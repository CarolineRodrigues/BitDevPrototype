{"version":3,"sources":["isolator.main.runtime.ts"],"names":["DEFAULT_CAPSULES_BASE_DIR","path","join","CACHE_ROOT","DEFAULT_ISOLATE_INSTALL_OPTIONS","installPackages","dedupe","installPeersFromEnvs","copyPeerToRuntimeOnComponents","copyPeerToRuntimeOnRoot","IsolatorMain","provider","dependencyResolver","loggerExtension","componentAspect","graphAspect","globalConfig","logger","createLogger","IsolatorAspect","id","isolator","constructor","graphBuilder","isolateComponents","seeders","opts","legacyScope","host","getHost","legacyLogger","debug","JSON","stringify","Object","assign","name","createGraphOpts","componentsToIsolate","seedersOnly","getMany","createGraph","baseDir","capsuleList","createCapsules","Network","getCapsulesRootDir","rootBaseDir","getGraphOpts","graph","getGraph","successorsSubgraph","map","toString","compsAndDeps","nodes","node","attr","existingCompsP","c","existing","includeFromNestedHosts","hasIdNested","hasId","undefined","existingComps","Promise","all","components","config","capsulesDir","emptyRootDir","fs","emptyDir","capsules","createCapsulesFromComponents","CapsuleList","fromArray","getExistingAsIs","skipIfExists","existingCapsules","filter","capsule","existsSync","length","capsulesWithPackagesData","getCapsulesPreviousPackageJson","writeComponentsInCapsules","updateWithCurrentPackageJsonData","installOptions","installInCapsules","cachePackagesOnCapsulesRoot","linkInCapsules","linkingOptions","forEach","capsuleWithPackageData","currentPackageJson","Error","component","writeFileSync","PACKAGE_JSON","isolateInstallOptions","installer","getInstaller","rootDir","cacheRootDirectory","peerOnlyPolicy","getWorkspacePeersOnlyPolicy","installTeambitBit","packageManagerConfigRootDir","packageManagerInstallOptions","overrides","capsulesOverrides","install","toComponentMap","linker","getLinker","capsulesWithModifiedPackageJson","getCapsulesWithModifiedPackageJson","link","legacyLink","packageJsonHasChanged","wereDependenciesInPackageJsonChanged","legacyComponents","state","_consumer","clone","allIds","BitIds","getCapsule","params","getComponentWriteParams","componentWriter","ComponentWriter","populateComponentsFilesToWrite","dataToPersist","persistAllToCapsule","keepExistingCapsule","workspacePolicy","getWorkspacePolicy","byLifecycleType","ids","bitMap","BitMap","writeToPath","origin","consumer","scope","override","writePackageJson","writeConfig","ignoreBitDependencies","excludeRegistryPrefix","isolated","tuples","ComponentMap","create","list","workspacePath","workspaceCapsuleFolder","readdir","capsuleFullPaths","workspace","e","code","capsulesRootBaseDir","getRootDirOfAllCapsules","deleteCapsules","capsuleBaseDir","dirToDelete","remove","Capsule","createFromComponent","getSync","CFG_CAPSULES_ROOT_BASE_DIR","previousPackageJson","DEPENDENCIES_FIELDS","some","field","packageJsonPath","previousPackageJsonRaw","promises","readFile","encoding","parse","updateP","packageJson","getCurrentPackageJson","found","isEqual","packageJsonObject","currentVersion","getComponentPackageVersionWithCache","getComponentDepsManifest","dependencies","manifest","devDependencies","compDeps","toTypeArray","dep","depCapsule","componentId","version","keyName","KEY_NAME_BY_LIFECYCLE_TYPE","lifecycle","entry","toManifest","packageName","deps","getDependencies","PackageJsonFile","loadFromCapsuleSync","addDependencies","packageJsonFile","addDevDependencies","addOrUpdateProperty","idStr","_componentsPackagesVersionCache","MainRuntime","DependencyResolverAspect","LoggerAspect","ComponentAspect","GraphAspect","GlobalConfigAspect","addRuntime"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAWA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAOA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;AAEA,MAAMA,yBAAyB,GAAGC,gBAAKC,IAAL,CAAUC,uBAAV,EAAsB,UAAtB,CAAlC,C,CAAqE;;;AAiGrE,MAAMC,+BAAgE,GAAG;AACvEC,EAAAA,eAAe,EAAE,IADsD;AAEvEC,EAAAA,MAAM,EAAE,IAF+D;AAGvEC,EAAAA,oBAAoB,EAAE,IAHiD;AAIvEC,EAAAA,6BAA6B,EAAE,KAJwC;AAKvEC,EAAAA,uBAAuB,EAAE;AAL8C,CAAzE;;AAQO,MAAMC,YAAN,CAAmB;AAI2C;AAE9C,eAARC,QAAQ,CAAC,CAACC,kBAAD,EAAqBC,eAArB,EAAsCC,eAAtC,EAAuDC,WAAvD,EAAoEC,YAApE,CAAD,EAMK;AACxB,UAAMC,MAAM,GAAGJ,eAAe,CAACK,YAAhB,CAA6BC,2BAAeC,EAA5C,CAAf;AACA,UAAMC,QAAQ,GAAG,IAAIX,YAAJ,CAAiBE,kBAAjB,EAAqCK,MAArC,EAA6CH,eAA7C,EAA8DC,WAA9D,EAA2EC,YAA3E,CAAjB;AACA,WAAOK,QAAP;AACD;;AACDC,EAAAA,WAAW,CACDV,kBADC,EAEDK,MAFC,EAGDH,eAHC,EAIDS,YAJC,EAKDP,YALC,EAMT;AAAA,SALQJ,kBAKR,GALQA,kBAKR;AAAA,SAJQK,MAIR,GAJQA,MAIR;AAAA,SAHQH,eAGR,GAHQA,eAGR;AAAA,SAFQS,YAER,GAFQA,YAER;AAAA,SADQP,YACR,GADQA,YACR;AAAA,6EAnB6D,EAmB7D;AAAE,GAvBoB,CAyBxB;AACA;;;AACuB,QAAjBQ,iBAAiB,CACrBC,OADqB,EAErBC,IAA8B,GAAG,EAFZ,EAGrBC,WAHqB,EAIH;AAAA;;AAClB,UAAMC,IAAI,GAAG,KAAKd,eAAL,CAAqBe,OAArB,EAAb;;AACAC,sBAAaC,KAAb,CACG,8BAA6BN,OAAO,CAACvB,IAAR,CAAa,IAAb,CAAmB,WAAU8B,IAAI,CAACC,SAAL,CACzDC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBT,IAAlB,EAAwB;AAAEE,MAAAA,IAAI,gBAAEF,IAAI,CAACE,IAAP,+CAAE,WAAWQ;AAAnB,KAAxB,CADyD,CAEzD,EAHJ;;AAKA,UAAMC,eAAe,GAAG,oBAAKX,IAAL,EAAW,CAAC,wBAAD,EAA2B,MAA3B,CAAX,CAAxB;AACA,UAAMY,mBAAmB,GAAGZ,IAAI,CAACa,WAAL,GACxB,MAAMX,IAAI,CAACY,OAAL,CAAaf,OAAb,CADkB,GAExB,MAAM,KAAKgB,WAAL,CAAiBhB,OAAjB,EAA0BY,eAA1B,CAFV;AAGAX,IAAAA,IAAI,CAACgB,OAAL,GAAehB,IAAI,CAACgB,OAAL,IAAgBd,IAAI,CAAC3B,IAApC;AACA,UAAM0C,WAAW,GAAG,MAAM,KAAKC,cAAL,CAAoBN,mBAApB,EAAyCZ,IAAzC,EAA+CC,WAA/C,CAA1B;AACA,WAAO,KAAIkB,kBAAJ,EAAYF,WAAZ,EAAyBlB,OAAzB,EAAkC,KAAKqB,kBAAL,CAAwBpB,IAAI,CAACgB,OAA7B,EAAsChB,IAAI,CAACqB,WAA3C,CAAlC,CAAP;AACD;;AAEwB,QAAXN,WAAW,CAAChB,OAAD,EAAyBC,IAAwB,GAAG,EAApD,EAA8E;AACrG,UAAME,IAAI,GAAG,KAAKd,eAAL,CAAqBe,OAArB,EAAb;AACA,UAAMmB,YAAY,GAAG,oBAAKtB,IAAL,EAAW,CAAC,MAAD,CAAX,CAArB;AACA,UAAMuB,KAAK,GAAG,MAAM,KAAK1B,YAAL,CAAkB2B,QAAlB,CAA2BzB,OAA3B,EAAoCuB,YAApC,CAApB;AACA,UAAMG,kBAAkB,GAAGF,KAAK,CAACE,kBAAN,CAAyB1B,OAAO,CAAC2B,GAAR,CAAahC,EAAD,IAAQA,EAAE,CAACiC,QAAH,EAApB,CAAzB,CAA3B;AACA,UAAMC,YAAY,GAAGH,kBAAkB,CAACI,KAAnB,CAAyBH,GAAzB,CAA8BI,IAAD,IAAUA,IAAI,CAACC,IAA5C,CAArB,CALqG,CAMrG;AACA;;AACA,UAAMC,cAAc,GAAGJ,YAAY,CAACF,GAAb,CAAiB,MAAOO,CAAP,IAAa;AACnD,UAAIC,QAAJ;;AACA,UAAIlC,IAAI,CAACmC,sBAAT,EAAiC;AAC/BD,QAAAA,QAAQ,GAAG,MAAMhC,IAAI,CAACkC,WAAL,CAAiBH,CAAC,CAACvC,EAAnB,EAAuB,IAAvB,CAAjB;AACD,OAFD,MAEO;AACLwC,QAAAA,QAAQ,GAAG,MAAMhC,IAAI,CAACmC,KAAL,CAAWJ,CAAC,CAACvC,EAAb,CAAjB;AACD;;AACD,UAAIwC,QAAJ,EAAc,OAAOD,CAAP;AACd,aAAOK,SAAP;AACD,KATsB,CAAvB;AAUA,UAAMC,aAAa,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYT,cAAZ,CAA5B;AACA,WAAO,uBAAQO,aAAR,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAC8B,QAAdrB,cAAc,CAC1BwB,UAD0B,EAE1B1C,IAF0B,EAG1BC,WAH0B,EAIJ;AACtB,UAAM0C,MAAM;AAAKhE,MAAAA,eAAe,EAAE;AAAtB,OAA+BqB,IAA/B,CAAZ;;AACA,UAAM4C,WAAW,GAAG,KAAKxB,kBAAL,CAAwBpB,IAAI,CAACgB,OAA7B,EAAgDhB,IAAI,CAACqB,WAArD,CAApB;;AACA,QAAIrB,IAAI,CAAC6C,YAAT,EAAuB;AACrB,YAAMC,mBAAGC,QAAH,CAAYH,WAAZ,CAAN;AACD;;AACD,UAAMI,QAAQ,GAAG,MAAM,KAAKC,4BAAL,CAAkCP,UAAlC,EAA8CE,WAA9C,EAA2DD,MAA3D,CAAvB;;AACA,UAAM1B,WAAW,GAAGiC,uBAAYC,SAAZ,CAAsBH,QAAtB,CAApB;;AACA,QAAIhD,IAAI,CAACoD,eAAT,EAA0B;AACxB,aAAOnC,WAAP;AACD;;AAED,QAAIjB,IAAI,CAACqD,YAAT,EAAuB;AACrB,YAAMC,gBAAgB,GAAGJ,uBAAYC,SAAZ,CACvBlC,WAAW,CAACsC,MAAZ,CAAoBC,OAAD,IAAaA,OAAO,CAACV,EAAR,CAAWW,UAAX,CAAsB,cAAtB,CAAhC,CADuB,CAAzB;;AAIA,UAAIH,gBAAgB,CAACI,MAAjB,KAA4BzC,WAAW,CAACyC,MAA5C,EAAoD,OAAOJ,gBAAP;AACrD;;AACD,UAAMK,wBAAwB,GAAG,MAAM,KAAKC,8BAAL,CAAoCZ,QAApC,CAAvC;AAEA,UAAM,KAAKa,yBAAL,CAA+BnB,UAA/B,EAA2CzB,WAA3C,EAAwDhB,WAAxD,CAAN;AACA,UAAM,KAAK6D,gCAAL,CAAsCH,wBAAtC,EAAgE1C,WAAhE,CAAN;AACA,UAAM8C,cAAc,GAAGvD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB/B,+BAAlB,EAAmDsB,IAAI,CAAC+D,cAAL,IAAuB,EAA1E,CAAvB;;AACA,QAAIA,cAAc,CAACpF,eAAnB,EAAoC;AAAA;;AAClC,YAAM,KAAKqF,iBAAL,CAAuBpB,WAAvB,EAAoC3B,WAApC,EAAiD8C,cAAjD,2BAAiE/D,IAAI,CAACiE,2BAAtE,yEAAqG,KAArG,CAAN;AACA,YAAM,KAAKC,cAAL,CAAoBtB,WAApB,EAAiC3B,WAAjC,EAA8C0C,wBAA9C,0BAAwE3D,IAAI,CAACmE,cAA7E,uEAA+F,EAA/F,CAAN;AACD,KA3BqB,CA6BtB;AACA;AACA;;;AACAR,IAAAA,wBAAwB,CAACS,OAAzB,CAAkCC,sBAAD,IAA4B;AAC3D,YAAM;AAAEC,QAAAA,kBAAF;AAAsBd,QAAAA;AAAtB,UAAkCa,sBAAxC;AACA,UAAI,CAACC,kBAAL,EACE,MAAM,IAAIC,KAAJ,CACH,kEAAiEf,OAAO,CAACgB,SAAR,CAAkB9E,EAAlB,CAAqBiC,QAArB,EAAgC,EAD9F,CAAN;AAGF0C,MAAAA,sBAAsB,CAACb,OAAvB,CAA+BV,EAA/B,CAAkC2B,aAAlC,CAAgDC,yBAAhD,EAA8DpE,IAAI,CAACC,SAAL,CAAe+D,kBAAf,EAAmC,IAAnC,EAAyC,CAAzC,CAA9D;AACD,KAPD;AASA,WAAOrD,WAAP;AACD;;AAE8B,QAAjB+C,iBAAiB,CAC7BpB,WAD6B,EAE7B3B,WAF6B,EAG7B0D,qBAH6B,EAI7BV,2BAJ6B,EAK7B;AACA,UAAMW,SAAS,GAAG,KAAK1F,kBAAL,CAAwB2F,YAAxB,CAAqC;AACrDC,MAAAA,OAAO,EAAElC,WAD4C;AAErDmC,MAAAA,kBAAkB,EAAEd,2BAA2B,GAAGrB,WAAH,GAAiBN;AAFX,KAArC,CAAlB,CADA,CAKA;AACA;;AAEA,UAAM0C,cAAc,GAAG,KAAKC,2BAAL,EAAvB;AACA,UAAMlB,cAA8B,GAAG;AACrCmB,MAAAA,iBAAiB,EAAE,CAAC,CAACP,qBAAqB,CAACO,iBADN;AAErCC,MAAAA,2BAA2B,EAAER,qBAAqB,CAACQ;AAFd,KAAvC;AAKA,UAAMC,4BAA0D,GAAG;AACjExG,MAAAA,MAAM,EAAE+F,qBAAqB,CAAC/F,MADmC;AAEjEE,MAAAA,6BAA6B,EAAE6F,qBAAqB,CAAC7F,6BAFY;AAGjEC,MAAAA,uBAAuB,EAAE4F,qBAAqB,CAAC5F,uBAHkB;AAIjEF,MAAAA,oBAAoB,EAAE8F,qBAAqB,CAAC9F,oBAJqB;AAKjEwG,MAAAA,SAAS,EAAE,KAAKnG,kBAAL,CAAwByD,MAAxB,CAA+B2C,iBAA/B,IAAoD,KAAKpG,kBAAL,CAAwByD,MAAxB,CAA+B0C;AAL7B,KAAnE;AAOA,UAAMT,SAAS,CAACW,OAAV,CACJ3C,WADI,EAEJoC,cAFI,EAGJ,KAAKQ,cAAL,CAAoBvE,WAApB,CAHI,EAIJ8C,cAJI,EAKJqB,4BALI,CAAN;AAOD;;AAE2B,QAAdlB,cAAc,CAC1BtB,WAD0B,EAE1B3B,WAF0B,EAG1B0C,wBAH0B,EAI1BQ,cAJ0B,EAK1B;AACA,UAAMsB,MAAM,GAAG,KAAKvG,kBAAL,CAAwBwG,SAAxB,CAAkC;AAC/CZ,MAAAA,OAAO,EAAElC,WADsC;AAE/CuB,MAAAA;AAF+C,KAAlC,CAAf;AAIA,UAAMa,cAAc,GAAG,KAAKC,2BAAL,EAAvB;AACA,UAAMU,+BAA+B,GAAG,KAAKC,kCAAL,CAAwCjC,wBAAxC,CAAxC;AACA,UAAM8B,MAAM,CAACI,IAAP,CAAYjD,WAAZ,EAAyBoC,cAAzB,EAAyC,KAAKQ,cAAL,CAAoBvE,WAApB,CAAzC,kCACDkD,cADC;AAEJ2B,MAAAA,UAAU,EAAE;AAFR,OAAN;AAIA,UAAM,2DAAqB7E,WAArB,EAAkC,KAAK1B,MAAvC,EAA+CqD,WAA/C,CAAN;AACA,UAAM,oEAA8B+C,+BAA9B,EAA+D1E,WAA/D,EAA4E,KAAK1B,MAAjF,CAAN,CAZA,CAaA;AACA;;AACA,UAAM,8DAA2BoG,+BAA3B,EAA4D,KAAKpG,MAAjE,CAAN,CAfA,CAgBA;AACD;;AAEOqG,EAAAA,kCAAkC,CAACjC,wBAAD,EAAqD;AAC7F,UAAMgC,+BAA0C,GAAGhC,wBAAwB,CACxEJ,MADgD,CACxCc,sBAAD,IAA4B;AAClC,YAAM0B,qBAAqB,GAAG,KAAKC,oCAAL,CAA0C3B,sBAA1C,CAA9B,CADkC,CAElC;AACA;;AACA,aAAO0B,qBAAP;AACD,KANgD,EAOhDrE,GAPgD,CAO3C2C,sBAAD,IAA4BA,sBAAsB,CAACb,OAPP,CAAnD;AAQA,WAAOmC,+BAAP;AACD;;AAEsC,QAAzB9B,yBAAyB,CAACnB,UAAD,EAA0BzB,WAA1B,EAAoDhB,WAApD,EAAyE;AAC9G,UAAMgG,gBAAgB,GAAGvD,UAAU,CAAChB,GAAX,CAAgB8C,SAAD,IAAeA,SAAS,CAAC0B,KAAV,CAAgBC,SAAhB,CAA0BC,KAA1B,EAA9B,CAAzB;AACA,QAAInG,WAAJ,EAAiB,MAAM,mDAA6BA,WAA7B,EAA0CgG,gBAA1C,CAAN;;AACjB,UAAMI,MAAM,GAAGC,gBAAOnD,SAAP,CAAiB8C,gBAAgB,CAACvE,GAAjB,CAAsBO,CAAD,IAAOA,CAAC,CAACvC,EAA9B,CAAjB,CAAf;;AACA,UAAM8C,OAAO,CAACC,GAAR,CACJC,UAAU,CAAChB,GAAX,CAAe,MAAO8C,SAAP,IAAqB;AAClC,YAAMhB,OAAO,GAAGvC,WAAW,CAACsF,UAAZ,CAAuB/B,SAAS,CAAC9E,EAAjC,CAAhB;AACA,UAAI,CAAC8D,OAAL,EAAc;AACd,YAAMgD,MAAM,GAAG,KAAKC,uBAAL,CAA6BjC,SAAS,CAAC0B,KAAV,CAAgBC,SAA7C,EAAwDE,MAAxD,EAAgEpG,WAAhE,CAAf;AACA,YAAMyG,eAAe,GAAG,KAAIC,0BAAJ,EAAoBH,MAApB,CAAxB;AACA,YAAME,eAAe,CAACE,8BAAhB,EAAN;AACA,YAAMpC,SAAS,CAAC0B,KAAV,CAAgBC,SAAhB,CAA0BU,aAA1B,CAAwCC,mBAAxC,CAA4DtD,OAA5D,EAAqE;AAAEuD,QAAAA,mBAAmB,EAAE;AAAvB,OAArE,CAAN;AACD,KAPD,CADI,CAAN;AAUD;;AAEO9B,EAAAA,2BAA2B,GAAoB;AACrD,UAAM+B,eAAe,GAAG,KAAK9H,kBAAL,CAAwB+H,kBAAxB,EAAxB;AACA,UAAMjC,cAAc,GAAGgC,eAAe,CAACE,eAAhB,CAAgC,MAAhC,CAAvB;AACA,WAAOlC,cAAP;AACD;;AAEOyB,EAAAA,uBAAuB,CAC7BjC,SAD6B,EAE7B2C,GAF6B,EAG7BlH,WAH6B,EAIP;AACtB,WAAO;AACLuE,MAAAA,SADK;AAEL;AACA4C,MAAAA,MAAM,EAAE,KAAIC,iBAAJ,EAAW/E,SAAX,EAAsBA,SAAtB,EAAiCA,SAAjC,EAA4C,KAA5C,CAHH;AAILgF,MAAAA,WAAW,EAAE,GAJR;AAKLC,MAAAA,MAAM,EAAE,UALH;AAMLC,MAAAA,QAAQ,EAAElF,SANL;AAOLmF,MAAAA,KAAK,EAAExH,WAPF;AAQLyH,MAAAA,QAAQ,EAAE,KARL;AASLC,MAAAA,gBAAgB,EAAE,IATb;AAULC,MAAAA,WAAW,EAAE,KAVR;AAWLC,MAAAA,qBAAqB,EAAEV,GAXlB;AAYLW,MAAAA,qBAAqB,EAAE,KAZlB;AAaLC,MAAAA,QAAQ,EAAE;AAbL,KAAP;AAeD;;AAEOvC,EAAAA,cAAc,CAACvE,WAAD,EAAiD;AACrE,UAAM+G,MAA6B,GAAG/G,WAAW,CAACS,GAAZ,CAAiB8B,OAAD,IAAa;AACjE,aAAO,CAACA,OAAO,CAACgB,SAAT,EAAoBhB,OAAO,CAACjF,IAA5B,CAAP;AACD,KAFqC,CAAtC;AAIA,WAAO0J,0BAAaC,MAAb,CAAoBF,MAApB,CAAP;AACD;;AAES,QAAJG,IAAI,CAACC,aAAD,EAA8C;AACtD,QAAI;AACF,YAAMC,sBAAsB,GAAG,KAAKjH,kBAAL,CAAwBgH,aAAxB,CAA/B;AACA,YAAMpF,QAAQ,GAAG,MAAMF,mBAAGwF,OAAH,CAAWD,sBAAX,CAAvB;AACA,YAAME,gBAAgB,GAAGvF,QAAQ,CAACtB,GAAT,CAAcO,CAAD,IAAO1D,gBAAKC,IAAL,CAAU6J,sBAAV,EAAkCpG,CAAlC,CAApB,CAAzB;AACA,aAAO;AACLuG,QAAAA,SAAS,EAAEJ,aADN;AAELpF,QAAAA,QAAQ,EAAEuF;AAFL,OAAP;AAID,KARD,CAQE,OAAOE,CAAP,EAAe;AACf,UAAIA,CAAC,CAACC,IAAF,KAAW,QAAf,EAAyB;AACvB,eAAO;AAAEF,UAAAA,SAAS,EAAEJ,aAAb;AAA4BpF,UAAAA,QAAQ,EAAE;AAAtC,SAAP;AACD;;AACD,YAAMyF,CAAN;AACD;AACF;;AAEDrH,EAAAA,kBAAkB,CAACJ,OAAD,EAAkBK,WAAlB,EAA6D;AAC7E,UAAMsH,mBAAmB,GAAGtH,WAAW,IAAI,KAAKuH,uBAAL,EAA3C;AACA,WAAOrK,gBAAKC,IAAL,CAAUmK,mBAAV,EAA+B,2BAAK3H,OAAL,CAA/B,CAAP;AACD;;AAEmB,QAAd6H,cAAc,CAACC,cAAD,EAAiD;AACnE,UAAMC,WAAW,GAAGD,cAAc,GAAG,KAAK1H,kBAAL,CAAwB0H,cAAxB,CAAH,GAA6C,KAAKF,uBAAL,EAA/E;AACA,UAAM9F,mBAAGkG,MAAH,CAAUD,WAAV,CAAN;AACA,WAAOA,WAAP;AACD;;AAEyC,QAA5B9F,4BAA4B,CACxCP,UADwC,EAExC1B,OAFwC,EAGxChB,IAHwC,EAIpB;AACpB,UAAMgD,QAAmB,GAAG,MAAMR,OAAO,CAACC,GAAR,CAChCC,UAAU,CAAChB,GAAX,CAAgB8C,SAAD,IAA0B;AACvC,aAAOyE,mBAAQC,mBAAR,CAA4B1E,SAA5B,EAAuCxD,OAAvC,EAAgDhB,IAAhD,CAAP;AACD,KAFD,CADgC,CAAlC;AAKA,WAAOgD,QAAP;AACD;;AAEO4F,EAAAA,uBAAuB,GAAW;AACxC,WAAO,KAAKtJ,YAAL,CAAkB6J,OAAlB,CAA0BC,uCAA1B,KAAyD9K,yBAAhE;AACD;;AAEO0H,EAAAA,oCAAoC,CAAC3B,sBAAD,EAA0D;AACpG,UAAM;AAAEgF,MAAAA,mBAAF;AAAuB/E,MAAAA;AAAvB,QAA8CD,sBAApD;AACA,QAAI,CAACgF,mBAAL,EAA0B,OAAO,IAAP,CAF0E,CAGpG;;AACA,WAAOC,iCAAoBC,IAApB,CAA0BC,KAAD,IAAW,CAAC,uBAAOH,mBAAmB,CAACG,KAAD,CAA1B,EAAmClF,kBAAkB,CAACkF,KAAD,CAArD,CAArC,CAAP;AACD;;AAE2C,QAA9B5F,8BAA8B,CAACZ,QAAD,EAAyD;AACnG,WAAOR,OAAO,CAACC,GAAR,CACLO,QAAQ,CAACtB,GAAT,CAAa,MAAO8B,OAAP,IAAmB;AAC9B,YAAMiG,eAAe,GAAGlL,gBAAKC,IAAL,CAAUgF,OAAO,CAACjF,IAAlB,EAAwB,cAAxB,CAAxB;;AACA,UAAI8K,mBAAwB,GAAG,IAA/B;;AACA,UAAI;AACF,cAAMK,sBAAsB,GAAG,MAAMlG,OAAO,CAACV,EAAR,CAAW6G,QAAX,CAAoBC,QAApB,CAA6BH,eAA7B,EAA8C;AAAEI,UAAAA,QAAQ,EAAE;AAAZ,SAA9C,CAArC;AACAR,QAAAA,mBAAmB,GAAG/I,IAAI,CAACwJ,KAAL,CAAWJ,sBAAX,CAAtB;AACD,OAHD,CAGE,OAAOjB,CAAP,EAAe,CACf;AACD;;AACD,aAAO;AACLjF,QAAAA,OADK;AAEL6F,QAAAA;AAFK,OAAP;AAID,KAbD,CADK,CAAP;AAgBD;;AAE6C,QAAhCvF,gCAAgC,CAC5CH,wBAD4C,EAE5CX,QAF4C,EAG5C;AACA,UAAM+G,OAAO,GAAG/G,QAAQ,CAACtB,GAAT,CAAa,MAAO8B,OAAP,IAAmB;AAC9C,YAAMwG,WAAW,GAAG,MAAM,KAAKC,qBAAL,CAA2BzG,OAA3B,EAAoCR,QAApC,CAA1B;AACA,YAAMkH,KAAK,GAAGvG,wBAAwB,CAACJ,MAAzB,CAAiCtB,CAAD,IAAOA,CAAC,CAACuB,OAAF,CAAUgB,SAAV,CAAoB9E,EAApB,CAAuByK,OAAvB,CAA+B3G,OAAO,CAACgB,SAAR,CAAkB9E,EAAjD,CAAvC,CAAd;AACA,UAAI,CAACwK,KAAK,CAACxG,MAAX,EAAmB,MAAM,IAAIa,KAAJ,CAAW,mDAAkDf,OAAO,CAACgB,SAAR,CAAkB9E,EAAG,EAAlF,CAAN;AACnB,UAAIwK,KAAK,CAACxG,MAAN,GAAe,CAAnB,EACE,MAAM,IAAIa,KAAJ,CACH,8DAA6Df,OAAO,CAACgB,SAAR,CAAkB9E,EAAlB,CAAqBiC,QAArB,EAAgC,IAD1F,CAAN;AAGFuI,MAAAA,KAAK,CAAC,CAAD,CAAL,CAAS5F,kBAAT,GAA8B0F,WAAW,CAACI,iBAA1C;AACD,KATe,CAAhB;AAUA,WAAO5H,OAAO,CAACC,GAAR,CAAYsH,OAAZ,CAAP;AACD;;AAEkC,QAArBE,qBAAqB,CAACzG,OAAD,EAAmBR,QAAnB,EAAoE;AACrG,UAAMwB,SAAoB,GAAGhB,OAAO,CAACgB,SAArC;AACA,UAAM6F,cAAc,GAAG,MAAM,KAAKC,mCAAL,CAAyC9F,SAAzC,CAA7B,CAFqG,CAGrG;;AACA,UAAM+F,wBAAwB,GAAG,MAAOC,YAAP,IAAwC;AACvE,YAAMC,QAAQ,GAAG;AACfD,QAAAA,YAAY,EAAE,EADC;AAEfE,QAAAA,eAAe,EAAE;AAFF,OAAjB;AAIA,YAAMC,QAAQ,GAAGH,YAAY,CAACI,WAAb,CAA8C,WAA9C,CAAjB;AACA,YAAMjB,QAAQ,GAAGgB,QAAQ,CAACjJ,GAAT,CAAa,MAAOmJ,GAAP,IAAe;AAC3C,cAAMC,UAAU,GAAG9H,QAAQ,CAACuD,UAAT,CAAoBsE,GAAG,CAACE,WAAxB,CAAnB;AACA,YAAIC,OAAO,GAAGH,GAAG,CAACG,OAAlB;;AACA,YAAIF,UAAJ,EAAgB;AACdE,UAAAA,OAAO,GAAG,MAAM,KAAKV,mCAAL,CAAyCQ,UAAzC,aAAyCA,UAAzC,uBAAyCA,UAAU,CAAEtG,SAArD,CAAhB;AACD;;AACD,cAAMyG,OAAO,GAAGC,iDAA2BL,GAAG,CAACM,SAA/B,CAAhB;;AACA,cAAMC,KAAK,GAAGP,GAAG,CAACQ,UAAJ,EAAd;;AACA,YAAID,KAAJ,EAAW;AACTX,UAAAA,QAAQ,CAACQ,OAAD,CAAR,CAAkBG,KAAK,CAACE,WAAxB,IAAuCN,OAAvC;AACD;AACF,OAXgB,CAAjB;AAYA,YAAMxI,OAAO,CAACC,GAAR,CAAYkH,QAAZ,CAAN;AACA,aAAOc,QAAP;AACD,KApBD;;AAqBA,UAAMc,IAAI,GAAG,MAAM,KAAKrM,kBAAL,CAAwBsM,eAAxB,CAAwChH,SAAxC,CAAnB;AACA,UAAMiG,QAAQ,GAAG,MAAMF,wBAAwB,CAACgB,IAAD,CAA/C,CA1BqG,CA4BrG;AACA;AACA;AACA;;AACA,UAAMvB,WAAW,GAAGyB,2BAAgBC,mBAAhB,CAAoClI,OAAO,CAACjF,IAA5C,CAApB;;AAEA,UAAMoN,eAAe,GAAIC,eAAD,IAAsC;AAC5DA,MAAAA,eAAe,CAACD,eAAhB,CAAgClB,QAAQ,CAACD,YAAzC;AACAoB,MAAAA,eAAe,CAACC,kBAAhB,CAAmCpB,QAAQ,CAACC,eAA5C;AACD,KAHD;;AAIAiB,IAAAA,eAAe,CAAC3B,WAAD,CAAf;AACAA,IAAAA,WAAW,CAAC8B,mBAAZ,CAAgC,SAAhC,EAA2CzB,cAA3C;AACA,WAAOL,WAAP;AACD;;AAEgD,QAAnCM,mCAAmC,CAAC9F,SAAD,EAAwC;AACvF,UAAMuH,KAAK,GAAGvH,SAAS,CAAC9E,EAAV,CAAaiC,QAAb,EAAd;;AACA,QAAI,KAAKqK,+BAAL,CAAqCD,KAArC,CAAJ,EAAiD;AAC/C,aAAO,KAAKC,+BAAL,CAAqCD,KAArC,CAAP;AACD;;AACD,UAAMf,OAAO,GAAG,MAAM,2DAA2BxG,SAA3B,CAAtB;AACA,SAAKwH,+BAAL,CAAqCD,KAArC,IAA8Cf,OAA9C;AACA,WAAOA,OAAP;AACD;;AAlYuB;;;gCAAbhM,Y,aACMiN,kB;gCADNjN,Y,kBAEW,CAACkN,8CAAD,EAA2BC,uBAA3B,EAAyCC,4BAAzC,EAA0DC,oBAA1D,EAAuEC,uBAAvE,C;gCAFXtN,Y,mBAGY,E;;AAkYzBS,2BAAe8M,UAAf,CAA0BvN,YAA1B","sourcesContent":["import { MainRuntime } from '@teambit/cli';\nimport { compact, pick } from 'lodash';\nimport { Component, ComponentMap, ComponentAspect, ComponentID } from '@teambit/component';\nimport type { ComponentMain, ComponentFactory } from '@teambit/component';\nimport { getComponentPackageVersion } from '@teambit/component-package-version';\nimport { GraphAspect } from '@teambit/graph';\nimport type { GraphBuilder } from '@teambit/graph';\nimport {\n  DependencyResolverAspect,\n  DependencyResolverMain,\n  LinkingOptions,\n  WorkspacePolicy,\n  InstallOptions,\n  DependencyList,\n  ComponentDependency,\n  KEY_NAME_BY_LIFECYCLE_TYPE,\n  PackageManagerInstallOptions,\n} from '@teambit/dependency-resolver';\nimport legacyLogger from '@teambit/legacy/dist/logger/logger';\nimport { Logger, LoggerAspect, LoggerMain } from '@teambit/logger';\nimport { BitIds } from '@teambit/legacy/dist/bit-id';\nimport LegacyScope from '@teambit/legacy/dist/scope/scope';\nimport GlobalConfigAspect, { GlobalConfigMain } from '@teambit/global-config';\nimport {\n  CACHE_ROOT,\n  DEPENDENCIES_FIELDS,\n  PACKAGE_JSON,\n  CFG_CAPSULES_ROOT_BASE_DIR,\n} from '@teambit/legacy/dist/constants';\nimport ConsumerComponent from '@teambit/legacy/dist/consumer/component';\nimport PackageJsonFile from '@teambit/legacy/dist/consumer/component/package-json-file';\nimport { importMultipleDistsArtifacts } from '@teambit/legacy/dist/consumer/component/sources/artifact-files';\nimport { PathOsBasedAbsolute } from '@teambit/legacy/dist/utils/path';\nimport { Scope } from '@teambit/legacy/dist/scope';\nimport fs from 'fs-extra';\nimport hash from 'object-hash';\nimport path from 'path';\nimport equals from 'ramda/src/equals';\nimport BitMap from '@teambit/legacy/dist/consumer/bit-map';\nimport ComponentWriter, { ComponentWriterProps } from '@teambit/legacy/dist/consumer/component-ops/component-writer';\nimport { Capsule } from './capsule';\nimport CapsuleList from './capsule-list';\nimport { IsolatorAspect } from './isolator.aspect';\nimport { symlinkBitLegacyToCapsules } from './symlink-bit-legacy-to-capsules';\nimport { symlinkOnCapsuleRoot, symlinkDependenciesToCapsules } from './symlink-dependencies-to-capsules';\nimport { Network } from './network';\n\nconst DEFAULT_CAPSULES_BASE_DIR = path.join(CACHE_ROOT, 'capsules'); // TODO: move elsewhere\n\nexport type ListResults = {\n  workspace: string;\n  capsules: string[];\n};\n\nexport type IsolateComponentsInstallOptions = {\n  installPackages?: boolean; // default: true\n  // TODO: add back when depResolver.getInstaller support it\n  // packageManager?: string;\n  dedupe?: boolean;\n  copyPeerToRuntimeOnComponents?: boolean;\n  copyPeerToRuntimeOnRoot?: boolean;\n  installPeersFromEnvs?: boolean;\n  installTeambitBit?: boolean;\n  packageManagerConfigRootDir?: string;\n};\n\ntype CreateGraphOptions = {\n  /**\n   * include components that exists in nested hosts. for example include components that exist in scope but not in the workspace\n   */\n  includeFromNestedHosts?: boolean;\n\n  /**\n   * Force specific host to get the component from.\n   */\n  host?: ComponentFactory;\n};\n\nexport type IsolateComponentsOptions = CreateGraphOptions & {\n  name?: string;\n  /**\n   * absolute path to put all the capsules dirs inside.\n   */\n  rootBaseDir?: string;\n\n  /**\n   * the capsule root-dir based on a *hash* of this baseDir, not on the baseDir itself.\n   * A folder with this hash as its name will be created in the rootBaseDir\n   * By default this value will be the host path\n   */\n  baseDir?: string;\n\n  /**\n   * create a new capsule with a random string attached to the path suffix\n   */\n  alwaysNew?: boolean;\n\n  /**\n   * installation options\n   */\n  installOptions?: IsolateComponentsInstallOptions;\n\n  linkingOptions?: LinkingOptions;\n\n  /**\n   * delete the capsule rootDir first. it makes sure that the isolation process starts fresh with\n   * no previous capsules. for build and tag this is true.\n   */\n  emptyRootDir?: boolean;\n\n  /**\n   * skip the reproduction of the capsule in case it exists.\n   */\n  skipIfExists?: boolean;\n\n  /**\n   * get existing capsule without doing any changes, no writes, no installations.\n   */\n  getExistingAsIs?: boolean;\n\n  /**\n   * place the package-manager cache on the capsule-root\n   */\n  cachePackagesOnCapsulesRoot?: boolean;\n\n  /**\n   * do not build graph with all dependencies. isolate the seeders only.\n   */\n  seedersOnly?: boolean;\n\n  /**\n   * Force specific host to get the component from.\n   */\n  host?: ComponentFactory;\n\n  packageManagerConfigRootDir?: string;\n};\n\ntype CapsulePackageJsonData = {\n  capsule: Capsule;\n  currentPackageJson?: Record<string, any>;\n  previousPackageJson: Record<string, any> | null;\n};\n\nconst DEFAULT_ISOLATE_INSTALL_OPTIONS: IsolateComponentsInstallOptions = {\n  installPackages: true,\n  dedupe: true,\n  installPeersFromEnvs: true,\n  copyPeerToRuntimeOnComponents: false,\n  copyPeerToRuntimeOnRoot: true,\n};\n\nexport class IsolatorMain {\n  static runtime = MainRuntime;\n  static dependencies = [DependencyResolverAspect, LoggerAspect, ComponentAspect, GraphAspect, GlobalConfigAspect];\n  static defaultConfig = {};\n  _componentsPackagesVersionCache: { [idStr: string]: string } = {}; // cache packages versions of components\n\n  static async provider([dependencyResolver, loggerExtension, componentAspect, graphAspect, globalConfig]: [\n    DependencyResolverMain,\n    LoggerMain,\n    ComponentMain,\n    GraphBuilder,\n    GlobalConfigMain\n  ]): Promise<IsolatorMain> {\n    const logger = loggerExtension.createLogger(IsolatorAspect.id);\n    const isolator = new IsolatorMain(dependencyResolver, logger, componentAspect, graphAspect, globalConfig);\n    return isolator;\n  }\n  constructor(\n    private dependencyResolver: DependencyResolverMain,\n    private logger: Logger,\n    private componentAspect: ComponentMain,\n    private graphBuilder: GraphBuilder,\n    private globalConfig: GlobalConfigMain\n  ) {}\n\n  // TODO: the legacy scope used for the component writer, which then decide if it need to write the artifacts and dists\n  // TODO: we should think of another way to provide it (maybe a new opts) then take the scope internally from the host\n  async isolateComponents(\n    seeders: ComponentID[],\n    opts: IsolateComponentsOptions = {},\n    legacyScope?: LegacyScope\n  ): Promise<Network> {\n    const host = this.componentAspect.getHost();\n    legacyLogger.debug(\n      `isolatorExt, createNetwork ${seeders.join(', ')}. opts: ${JSON.stringify(\n        Object.assign({}, opts, { host: opts.host?.name })\n      )}`\n    );\n    const createGraphOpts = pick(opts, ['includeFromNestedHosts', 'host']);\n    const componentsToIsolate = opts.seedersOnly\n      ? await host.getMany(seeders)\n      : await this.createGraph(seeders, createGraphOpts);\n    opts.baseDir = opts.baseDir || host.path;\n    const capsuleList = await this.createCapsules(componentsToIsolate, opts, legacyScope);\n    return new Network(capsuleList, seeders, this.getCapsulesRootDir(opts.baseDir, opts.rootBaseDir));\n  }\n\n  private async createGraph(seeders: ComponentID[], opts: CreateGraphOptions = {}): Promise<Component[]> {\n    const host = this.componentAspect.getHost();\n    const getGraphOpts = pick(opts, ['host']);\n    const graph = await this.graphBuilder.getGraph(seeders, getGraphOpts);\n    const successorsSubgraph = graph.successorsSubgraph(seeders.map((id) => id.toString()));\n    const compsAndDeps = successorsSubgraph.nodes.map((node) => node.attr);\n    // do not ignore the version here. a component might be in .bitmap with one version and\n    // installed as a package with another version. we don't want them both.\n    const existingCompsP = compsAndDeps.map(async (c) => {\n      let existing;\n      if (opts.includeFromNestedHosts) {\n        existing = await host.hasIdNested(c.id, true);\n      } else {\n        existing = await host.hasId(c.id);\n      }\n      if (existing) return c;\n      return undefined;\n    });\n    const existingComps = await Promise.all(existingCompsP);\n    return compact(existingComps);\n  }\n\n  /**\n   * Create capsules for the provided components\n   * do not use this outside directly, use isolate components which build the entire network\n   * @param components\n   * @param opts\n   * @param legacyScope\n   */\n  private async createCapsules(\n    components: Component[],\n    opts: IsolateComponentsOptions,\n    legacyScope?: Scope\n  ): Promise<CapsuleList> {\n    const config = { installPackages: true, ...opts };\n    const capsulesDir = this.getCapsulesRootDir(opts.baseDir as string, opts.rootBaseDir);\n    if (opts.emptyRootDir) {\n      await fs.emptyDir(capsulesDir);\n    }\n    const capsules = await this.createCapsulesFromComponents(components, capsulesDir, config);\n    const capsuleList = CapsuleList.fromArray(capsules);\n    if (opts.getExistingAsIs) {\n      return capsuleList;\n    }\n\n    if (opts.skipIfExists) {\n      const existingCapsules = CapsuleList.fromArray(\n        capsuleList.filter((capsule) => capsule.fs.existsSync('package.json'))\n      );\n\n      if (existingCapsules.length === capsuleList.length) return existingCapsules;\n    }\n    const capsulesWithPackagesData = await this.getCapsulesPreviousPackageJson(capsules);\n\n    await this.writeComponentsInCapsules(components, capsuleList, legacyScope);\n    await this.updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsuleList);\n    const installOptions = Object.assign({}, DEFAULT_ISOLATE_INSTALL_OPTIONS, opts.installOptions || {});\n    if (installOptions.installPackages) {\n      await this.installInCapsules(capsulesDir, capsuleList, installOptions, opts.cachePackagesOnCapsulesRoot ?? false);\n      await this.linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, opts.linkingOptions ?? {});\n    }\n\n    // rewrite the package-json with the component dependencies in it. the original package.json\n    // that was written before, didn't have these dependencies in order for the package-manager to\n    // be able to install them without crushing when the versions don't exist yet\n    capsulesWithPackagesData.forEach((capsuleWithPackageData) => {\n      const { currentPackageJson, capsule } = capsuleWithPackageData;\n      if (!currentPackageJson)\n        throw new Error(\n          `isolator.createCapsules, unable to find currentPackageJson for ${capsule.component.id.toString()}`\n        );\n      capsuleWithPackageData.capsule.fs.writeFileSync(PACKAGE_JSON, JSON.stringify(currentPackageJson, null, 2));\n    });\n\n    return capsuleList;\n  }\n\n  private async installInCapsules(\n    capsulesDir: string,\n    capsuleList: CapsuleList,\n    isolateInstallOptions: IsolateComponentsInstallOptions,\n    cachePackagesOnCapsulesRoot: boolean\n  ) {\n    const installer = this.dependencyResolver.getInstaller({\n      rootDir: capsulesDir,\n      cacheRootDirectory: cachePackagesOnCapsulesRoot ? capsulesDir : undefined,\n    });\n    // When using isolator we don't want to use the policy defined in the workspace directly,\n    // we only want to instal deps from components and the peer from the workspace\n\n    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();\n    const installOptions: InstallOptions = {\n      installTeambitBit: !!isolateInstallOptions.installTeambitBit,\n      packageManagerConfigRootDir: isolateInstallOptions.packageManagerConfigRootDir,\n    };\n\n    const packageManagerInstallOptions: PackageManagerInstallOptions = {\n      dedupe: isolateInstallOptions.dedupe,\n      copyPeerToRuntimeOnComponents: isolateInstallOptions.copyPeerToRuntimeOnComponents,\n      copyPeerToRuntimeOnRoot: isolateInstallOptions.copyPeerToRuntimeOnRoot,\n      installPeersFromEnvs: isolateInstallOptions.installPeersFromEnvs,\n      overrides: this.dependencyResolver.config.capsulesOverrides || this.dependencyResolver.config.overrides,\n    };\n    await installer.install(\n      capsulesDir,\n      peerOnlyPolicy,\n      this.toComponentMap(capsuleList),\n      installOptions,\n      packageManagerInstallOptions\n    );\n  }\n\n  private async linkInCapsules(\n    capsulesDir: string,\n    capsuleList: CapsuleList,\n    capsulesWithPackagesData: CapsulePackageJsonData[],\n    linkingOptions: LinkingOptions\n  ) {\n    const linker = this.dependencyResolver.getLinker({\n      rootDir: capsulesDir,\n      linkingOptions,\n    });\n    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();\n    const capsulesWithModifiedPackageJson = this.getCapsulesWithModifiedPackageJson(capsulesWithPackagesData);\n    await linker.link(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), {\n      ...linkingOptions,\n      legacyLink: false,\n    });\n    await symlinkOnCapsuleRoot(capsuleList, this.logger, capsulesDir);\n    await symlinkDependenciesToCapsules(capsulesWithModifiedPackageJson, capsuleList, this.logger);\n    // TODO: this is a hack to have access to the bit bin project in order to access core extensions from user extension\n    // TODO: remove this after exporting core extensions as components\n    await symlinkBitLegacyToCapsules(capsulesWithModifiedPackageJson, this.logger);\n    // await copyBitLegacyToCapsuleRoot(capsulesDir, this.logger);\n  }\n\n  private getCapsulesWithModifiedPackageJson(capsulesWithPackagesData: CapsulePackageJsonData[]) {\n    const capsulesWithModifiedPackageJson: Capsule[] = capsulesWithPackagesData\n      .filter((capsuleWithPackageData) => {\n        const packageJsonHasChanged = this.wereDependenciesInPackageJsonChanged(capsuleWithPackageData);\n        // @todo: when a component is tagged, it changes all package-json of its dependents, but it\n        // should not trigger any \"npm install\" because they dependencies are symlinked by us\n        return packageJsonHasChanged;\n      })\n      .map((capsuleWithPackageData) => capsuleWithPackageData.capsule);\n    return capsulesWithModifiedPackageJson;\n  }\n\n  private async writeComponentsInCapsules(components: Component[], capsuleList: CapsuleList, legacyScope?: Scope) {\n    const legacyComponents = components.map((component) => component.state._consumer.clone());\n    if (legacyScope) await importMultipleDistsArtifacts(legacyScope, legacyComponents);\n    const allIds = BitIds.fromArray(legacyComponents.map((c) => c.id));\n    await Promise.all(\n      components.map(async (component) => {\n        const capsule = capsuleList.getCapsule(component.id);\n        if (!capsule) return;\n        const params = this.getComponentWriteParams(component.state._consumer, allIds, legacyScope);\n        const componentWriter = new ComponentWriter(params);\n        await componentWriter.populateComponentsFilesToWrite();\n        await component.state._consumer.dataToPersist.persistAllToCapsule(capsule, { keepExistingCapsule: true });\n      })\n    );\n  }\n\n  private getWorkspacePeersOnlyPolicy(): WorkspacePolicy {\n    const workspacePolicy = this.dependencyResolver.getWorkspacePolicy();\n    const peerOnlyPolicy = workspacePolicy.byLifecycleType('peer');\n    return peerOnlyPolicy;\n  }\n\n  private getComponentWriteParams(\n    component: ConsumerComponent,\n    ids: BitIds,\n    legacyScope?: Scope\n  ): ComponentWriterProps {\n    return {\n      component,\n      // @ts-ignore\n      bitMap: new BitMap(undefined, undefined, undefined, false),\n      writeToPath: '.',\n      origin: 'IMPORTED',\n      consumer: undefined,\n      scope: legacyScope,\n      override: false,\n      writePackageJson: true,\n      writeConfig: false,\n      ignoreBitDependencies: ids,\n      excludeRegistryPrefix: false,\n      isolated: true,\n    };\n  }\n\n  private toComponentMap(capsuleList: CapsuleList): ComponentMap<string> {\n    const tuples: [Component, string][] = capsuleList.map((capsule) => {\n      return [capsule.component, capsule.path];\n    });\n\n    return ComponentMap.create(tuples);\n  }\n\n  async list(workspacePath: string): Promise<ListResults> {\n    try {\n      const workspaceCapsuleFolder = this.getCapsulesRootDir(workspacePath);\n      const capsules = await fs.readdir(workspaceCapsuleFolder);\n      const capsuleFullPaths = capsules.map((c) => path.join(workspaceCapsuleFolder, c));\n      return {\n        workspace: workspacePath,\n        capsules: capsuleFullPaths,\n      };\n    } catch (e: any) {\n      if (e.code === 'ENOENT') {\n        return { workspace: workspacePath, capsules: [] };\n      }\n      throw e;\n    }\n  }\n\n  getCapsulesRootDir(baseDir: string, rootBaseDir?: string): PathOsBasedAbsolute {\n    const capsulesRootBaseDir = rootBaseDir || this.getRootDirOfAllCapsules();\n    return path.join(capsulesRootBaseDir, hash(baseDir));\n  }\n\n  async deleteCapsules(capsuleBaseDir: string | null): Promise<string> {\n    const dirToDelete = capsuleBaseDir ? this.getCapsulesRootDir(capsuleBaseDir) : this.getRootDirOfAllCapsules();\n    await fs.remove(dirToDelete);\n    return dirToDelete;\n  }\n\n  private async createCapsulesFromComponents(\n    components: Component[],\n    baseDir: string,\n    opts: IsolateComponentsOptions\n  ): Promise<Capsule[]> {\n    const capsules: Capsule[] = await Promise.all(\n      components.map((component: Component) => {\n        return Capsule.createFromComponent(component, baseDir, opts);\n      })\n    );\n    return capsules;\n  }\n\n  private getRootDirOfAllCapsules(): string {\n    return this.globalConfig.getSync(CFG_CAPSULES_ROOT_BASE_DIR) || DEFAULT_CAPSULES_BASE_DIR;\n  }\n\n  private wereDependenciesInPackageJsonChanged(capsuleWithPackageData: CapsulePackageJsonData): boolean {\n    const { previousPackageJson, currentPackageJson } = capsuleWithPackageData;\n    if (!previousPackageJson) return true;\n    // @ts-ignore at this point, currentPackageJson is set\n    return DEPENDENCIES_FIELDS.some((field) => !equals(previousPackageJson[field], currentPackageJson[field]));\n  }\n\n  private async getCapsulesPreviousPackageJson(capsules: Capsule[]): Promise<CapsulePackageJsonData[]> {\n    return Promise.all(\n      capsules.map(async (capsule) => {\n        const packageJsonPath = path.join(capsule.path, 'package.json');\n        let previousPackageJson: any = null;\n        try {\n          const previousPackageJsonRaw = await capsule.fs.promises.readFile(packageJsonPath, { encoding: 'utf8' });\n          previousPackageJson = JSON.parse(previousPackageJsonRaw);\n        } catch (e: any) {\n          // package-json doesn't exist in the capsule, that's fine, it'll be considered as a cache miss\n        }\n        return {\n          capsule,\n          previousPackageJson,\n        };\n      })\n    );\n  }\n\n  private async updateWithCurrentPackageJsonData(\n    capsulesWithPackagesData: CapsulePackageJsonData[],\n    capsules: CapsuleList\n  ) {\n    const updateP = capsules.map(async (capsule) => {\n      const packageJson = await this.getCurrentPackageJson(capsule, capsules);\n      const found = capsulesWithPackagesData.filter((c) => c.capsule.component.id.isEqual(capsule.component.id));\n      if (!found.length) throw new Error(`updateWithCurrentPackageJsonData unable to find ${capsule.component.id}`);\n      if (found.length > 1)\n        throw new Error(\n          `updateWithCurrentPackageJsonData found duplicate capsules: ${capsule.component.id.toString()}\"\"`\n        );\n      found[0].currentPackageJson = packageJson.packageJsonObject;\n    });\n    return Promise.all(updateP);\n  }\n\n  private async getCurrentPackageJson(capsule: Capsule, capsules: CapsuleList): Promise<PackageJsonFile> {\n    const component: Component = capsule.component;\n    const currentVersion = await this.getComponentPackageVersionWithCache(component);\n    // const newVersion = '0.0.1-new';\n    const getComponentDepsManifest = async (dependencies: DependencyList) => {\n      const manifest = {\n        dependencies: {},\n        devDependencies: {},\n      };\n      const compDeps = dependencies.toTypeArray<ComponentDependency>('component');\n      const promises = compDeps.map(async (dep) => {\n        const depCapsule = capsules.getCapsule(dep.componentId);\n        let version = dep.version;\n        if (depCapsule) {\n          version = await this.getComponentPackageVersionWithCache(depCapsule?.component);\n        }\n        const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];\n        const entry = dep.toManifest();\n        if (entry) {\n          manifest[keyName][entry.packageName] = version;\n        }\n      });\n      await Promise.all(promises);\n      return manifest;\n    };\n    const deps = await this.dependencyResolver.getDependencies(component);\n    const manifest = await getComponentDepsManifest(deps);\n\n    // unfortunately, component.packageJsonFile is not available here.\n    // the reason is that `writeComponentsToCapsules` clones the component before writing them\n    // also, don't use `PackageJsonFile.createFromComponent`, as it looses the intermediate changes\n    // such as postInstall scripts for custom-module-resolution.\n    const packageJson = PackageJsonFile.loadFromCapsuleSync(capsule.path);\n\n    const addDependencies = (packageJsonFile: PackageJsonFile) => {\n      packageJsonFile.addDependencies(manifest.dependencies);\n      packageJsonFile.addDevDependencies(manifest.devDependencies);\n    };\n    addDependencies(packageJson);\n    packageJson.addOrUpdateProperty('version', currentVersion);\n    return packageJson;\n  }\n\n  private async getComponentPackageVersionWithCache(component: Component): Promise<string> {\n    const idStr = component.id.toString();\n    if (this._componentsPackagesVersionCache[idStr]) {\n      return this._componentsPackagesVersionCache[idStr];\n    }\n    const version = await getComponentPackageVersion(component);\n    this._componentsPackagesVersionCache[idStr] = version;\n    return version;\n  }\n}\n\nIsolatorAspect.addRuntime(IsolatorMain);\n"]}