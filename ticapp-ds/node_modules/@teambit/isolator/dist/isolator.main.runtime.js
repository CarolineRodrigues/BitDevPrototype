"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsolatorMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _componentPackageVersion() {
  const data = require("@teambit/component-package-version");

  _componentPackageVersion = function () {
    return data;
  };

  return data;
}

function _graph() {
  const data = require("@teambit/graph");

  _graph = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _logger2() {
  const data = require("@teambit/logger");

  _logger2 = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _globalConfig() {
  const data = _interopRequireDefault(require("@teambit/global-config"));

  _globalConfig = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");

  _artifactFiles = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _objectHash() {
  const data = _interopRequireDefault(require("object-hash"));

  _objectHash = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _equals() {
  const data = _interopRequireDefault(require("ramda/src/equals"));

  _equals = function () {
    return data;
  };

  return data;
}

function _bitMap() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/bit-map"));

  _bitMap = function () {
    return data;
  };

  return data;
}

function _componentWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/component-writer"));

  _componentWriter = function () {
    return data;
  };

  return data;
}

function _capsule() {
  const data = require("./capsule");

  _capsule = function () {
    return data;
  };

  return data;
}

function _capsuleList() {
  const data = _interopRequireDefault(require("./capsule-list"));

  _capsuleList = function () {
    return data;
  };

  return data;
}

function _isolator() {
  const data = require("./isolator.aspect");

  _isolator = function () {
    return data;
  };

  return data;
}

function _symlinkBitLegacyToCapsules() {
  const data = require("./symlink-bit-legacy-to-capsules");

  _symlinkBitLegacyToCapsules = function () {
    return data;
  };

  return data;
}

function _symlinkDependenciesToCapsules() {
  const data = require("./symlink-dependencies-to-capsules");

  _symlinkDependenciesToCapsules = function () {
    return data;
  };

  return data;
}

function _network() {
  const data = require("./network");

  _network = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const DEFAULT_CAPSULES_BASE_DIR = _path().default.join(_constants().CACHE_ROOT, 'capsules'); // TODO: move elsewhere


const DEFAULT_ISOLATE_INSTALL_OPTIONS = {
  installPackages: true,
  dedupe: true,
  installPeersFromEnvs: true,
  copyPeerToRuntimeOnComponents: false,
  copyPeerToRuntimeOnRoot: true
};

class IsolatorMain {
  // cache packages versions of components
  static async provider([dependencyResolver, loggerExtension, componentAspect, graphAspect, globalConfig]) {
    const logger = loggerExtension.createLogger(_isolator().IsolatorAspect.id);
    const isolator = new IsolatorMain(dependencyResolver, logger, componentAspect, graphAspect, globalConfig);
    return isolator;
  }

  constructor(dependencyResolver, logger, componentAspect, graphBuilder, globalConfig) {
    this.dependencyResolver = dependencyResolver;
    this.logger = logger;
    this.componentAspect = componentAspect;
    this.graphBuilder = graphBuilder;
    this.globalConfig = globalConfig;
    (0, _defineProperty2().default)(this, "_componentsPackagesVersionCache", {});
  } // TODO: the legacy scope used for the component writer, which then decide if it need to write the artifacts and dists
  // TODO: we should think of another way to provide it (maybe a new opts) then take the scope internally from the host


  async isolateComponents(seeders, opts = {}, legacyScope) {
    var _opts$host;

    const host = this.componentAspect.getHost();

    _logger().default.debug(`isolatorExt, createNetwork ${seeders.join(', ')}. opts: ${JSON.stringify(Object.assign({}, opts, {
      host: (_opts$host = opts.host) === null || _opts$host === void 0 ? void 0 : _opts$host.name
    }))}`);

    const createGraphOpts = (0, _lodash().pick)(opts, ['includeFromNestedHosts', 'host']);
    const componentsToIsolate = opts.seedersOnly ? await host.getMany(seeders) : await this.createGraph(seeders, createGraphOpts);
    opts.baseDir = opts.baseDir || host.path;
    const capsuleList = await this.createCapsules(componentsToIsolate, opts, legacyScope);
    return new (_network().Network)(capsuleList, seeders, this.getCapsulesRootDir(opts.baseDir, opts.rootBaseDir));
  }

  async createGraph(seeders, opts = {}) {
    const host = this.componentAspect.getHost();
    const getGraphOpts = (0, _lodash().pick)(opts, ['host']);
    const graph = await this.graphBuilder.getGraph(seeders, getGraphOpts);
    const successorsSubgraph = graph.successorsSubgraph(seeders.map(id => id.toString()));
    const compsAndDeps = successorsSubgraph.nodes.map(node => node.attr); // do not ignore the version here. a component might be in .bitmap with one version and
    // installed as a package with another version. we don't want them both.

    const existingCompsP = compsAndDeps.map(async c => {
      let existing;

      if (opts.includeFromNestedHosts) {
        existing = await host.hasIdNested(c.id, true);
      } else {
        existing = await host.hasId(c.id);
      }

      if (existing) return c;
      return undefined;
    });
    const existingComps = await Promise.all(existingCompsP);
    return (0, _lodash().compact)(existingComps);
  }
  /**
   * Create capsules for the provided components
   * do not use this outside directly, use isolate components which build the entire network
   * @param components
   * @param opts
   * @param legacyScope
   */


  async createCapsules(components, opts, legacyScope) {
    const config = _objectSpread({
      installPackages: true
    }, opts);

    const capsulesDir = this.getCapsulesRootDir(opts.baseDir, opts.rootBaseDir);

    if (opts.emptyRootDir) {
      await _fsExtra().default.emptyDir(capsulesDir);
    }

    const capsules = await this.createCapsulesFromComponents(components, capsulesDir, config);

    const capsuleList = _capsuleList().default.fromArray(capsules);

    if (opts.getExistingAsIs) {
      return capsuleList;
    }

    if (opts.skipIfExists) {
      const existingCapsules = _capsuleList().default.fromArray(capsuleList.filter(capsule => capsule.fs.existsSync('package.json')));

      if (existingCapsules.length === capsuleList.length) return existingCapsules;
    }

    const capsulesWithPackagesData = await this.getCapsulesPreviousPackageJson(capsules);
    await this.writeComponentsInCapsules(components, capsuleList, legacyScope);
    await this.updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsuleList);
    const installOptions = Object.assign({}, DEFAULT_ISOLATE_INSTALL_OPTIONS, opts.installOptions || {});

    if (installOptions.installPackages) {
      var _opts$cachePackagesOn, _opts$linkingOptions;

      await this.installInCapsules(capsulesDir, capsuleList, installOptions, (_opts$cachePackagesOn = opts.cachePackagesOnCapsulesRoot) !== null && _opts$cachePackagesOn !== void 0 ? _opts$cachePackagesOn : false);
      await this.linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, (_opts$linkingOptions = opts.linkingOptions) !== null && _opts$linkingOptions !== void 0 ? _opts$linkingOptions : {});
    } // rewrite the package-json with the component dependencies in it. the original package.json
    // that was written before, didn't have these dependencies in order for the package-manager to
    // be able to install them without crushing when the versions don't exist yet


    capsulesWithPackagesData.forEach(capsuleWithPackageData => {
      const {
        currentPackageJson,
        capsule
      } = capsuleWithPackageData;
      if (!currentPackageJson) throw new Error(`isolator.createCapsules, unable to find currentPackageJson for ${capsule.component.id.toString()}`);
      capsuleWithPackageData.capsule.fs.writeFileSync(_constants().PACKAGE_JSON, JSON.stringify(currentPackageJson, null, 2));
    });
    return capsuleList;
  }

  async installInCapsules(capsulesDir, capsuleList, isolateInstallOptions, cachePackagesOnCapsulesRoot) {
    const installer = this.dependencyResolver.getInstaller({
      rootDir: capsulesDir,
      cacheRootDirectory: cachePackagesOnCapsulesRoot ? capsulesDir : undefined
    }); // When using isolator we don't want to use the policy defined in the workspace directly,
    // we only want to instal deps from components and the peer from the workspace

    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();
    const installOptions = {
      installTeambitBit: !!isolateInstallOptions.installTeambitBit,
      packageManagerConfigRootDir: isolateInstallOptions.packageManagerConfigRootDir
    };
    const packageManagerInstallOptions = {
      dedupe: isolateInstallOptions.dedupe,
      copyPeerToRuntimeOnComponents: isolateInstallOptions.copyPeerToRuntimeOnComponents,
      copyPeerToRuntimeOnRoot: isolateInstallOptions.copyPeerToRuntimeOnRoot,
      installPeersFromEnvs: isolateInstallOptions.installPeersFromEnvs,
      overrides: this.dependencyResolver.config.capsulesOverrides || this.dependencyResolver.config.overrides
    };
    await installer.install(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), installOptions, packageManagerInstallOptions);
  }

  async linkInCapsules(capsulesDir, capsuleList, capsulesWithPackagesData, linkingOptions) {
    const linker = this.dependencyResolver.getLinker({
      rootDir: capsulesDir,
      linkingOptions
    });
    const peerOnlyPolicy = this.getWorkspacePeersOnlyPolicy();
    const capsulesWithModifiedPackageJson = this.getCapsulesWithModifiedPackageJson(capsulesWithPackagesData);
    await linker.link(capsulesDir, peerOnlyPolicy, this.toComponentMap(capsuleList), _objectSpread(_objectSpread({}, linkingOptions), {}, {
      legacyLink: false
    }));
    await (0, _symlinkDependenciesToCapsules().symlinkOnCapsuleRoot)(capsuleList, this.logger, capsulesDir);
    await (0, _symlinkDependenciesToCapsules().symlinkDependenciesToCapsules)(capsulesWithModifiedPackageJson, capsuleList, this.logger); // TODO: this is a hack to have access to the bit bin project in order to access core extensions from user extension
    // TODO: remove this after exporting core extensions as components

    await (0, _symlinkBitLegacyToCapsules().symlinkBitLegacyToCapsules)(capsulesWithModifiedPackageJson, this.logger); // await copyBitLegacyToCapsuleRoot(capsulesDir, this.logger);
  }

  getCapsulesWithModifiedPackageJson(capsulesWithPackagesData) {
    const capsulesWithModifiedPackageJson = capsulesWithPackagesData.filter(capsuleWithPackageData => {
      const packageJsonHasChanged = this.wereDependenciesInPackageJsonChanged(capsuleWithPackageData); // @todo: when a component is tagged, it changes all package-json of its dependents, but it
      // should not trigger any "npm install" because they dependencies are symlinked by us

      return packageJsonHasChanged;
    }).map(capsuleWithPackageData => capsuleWithPackageData.capsule);
    return capsulesWithModifiedPackageJson;
  }

  async writeComponentsInCapsules(components, capsuleList, legacyScope) {
    const legacyComponents = components.map(component => component.state._consumer.clone());
    if (legacyScope) await (0, _artifactFiles().importMultipleDistsArtifacts)(legacyScope, legacyComponents);

    const allIds = _bitId().BitIds.fromArray(legacyComponents.map(c => c.id));

    await Promise.all(components.map(async component => {
      const capsule = capsuleList.getCapsule(component.id);
      if (!capsule) return;
      const params = this.getComponentWriteParams(component.state._consumer, allIds, legacyScope);
      const componentWriter = new (_componentWriter().default)(params);
      await componentWriter.populateComponentsFilesToWrite();
      await component.state._consumer.dataToPersist.persistAllToCapsule(capsule, {
        keepExistingCapsule: true
      });
    }));
  }

  getWorkspacePeersOnlyPolicy() {
    const workspacePolicy = this.dependencyResolver.getWorkspacePolicy();
    const peerOnlyPolicy = workspacePolicy.byLifecycleType('peer');
    return peerOnlyPolicy;
  }

  getComponentWriteParams(component, ids, legacyScope) {
    return {
      component,
      // @ts-ignore
      bitMap: new (_bitMap().default)(undefined, undefined, undefined, false),
      writeToPath: '.',
      origin: 'IMPORTED',
      consumer: undefined,
      scope: legacyScope,
      override: false,
      writePackageJson: true,
      writeConfig: false,
      ignoreBitDependencies: ids,
      excludeRegistryPrefix: false,
      isolated: true
    };
  }

  toComponentMap(capsuleList) {
    const tuples = capsuleList.map(capsule => {
      return [capsule.component, capsule.path];
    });
    return _component().ComponentMap.create(tuples);
  }

  async list(workspacePath) {
    try {
      const workspaceCapsuleFolder = this.getCapsulesRootDir(workspacePath);
      const capsules = await _fsExtra().default.readdir(workspaceCapsuleFolder);
      const capsuleFullPaths = capsules.map(c => _path().default.join(workspaceCapsuleFolder, c));
      return {
        workspace: workspacePath,
        capsules: capsuleFullPaths
      };
    } catch (e) {
      if (e.code === 'ENOENT') {
        return {
          workspace: workspacePath,
          capsules: []
        };
      }

      throw e;
    }
  }

  getCapsulesRootDir(baseDir, rootBaseDir) {
    const capsulesRootBaseDir = rootBaseDir || this.getRootDirOfAllCapsules();
    return _path().default.join(capsulesRootBaseDir, (0, _objectHash().default)(baseDir));
  }

  async deleteCapsules(capsuleBaseDir) {
    const dirToDelete = capsuleBaseDir ? this.getCapsulesRootDir(capsuleBaseDir) : this.getRootDirOfAllCapsules();
    await _fsExtra().default.remove(dirToDelete);
    return dirToDelete;
  }

  async createCapsulesFromComponents(components, baseDir, opts) {
    const capsules = await Promise.all(components.map(component => {
      return _capsule().Capsule.createFromComponent(component, baseDir, opts);
    }));
    return capsules;
  }

  getRootDirOfAllCapsules() {
    return this.globalConfig.getSync(_constants().CFG_CAPSULES_ROOT_BASE_DIR) || DEFAULT_CAPSULES_BASE_DIR;
  }

  wereDependenciesInPackageJsonChanged(capsuleWithPackageData) {
    const {
      previousPackageJson,
      currentPackageJson
    } = capsuleWithPackageData;
    if (!previousPackageJson) return true; // @ts-ignore at this point, currentPackageJson is set

    return _constants().DEPENDENCIES_FIELDS.some(field => !(0, _equals().default)(previousPackageJson[field], currentPackageJson[field]));
  }

  async getCapsulesPreviousPackageJson(capsules) {
    return Promise.all(capsules.map(async capsule => {
      const packageJsonPath = _path().default.join(capsule.path, 'package.json');

      let previousPackageJson = null;

      try {
        const previousPackageJsonRaw = await capsule.fs.promises.readFile(packageJsonPath, {
          encoding: 'utf8'
        });
        previousPackageJson = JSON.parse(previousPackageJsonRaw);
      } catch (e) {// package-json doesn't exist in the capsule, that's fine, it'll be considered as a cache miss
      }

      return {
        capsule,
        previousPackageJson
      };
    }));
  }

  async updateWithCurrentPackageJsonData(capsulesWithPackagesData, capsules) {
    const updateP = capsules.map(async capsule => {
      const packageJson = await this.getCurrentPackageJson(capsule, capsules);
      const found = capsulesWithPackagesData.filter(c => c.capsule.component.id.isEqual(capsule.component.id));
      if (!found.length) throw new Error(`updateWithCurrentPackageJsonData unable to find ${capsule.component.id}`);
      if (found.length > 1) throw new Error(`updateWithCurrentPackageJsonData found duplicate capsules: ${capsule.component.id.toString()}""`);
      found[0].currentPackageJson = packageJson.packageJsonObject;
    });
    return Promise.all(updateP);
  }

  async getCurrentPackageJson(capsule, capsules) {
    const component = capsule.component;
    const currentVersion = await this.getComponentPackageVersionWithCache(component); // const newVersion = '0.0.1-new';

    const getComponentDepsManifest = async dependencies => {
      const manifest = {
        dependencies: {},
        devDependencies: {}
      };
      const compDeps = dependencies.toTypeArray('component');
      const promises = compDeps.map(async dep => {
        const depCapsule = capsules.getCapsule(dep.componentId);
        let version = dep.version;

        if (depCapsule) {
          version = await this.getComponentPackageVersionWithCache(depCapsule === null || depCapsule === void 0 ? void 0 : depCapsule.component);
        }

        const keyName = _dependencyResolver().KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];

        const entry = dep.toManifest();

        if (entry) {
          manifest[keyName][entry.packageName] = version;
        }
      });
      await Promise.all(promises);
      return manifest;
    };

    const deps = await this.dependencyResolver.getDependencies(component);
    const manifest = await getComponentDepsManifest(deps); // unfortunately, component.packageJsonFile is not available here.
    // the reason is that `writeComponentsToCapsules` clones the component before writing them
    // also, don't use `PackageJsonFile.createFromComponent`, as it looses the intermediate changes
    // such as postInstall scripts for custom-module-resolution.

    const packageJson = _packageJsonFile().default.loadFromCapsuleSync(capsule.path);

    const addDependencies = packageJsonFile => {
      packageJsonFile.addDependencies(manifest.dependencies);
      packageJsonFile.addDevDependencies(manifest.devDependencies);
    };

    addDependencies(packageJson);
    packageJson.addOrUpdateProperty('version', currentVersion);
    return packageJson;
  }

  async getComponentPackageVersionWithCache(component) {
    const idStr = component.id.toString();

    if (this._componentsPackagesVersionCache[idStr]) {
      return this._componentsPackagesVersionCache[idStr];
    }

    const version = await (0, _componentPackageVersion().getComponentPackageVersion)(component);
    this._componentsPackagesVersionCache[idStr] = version;
    return version;
  }

}

exports.IsolatorMain = IsolatorMain;
(0, _defineProperty2().default)(IsolatorMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(IsolatorMain, "dependencies", [_dependencyResolver().DependencyResolverAspect, _logger2().LoggerAspect, _component().ComponentAspect, _graph().GraphAspect, _globalConfig().default]);
(0, _defineProperty2().default)(IsolatorMain, "defaultConfig", {});

_isolator().IsolatorAspect.addRuntime(IsolatorMain);

//# sourceMappingURL=isolator.main.runtime.js.map