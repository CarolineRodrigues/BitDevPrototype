"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactApp = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _toolboxNetwork() {
  const data = require("@teambit/toolbox.network.get-port");

  _toolboxNetwork = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _terserWebpackPlugin() {
  const data = _interopRequireDefault(require("terser-webpack-plugin"));

  _terserWebpackPlugin = function () {
    return data;
  };

  return data;
}

function _plugins() {
  const data = require("./plugins");

  _plugins = function () {
    return data;
  };

  return data;
}

function _webpack() {
  const data = require("../../webpack");

  _webpack = function () {
    return data;
  };

  return data;
}

class ReactApp {
  constructor(name, entry, portRange, reactEnv, prerenderRoutes, bundler, devServer, transformers, deploy, favicon) {
    this.name = name;
    this.entry = entry;
    this.portRange = portRange;
    this.reactEnv = reactEnv;
    this.prerenderRoutes = prerenderRoutes;
    this.bundler = bundler;
    this.devServer = devServer;
    this.transformers = transformers;
    this.deploy = deploy;
    this.favicon = favicon;
    (0, _defineProperty2().default)(this, "applicationType", 'react-common-js');
    (0, _defineProperty2().default)(this, "dir", 'public');
  }

  async run(context) {
    const [from, to] = this.portRange;
    const port = await _toolboxNetwork().Port.getPort(from, to);

    if (this.devServer) {
      await this.devServer.listen(port);
      return port;
    }

    const devServerContext = this.getDevServerContext(context);
    const devServer = this.reactEnv.getDevServer(devServerContext, [configMutator => {
      configMutator.addTopLevel('devServer', {
        historyApiFallback: {
          index: '/index.html',
          disableDotRule: true
        }
      });
      if (!configMutator.raw.output) configMutator.raw.output = {};
      configMutator.raw.output.publicPath = '/';
      return configMutator;
    }]);
    await devServer.listen(port);
    return port;
  }

  async build(context) {
    const htmlConfig = [{
      title: context.name,
      templateContent: (0, _webpack().html)(context.name),
      minify: false,
      favicon: this.favicon // filename: ''.html`,

    }];
    Object.assign(context, {
      html: htmlConfig
    });
    const bundler = await this.getBundler(context);
    await bundler.run();
    return {
      publicDir: `${this.getPublicDir()}/${this.dir}`
    };
  }

  getBundler(context) {
    if (this.bundler) return this.bundler;
    return this.getDefaultBundler(context);
  }

  async getDefaultBundler(context) {
    var _this$transformers;

    const {
      capsule
    } = context;
    const reactEnv = context.env;
    const publicDir = this.getPublicDir();
    const outputPath = (0, _path().join)(capsule.path, publicDir);
    const {
      distDir
    } = reactEnv.getCompiler();
    const entries = this.entry.map(entry => require.resolve(`${capsule.path}/${distDir}/${(0, _path().basename)(entry)}`));
    const staticDir = (0, _path().join)(outputPath, this.dir);
    const bundlerContext = Object.assign(context, {
      targets: [{
        components: [capsule === null || capsule === void 0 ? void 0 : capsule.component],
        entries,
        outputPath
      }],
      entry: [],
      rootPath: '/',
      metaData: {
        initiator: `building app: ${context.name}`,
        envId: context.id
      }
    });

    const defaultTransformer = configMutator => {
      var _config$raw$optimizat;

      const config = configMutator.addTopLevel('output', {
        path: staticDir,
        publicPath: `/`
      });
      if (this.prerenderRoutes) config.addPlugin((0, _plugins().prerenderSPAPlugin)(this.prerenderRoutes, staticDir));

      if ((_config$raw$optimizat = config.raw.optimization) !== null && _config$raw$optimizat !== void 0 && _config$raw$optimizat.minimizer) {
        var _config$raw$optimizat2, _config$raw$optimizat3;

        (0, _lodash().remove)((_config$raw$optimizat2 = config.raw.optimization) === null || _config$raw$optimizat2 === void 0 ? void 0 : _config$raw$optimizat2.minimizer, minimizer => {
          return minimizer.constructor.name === 'TerserPlugin';
        });
        (_config$raw$optimizat3 = config.raw.optimization) === null || _config$raw$optimizat3 === void 0 ? void 0 : _config$raw$optimizat3.minimizer.push(new (_terserWebpackPlugin().default)({
          minify: _terserWebpackPlugin().default.esbuildMinify,
          // `terserOptions` options will be passed to `esbuild`
          // Link to options - https://esbuild.github.io/api/#minify
          terserOptions: {
            minify: true
          }
        }));
      }

      return config;
    };

    const transformers = [defaultTransformer, ...((_this$transformers = this.transformers) !== null && _this$transformers !== void 0 ? _this$transformers : [])];
    const bundler = await reactEnv.getBundler(bundlerContext, transformers);
    return bundler;
  }

  getPublicDir() {
    return (0, _path().join)(this.applicationType, this.name);
  }

  getDevServerContext(context) {
    return Object.assign(context, {
      entry: this.entry,
      rootPath: '',
      publicPath: `public/${this.name}`,
      title: this.name,
      favicon: this.favicon
    });
  }

}

exports.ReactApp = ReactApp;

//# sourceMappingURL=react.application.js.map