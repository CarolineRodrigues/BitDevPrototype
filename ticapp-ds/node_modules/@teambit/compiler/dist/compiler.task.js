"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerTask = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

/**
 * compiler build task. Allows to compile components during component build.
 */
class CompilerTask {
  constructor(aspectId, name, compilerInstance) {
    this.aspectId = aspectId;
    this.name = name;
    this.compilerInstance = compilerInstance;
    (0, _defineProperty2().default)(this, "description", 'compile components');

    if (compilerInstance.artifactName) {
      this.description += ` for artifact ${compilerInstance.artifactName}`;
    }
  }

  async preBuild(context) {
    await Promise.all(context.capsuleNetwork.seedersCapsules.map(capsule => this.copyNonSupportedFiles(capsule, this.compilerInstance)));
    if (!this.compilerInstance.preBuild) return;
    await this.compilerInstance.preBuild(context);
  }

  async execute(context) {
    const buildResults = await this.compilerInstance.build(context);
    return buildResults;
  }

  async postBuild(context, tasksResults) {
    if (!this.compilerInstance.postBuild) return;
    await this.compilerInstance.postBuild(context, tasksResults);
  }

  async copyNonSupportedFiles(capsule, compiler) {
    if (!compiler.shouldCopyNonSupportedFiles) {
      return;
    }

    const component = capsule.component;
    await Promise.all(component.filesystem.files.map(async file => {
      if (compiler.isFileSupported(file.path)) return;
      const content = file.contents;
      await _fsExtra().default.outputFile(_path().default.join(capsule.path, compiler.distDir, file.relative), content);
    }));
  }

}

exports.CompilerTask = CompilerTask;

//# sourceMappingURL=compiler.task.js.map