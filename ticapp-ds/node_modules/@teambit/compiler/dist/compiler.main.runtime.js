"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompilerMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _aspectLoader() {
  const data = _interopRequireDefault(require("@teambit/aspect-loader"));

  _aspectLoader = function () {
    return data;
  };

  return data;
}

function _builder() {
  const data = require("@teambit/builder");

  _builder = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _generator() {
  const data = require("@teambit/generator");

  _generator = function () {
    return data;
  };

  return data;
}

function _pubsub() {
  const data = require("@teambit/pubsub");

  _pubsub = function () {
    return data;
  };

  return data;
}

function _ui() {
  const data = _interopRequireDefault(require("@teambit/ui"));

  _ui = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = require("@teambit/workspace");

  _workspace = function () {
    return data;
  };

  return data;
}

function _compiler() {
  const data = require("./compiler.aspect");

  _compiler = function () {
    return data;
  };

  return data;
}

function _compiler2() {
  const data = require("./compiler.cmd");

  _compiler2 = function () {
    return data;
  };

  return data;
}

function _compiler3() {
  const data = require("./compiler.service");

  _compiler3 = function () {
    return data;
  };

  return data;
}

function _compiler4() {
  const data = require("./compiler.task");

  _compiler4 = function () {
    return data;
  };

  return data;
}

function _distArtifact() {
  const data = require("./dist-artifact");

  _distArtifact = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _types() {
  const data = require("./types");

  _types = function () {
    return data;
  };

  return data;
}

function _workspaceCompiler() {
  const data = require("./workspace-compiler");

  _workspaceCompiler = function () {
    return data;
  };

  return data;
}

function _compiler5() {
  const data = require("./templates/compiler");

  _compiler5 = function () {
    return data;
  };

  return data;
}

class CompilerMain {
  constructor(pubsub, workspaceCompiler, envs, builder) {
    this.pubsub = pubsub;
    this.workspaceCompiler = workspaceCompiler;
    this.envs = envs;
    this.builder = builder;
  }
  /**
   * Run compilation on `bit new` and when new components are imported
   */


  compileOnWorkspace(componentsIds = [], // when empty, it compiles all
  options = {
    initiator: _types().CompilationInitiator.ComponentAdded
  }) {
    return this.workspaceCompiler.compileComponents(componentsIds, options);
  }
  /**
   * API to create a new compiler task, it facilitates the usage of multiple compilers.
   * with this method you can create any number of compilers and add them to the buildPipeline.
   */


  createTask(name, compiler) {
    return new (_compiler4().CompilerTask)(_compiler().CompilerAspect.id, name, compiler);
  }
  /**
   * find the compiler configured on the workspace and ask for the dist path.
   */


  getDistPathBySrcPath(component, srcPath) {
    var _environment$getCompi;

    const environment = this.envs.getEnv(component).env;
    const compilerInstance = (_environment$getCompi = environment.getCompiler) === null || _environment$getCompi === void 0 ? void 0 : _environment$getCompi.call(environment);
    if (!compilerInstance) return null;
    return compilerInstance.getDistPathBySrcPath(srcPath);
  }

  async getDistsFiles(component) {
    const artifacts = await this.builder.getArtifactsVinylByExtension(component, _compiler().CompilerAspect.id);
    if (!artifacts.length) throw new (_exceptions().DistArtifactNotFound)(component.id);
    return new (_distArtifact().DistArtifact)(artifacts);
  }

  static async provider([cli, workspace, envs, loggerMain, pubsub, aspectLoader, builder, ui, generator]) {
    const logger = loggerMain.createLogger(_compiler().CompilerAspect.id);
    const workspaceCompiler = new (_workspaceCompiler().WorkspaceCompiler)(workspace, envs, pubsub, aspectLoader, ui, logger);
    envs.registerService(new (_compiler3().CompilerService)());
    const compilerMain = new CompilerMain(pubsub, workspaceCompiler, envs, builder);
    cli.register(new (_compiler2().CompileCmd)(workspaceCompiler, logger, pubsub));
    generator.registerComponentTemplate([_compiler5().compilerTemplate]);
    _manyComponentsWriter().default.externalCompiler = compilerMain.compileOnWorkspace.bind(compilerMain);
    return compilerMain;
  }

}

exports.CompilerMain = CompilerMain;
(0, _defineProperty2().default)(CompilerMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(CompilerMain, "dependencies", [_cli().CLIAspect, _workspace().WorkspaceAspect, _envs().EnvsAspect, _logger().LoggerAspect, _pubsub().PubsubAspect, _aspectLoader().default, _builder().BuilderAspect, _ui().default, _generator().GeneratorAspect]);

_compiler().CompilerAspect.addRuntime(CompilerMain);

//# sourceMappingURL=compiler.main.runtime.js.map