import type { AspectLoaderMain } from '@teambit/aspect-loader';
import { TaskResultsList, BuilderData } from '@teambit/builder';
import { AspectDefinition } from '@teambit/aspect-loader';
import { CLIMain } from '@teambit/cli';
import type { ComponentMain, ComponentMap } from '@teambit/component';
import { Component, ComponentFactory, ComponentID, Snap, State } from '@teambit/component';
import type { GraphqlMain } from '@teambit/graphql';
import { Harmony, SlotRegistry, ExtensionManifest, Aspect } from '@teambit/harmony';
import { IsolatorMain } from '@teambit/isolator';
import { LoggerMain, Logger } from '@teambit/logger';
import { ExpressMain } from '@teambit/express';
import type { UiMain } from '@teambit/ui';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import { BitId } from '@teambit/legacy-bit-id';
import { BitIds as ComponentsIds } from '@teambit/legacy/dist/bit-id';
import { ModelComponent, Lane } from '@teambit/legacy/dist/scope/models';
import LegacyScope, { LegacyOnTagResult, OnTagOpts } from '@teambit/legacy/dist/scope/scope';
import { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';
import { PersistOptions } from '@teambit/legacy/dist/scope/types';
import LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';
import { Remotes } from '@teambit/legacy/dist/remotes';
import { ConfigMain } from '@teambit/config';
import { Types } from '@teambit/legacy/dist/scope/object-registrar';
import { FETCH_OPTIONS } from '@teambit/legacy/dist/api/scope/lib/fetch';
import { ObjectList } from '@teambit/legacy/dist/scope/objects/object-list';
import { AuthData } from '@teambit/legacy/dist/scope/network/http/http';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import { EnvsMain } from '@teambit/envs';
import { ScopeComponentLoader } from './scope-component-loader';
declare type TagRegistry = SlotRegistry<OnTag>;
declare type ManifestOrAspect = ExtensionManifest | Aspect;
export declare type OnTagResults = {
    builderDataMap: ComponentMap<BuilderData>;
    pipeResults: TaskResultsList[];
};
export declare type OnTag = (components: Component[], options?: OnTagOpts) => Promise<OnTagResults>;
declare type RemoteEventMetadata = {
    auth?: AuthData;
    headers?: {};
};
declare type RemoteEvent<Data> = (data: Data, metadata: RemoteEventMetadata, errors?: Array<string | Error>) => Promise<void>;
declare type OnPostPutData = {
    ids: ComponentID[];
    lanes: Lane[];
};
declare type OnPostDeleteData = {
    ids: ComponentID[];
};
declare type OnPreFetchObjectData = {
    ids: string[];
    fetchOptions: FETCH_OPTIONS;
};
declare type OnPostPut = RemoteEvent<OnPostPutData>;
declare type OnPostExport = RemoteEvent<OnPostPutData>;
declare type OnPostDelete = RemoteEvent<OnPostDeleteData>;
declare type OnPostObjectsPersist = RemoteEvent<undefined>;
declare type OnPreFetchObjects = RemoteEvent<OnPreFetchObjectData>;
export declare type OnPostPutSlot = SlotRegistry<OnPostPut>;
export declare type OnPostDeleteSlot = SlotRegistry<OnPostDelete>;
export declare type OnPostExportSlot = SlotRegistry<OnPostExport>;
export declare type OnPostObjectsPersistSlot = SlotRegistry<OnPostObjectsPersist>;
export declare type OnPreFetchObjectsSlot = SlotRegistry<OnPreFetchObjects>;
export declare type ScopeConfig = {
    httpTimeOut: number;
    description?: string;
    icon?: string;
    backgroundIconColor?: string;
};
export declare class ScopeMain implements ComponentFactory {
    /**
     * private reference to the instance of Harmony.
     */
    private harmony;
    /**
     * legacy scope
     */
    readonly legacyScope: LegacyScope;
    /**
     * component extension.
     */
    readonly componentExtension: ComponentMain;
    /**
     * slot registry for subscribing to build
     */
    readonly config: ScopeConfig;
    private tagRegistry;
    private postPutSlot;
    private postDeleteSlot;
    private postExportSlot;
    private postObjectsPersist;
    preFetchObjects: OnPreFetchObjectsSlot;
    private isolator;
    private aspectLoader;
    private logger;
    private envs;
    componentLoader: ScopeComponentLoader;
    constructor(
    /**
     * private reference to the instance of Harmony.
     */
    harmony: Harmony, 
    /**
     * legacy scope
     */
    legacyScope: LegacyScope, 
    /**
     * component extension.
     */
    componentExtension: ComponentMain, 
    /**
     * slot registry for subscribing to build
     */
    config: ScopeConfig, tagRegistry: TagRegistry, postPutSlot: OnPostPutSlot, postDeleteSlot: OnPostDeleteSlot, postExportSlot: OnPostExportSlot, postObjectsPersist: OnPostObjectsPersistSlot, preFetchObjects: OnPreFetchObjectsSlot, isolator: IsolatorMain, aspectLoader: AspectLoaderMain, logger: Logger, envs: EnvsMain);
    /**
     * name of the scope
     */
    get name(): string;
    get icon(): string | undefined;
    get backgroundIconColor(): string | undefined;
    get description(): string | undefined;
    get path(): string;
    get isLegacy(): boolean;
    /**
     * register to the tag slot.
     */
    onTag(tagFn: OnTag): void;
    reloadAspectsWithNewVersion(components: ConsumerComponent[]): Promise<void>;
    getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]>;
    clearCache(): void;
    builderDataMapToLegacyOnTagResults(builderDataComponentMap: ComponentMap<BuilderData>): LegacyOnTagResult[];
    /**
     * register to the post-export slot.
     */
    onPostPut(postPutFn: OnPostPut): this;
    /**
     * register to the post-delete slot.
     */
    onPostDelete(postDeleteFn: OnPostDelete): this;
    /**
     * register to the post-export slot.
     */
    registerOnPostExport(postExportFn: OnPostExport): this;
    registerOnPreFetchObjects(preFetchObjectsFn: OnPreFetchObjects): this;
    registerOnPostObjectsPersist(postObjectsPersistFn: OnPostObjectsPersist): this;
    /**
     * Will fetch a list of components into the current scope.
     * This will only fetch the object and won't write the files to the actual FS
     *
     * @param {ComponentsIds} ids list of ids to fetch
     */
    fetch(ids: ComponentsIds): void;
    /**
     * This function will get a component and sealed it's current state into the scope
     *
     * @param {Component[]} components A list of components to seal with specific persist options (such as message and version number)
     * @param {PersistOptions} persistGeneralOptions General persistence options such as verbose
     */
    persist(components: Component[], options: PersistOptions): void;
    delete({ ids, force, lanes }: {
        ids: string[];
        force: boolean;
        lanes: boolean;
    }, headers?: Record<string, any>): Promise<import("@teambit/legacy/dist/scope/removed-components").RemovedObjectSerialized>;
    toObjectList(types: Types): Promise<ObjectList>;
    private toJs;
    private parseLocalAspect;
    private findRuntime;
    private loadAspectFromPath;
    private localAspects;
    loadAspects(ids: string[], throwOnError?: boolean, neededFor?: ComponentID): Promise<string[]>;
    /**
     * This function get's a list of aspect ids and return them grouped by whether any of them is the env of other from the list
     * @param ids
     */
    groupAspectIdsByEnvOfTheList(ids: string[]): Promise<{
        envs: string[];
        other: string[];
    }>;
    private getManifestsAndLoadAspects;
    getManifestsGraphRecursively(ids: string[], visited?: string[], throwOnError?: boolean, opts?: {
        packageManagerConfigRootDir?: string;
    }): Promise<ManifestOrAspect[]>;
    private getNonLoadedAspects;
    private resolveLocalAspects;
    getResolvedAspects(components: Component[], opts?: {
        skipIfExists?: boolean;
        packageManagerConfigRootDir?: string;
    }): Promise<RequireableComponent[]>;
    private compileIfNoDist;
    private tryCompile;
    requireAspects(components: Component[], throwOnError?: boolean, opts?: {
        packageManagerConfigRootDir?: string;
    }): Promise<Array<ExtensionManifest | Aspect>>;
    getAspectCapsulePath(): string;
    private resolveUserAspects;
    resolveAspects(runtimeName?: string, componentIds?: ComponentID[]): Promise<AspectDefinition[]>;
    getLegacyGraph(ids?: ComponentID[]): Promise<LegacyGraph>;
    /**
     * import components into the scope.
     */
    import(ids: ComponentID[], { useCache, throwIfNotExist, reFetchUnBuiltVersion, }?: {
        /**
         * if the component exists locally, don't go to the server to search for updates.
         */
        useCache?: boolean;
        throwIfNotExist?: boolean;
        /**
         * if the Version objects exists locally, but its `buildStatus` is Pending or Failed, reach the remote to find
         * whether the version was already built there.
         */
        reFetchUnBuiltVersion?: boolean;
    }): Promise<Component[]>;
    get(id: ComponentID): Promise<Component | undefined>;
    getFromConsumerComponent(consumerComponent: ConsumerComponent): Promise<Component>;
    /**
     * get a component from a remote without importing it
     */
    getRemoteComponent(id: ComponentID): Promise<Component>;
    /**
     * list all components in the scope.
     */
    list(filter?: {
        offset: number;
        limit: number;
    }, includeCache?: boolean, includeFromLanes?: boolean): Promise<Component[]>;
    /**
     * for now, list of invalid components are mostly useful for the workspace.
     * in the future, this can return components that failed to load in the scope due to objects file
     * corruption or similar issues.
     */
    listInvalid(): Promise<never[]>;
    /**
     * get ids of all scope components.
     * @param includeCache whether or not include components that their scope-name is different than the current scope-name
     */
    listIds(includeCache?: boolean, includeFromLanes?: boolean): Promise<ComponentID[]>;
    /**
     * Check if a specific id exist in the scope
     * @param componentId
     */
    hasId(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    hasIdNested(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    /**
     * determine whether a component exists in the scope.
     */
    exists(modelComponent: ModelComponent): boolean;
    getMany(ids: ComponentID[], throwIfNotExist?: boolean): Promise<Component[]>;
    /**
     * load components from a scope and load their aspects
     */
    loadMany(ids: ComponentID[]): Promise<Component[]>;
    /**
     * get a component and throw an exception if not found.
     * @param id component id
     */
    getOrThrow(id: ComponentID): Promise<Component>;
    /**
     * returns a specific state of a component.
     * @param id component ID.
     * @param hash state hash.
     */
    getState(id: ComponentID, hash: string): Promise<State>;
    getSnap(id: ComponentID, hash: string): Promise<Snap>;
    getLogs(id: ComponentID, shortHash?: boolean, startsFrom?: string): Promise<ComponentLog[]>;
    /**
     * resolve a component ID.
     * @param id component ID.
     */
    resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID>;
    resolveMultipleComponentIds(ids: Array<string | ComponentID | BitId>): Promise<ComponentID[]>;
    /**
     * load components into the scope through a variants pattern.
     */
    byPattern(patterns: string[], scope?: string): Promise<Component[]>;
    getExactVersionBySemverRange(id: ComponentID, range: string): Promise<string | undefined>;
    resumeExport(exportId: string, remotes: string[]): Promise<string[]>;
    resolveId(id: string): Promise<ComponentID>;
    _legacyRemotes(): Promise<Remotes>;
    /**
     * get a component and load its aspect
     */
    load(id: ComponentID): Promise<Component | undefined>;
    loadComponentsAspect(component: Component): Promise<void>;
    /**
     * declare the slots of scope extension.
     */
    static slots: (((registerFn: () => string) => SlotRegistry<OnTag>) | ((registerFn: () => string) => SlotRegistry<OnPostPut>) | ((registerFn: () => string) => SlotRegistry<OnPostObjectsPersist>) | ((registerFn: () => string) => SlotRegistry<OnPreFetchObjects>))[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: Aspect[];
    static defaultConfig: ScopeConfig;
    static provider([componentExt, ui, graphql, cli, isolator, aspectLoader, express, loggerMain, envs, configMain]: [
        ComponentMain,
        UiMain,
        GraphqlMain,
        CLIMain,
        IsolatorMain,
        AspectLoaderMain,
        ExpressMain,
        LoggerMain,
        EnvsMain,
        ConfigMain
    ], config: ScopeConfig, [tagSlot, postPutSlot, postDeleteSlot, postExportSlot, postObjectsPersistSlot, preFetchObjectsSlot]: [
        TagRegistry,
        OnPostPutSlot,
        OnPostDeleteSlot,
        OnPostExportSlot,
        OnPostObjectsPersistSlot,
        OnPreFetchObjectsSlot
    ], harmony: Harmony): Promise<ScopeMain | undefined>;
}
export {};
