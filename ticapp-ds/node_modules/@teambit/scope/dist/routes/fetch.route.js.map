{"version":3,"sources":["fetch.route.ts"],"names":["FetchRoute","constructor","scope","logger","Verb","READ","req","res","setTimeout","config","httpTimeOut","preFetchHookP","preFetchObjects","values","map","fn","ids","body","fetchOptions","headers","Promise","all","catch","err","error","readable","path","pack","ObjectList","fromObjectStreamToTar","name","pipelinePromise","pipeline","info","aborted","warn"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGO,MAAMA,UAAN,CAAkC;AACvCC,EAAAA,WAAW,CAASC,KAAT,EAAmCC,MAAnC,EAAmD;AAAA,SAA1CD,KAA0C,GAA1CA,KAA0C;AAAA,SAAhBC,MAAgB,GAAhBA,MAAgB;AAAA,mDAEtD,cAFsD;AAAA,oDAGrD,MAHqD;AAAA,kDAIvDC,gBAAKC,IAJkD;AAAA,yDAKhD,CACZ,OAAOC,GAAP,EAAqBC,GAArB,KAAuC;AACrCD,MAAAA,GAAG,CAACE,UAAJ,CAAe,KAAKN,KAAL,CAAWO,MAAX,CAAkBC,WAAjC;AACA,YAAMC,aAAa,GAAG,KAAKT,KAAL,CAAWU,eAAX,CACnBC,MADmB,GAEnBC,GAFmB,CAEdC,EAAD,IAAQA,EAAE,CAAC;AAAEC,QAAAA,GAAG,EAAEV,GAAG,CAACW,IAAJ,CAASD,GAAhB;AAAqBE,QAAAA,YAAY,EAAEZ,GAAG,CAACW,IAAJ,CAASC;AAA5C,OAAD,EAA6D;AAAEC,QAAAA,OAAO,EAAEb,GAAG,CAACa;AAAf,OAA7D,CAFK,CAAtB;AAIAC,MAAAA,OAAO,CAACC,GAAR,CAAYV,aAAZ,EAA2BW,KAA3B,CAAkCC,GAAD,IAAS;AACxC,aAAKpB,MAAL,CAAYqB,KAAZ,CAAkB,sFAAlB,EAA0GD,GAA1G;AACD,OAFD;AAIA,YAAME,QAAQ,GAAG,MAAM,oBAAM,KAAKvB,KAAL,CAAWwB,IAAjB,EAAuBpB,GAAG,CAACW,IAAJ,CAASD,GAAhC,EAAqCV,GAAG,CAACW,IAAJ,CAASC,YAA9C,CAAvB;;AACA,YAAMS,IAAI,GAAGC,yBAAWC,qBAAX,CAAiCJ,QAAjC,EAA2C,KAAKvB,KAAL,CAAW4B,IAAtD,CAAb;;AACA,YAAMC,eAAe,GAAG,uBAAUC,kBAAV,CAAxB;;AACA,UAAI;AACF,cAAMD,eAAe,CAACJ,IAAD,EAAOpB,GAAP,CAArB;AACA,aAAKJ,MAAL,CAAY8B,IAAZ,CAAiB,qEAAjB,EAAwF3B,GAAG,CAACa,OAA5F;AACD,OAHD,CAGE,OAAOI,GAAP,EAAiB;AACjB,YAAIjB,GAAG,CAAC4B,OAAR,EAAiB;AACf,eAAK/B,MAAL,CAAYgC,IAAZ,CAAiB,4CAAjB,EAA+DZ,GAA/D;AACD,SAFD,MAEO;AACL,eAAKpB,MAAL,CAAYqB,KAAZ,CACG;AACb,gGAFU,EAGED,GAHF;AAKD;AACF;AACF,KA5BW,CALgD;AAAE;;AADzB","sourcesContent":["import { Route, Verb, Request, Response } from '@teambit/express';\nimport { fetch } from '@teambit/legacy/dist/api/scope';\nimport { ObjectList } from '@teambit/legacy/dist/scope/objects/object-list';\nimport { Logger } from '@teambit/logger';\nimport { promisify } from 'util';\nimport { pipeline } from 'stream';\nimport { ScopeMain } from '../scope.main.runtime';\n\nexport class FetchRoute implements Route {\n  constructor(private scope: ScopeMain, private logger: Logger) {}\n\n  route = '/scope/fetch';\n  method = 'post';\n  verb = Verb.READ;\n  middlewares = [\n    async (req: Request, res: Response) => {\n      req.setTimeout(this.scope.config.httpTimeOut);\n      const preFetchHookP = this.scope.preFetchObjects\n        .values()\n        .map((fn) => fn({ ids: req.body.ids, fetchOptions: req.body.fetchOptions }, { headers: req.headers }));\n\n      Promise.all(preFetchHookP).catch((err) => {\n        this.logger.error('fatal: onPreFetchObjects encountered an error (this error does not stop the process)', err);\n      });\n\n      const readable = await fetch(this.scope.path, req.body.ids, req.body.fetchOptions);\n      const pack = ObjectList.fromObjectStreamToTar(readable, this.scope.name);\n      const pipelinePromise = promisify(pipeline);\n      try {\n        await pipelinePromise(pack, res);\n        this.logger.info('fetch.router, the response has been sent successfully to the client', req.headers);\n      } catch (err: any) {\n        if (req.aborted) {\n          this.logger.warn('FetchRoute, the client aborted the request', err);\n        } else {\n          this.logger.error(\n            `FetchRoute encountered an error during the pipeline streaming, this should never happen.\n  make sure the error is caught in fromObjectStreamToTar and it streamed using the name \"ERROR\"`,\n            err\n          );\n        }\n      }\n    },\n  ];\n}\n"]}