import { CLIMain } from '@teambit/cli';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import { Workspace } from '@teambit/workspace';
import { Component, ComponentID, ComponentMain } from '@teambit/component';
import { ComponentIdObj } from '@teambit/component-id';
import { GraphqlMain } from '@teambit/graphql';
import { NewComponentHelperMain } from '@teambit/new-component-helper';
import { ForkOptions } from './fork.cmd';
export declare type ForkInfo = {
    forkedFrom: ComponentID;
};
export declare class ForkingMain {
    private workspace;
    private dependencyResolver;
    private newComponentHelper;
    constructor(workspace: Workspace, dependencyResolver: DependencyResolverMain, newComponentHelper: NewComponentHelperMain);
    fork(sourceIdStr: string, targetId?: string, options?: ForkOptions): Promise<ComponentID>;
    getForkInfo(component: Component): ForkInfo | null;
    private forkExistingInWorkspace;
    private forkRemoteComponent;
    private getConfig;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([cli, workspace, dependencyResolver, componentMain, newComponentHelper, graphql]: [
        CLIMain,
        Workspace,
        DependencyResolverMain,
        ComponentMain,
        NewComponentHelperMain,
        GraphqlMain
    ]): Promise<ForkingMain>;
}
export declare type ForkConfig = {
    forkedFrom: ComponentIdObj;
};
