"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForkingMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));

  _workspace = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireWildcard(require("@teambit/component"));

  _component = function () {
    return data;
  };

  return data;
}

function _graphql() {
  const data = _interopRequireDefault(require("@teambit/graphql"));

  _graphql = function () {
    return data;
  };

  return data;
}

function _newComponentHelper() {
  const data = _interopRequireDefault(require("@teambit/new-component-helper"));

  _newComponentHelper = function () {
    return data;
  };

  return data;
}

function _fork() {
  const data = require("./fork.cmd");

  _fork = function () {
    return data;
  };

  return data;
}

function _forking() {
  const data = require("./forking.aspect");

  _forking = function () {
    return data;
  };

  return data;
}

function _forking2() {
  const data = require("./forking.fragment");

  _forking2 = function () {
    return data;
  };

  return data;
}

function _forking3() {
  const data = require("./forking.graphql");

  _forking3 = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

class ForkingMain {
  constructor(workspace, dependencyResolver, newComponentHelper) {
    this.workspace = workspace;
    this.dependencyResolver = dependencyResolver;
    this.newComponentHelper = newComponentHelper;
  }

  async fork(sourceIdStr, targetId, options) {
    const sourceId = await this.workspace.resolveComponentId(sourceIdStr);
    const exists = this.workspace.exists(sourceId);

    if (exists) {
      const existingInWorkspace = await this.workspace.get(sourceId);
      return this.forkExistingInWorkspace(existingInWorkspace, targetId, options);
    }

    const sourceIdWithScope = sourceId._legacy.scope ? sourceId : _component().ComponentID.fromLegacy(_legacyBitId().BitId.parse(sourceIdStr, true));
    return this.forkRemoteComponent(sourceIdWithScope, targetId, options);
  }

  getForkInfo(component) {
    var _component$state$aspe;

    const forkConfig = (_component$state$aspe = component.state.aspects.get(_forking().ForkingAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : _component$state$aspe.config;
    if (!forkConfig) return null;
    return {
      forkedFrom: _component().ComponentID.fromObject(forkConfig.forkedFrom)
    };
  }

  async forkExistingInWorkspace(existing, targetId, options) {
    if (!targetId) {
      throw new Error(`error: unable to create "${existing.id.toStringWithoutVersion()}" component, a component with the same name already exists.
please specify the target-id arg`);
    }

    const targetCompId = this.newComponentHelper.getNewComponentId(targetId, undefined, options === null || options === void 0 ? void 0 : options.scope);
    const config = await this.getConfig(existing);
    await this.newComponentHelper.writeAndAddNewComp(existing, targetCompId, options, config);
    return targetCompId;
  }

  async forkRemoteComponent(sourceId, targetId, options) {
    const targetName = targetId || sourceId.fullName;
    const targetCompId = this.newComponentHelper.getNewComponentId(targetName, undefined, options === null || options === void 0 ? void 0 : options.scope);
    const comp = await this.workspace.scope.getRemoteComponent(sourceId);
    const deps = await this.dependencyResolver.getDependencies(comp); // only bring auto-resolved dependencies, others should be set in the workspace.jsonc template

    const workspacePolicyEntries = deps.filter(dep => dep.source === 'auto').map(dep => {
      var _dep$getPackageName;

      return {
        dependencyId: ((_dep$getPackageName = dep.getPackageName) === null || _dep$getPackageName === void 0 ? void 0 : _dep$getPackageName.call(dep)) || dep.id,
        lifecycleType: dep.lifecycle === 'dev' ? 'runtime' : dep.lifecycle,
        value: {
          version: dep.version
        }
      };
    });
    this.dependencyResolver.addToRootPolicy(workspacePolicyEntries, {
      updateExisting: true
    });
    const config = await this.getConfig(comp);
    await this.newComponentHelper.writeAndAddNewComp(comp, targetCompId, options, config);
    await this.dependencyResolver.persistConfig(this.workspace.path);
    await this.workspace.install(undefined, {
      dedupe: true,
      import: false,
      copyPeerToRuntimeOnRoot: true,
      copyPeerToRuntimeOnComponents: false,
      updateExisting: false
    });
    return targetCompId;
  }

  async getConfig(comp) {
    const fromExisting = await this.newComponentHelper.getConfigFromExistingToNewComponent(comp);
    return _objectSpread(_objectSpread({}, fromExisting), {}, {
      [_forking().ForkingAspect.id]: {
        forkedFrom: comp.id.toObject()
      }
    });
  }

  static async provider([cli, workspace, dependencyResolver, componentMain, newComponentHelper, graphql]) {
    const forkingMain = new ForkingMain(workspace, dependencyResolver, newComponentHelper);
    cli.register(new (_fork().ForkCmd)(forkingMain));
    graphql.register((0, _forking3().forkingSchema)(forkingMain));
    componentMain.registerShowFragments([new (_forking2().ForkingFragment)(forkingMain)]);
    return forkingMain;
  }

}

exports.ForkingMain = ForkingMain;
(0, _defineProperty2().default)(ForkingMain, "slots", []);
(0, _defineProperty2().default)(ForkingMain, "dependencies", [_cli().CLIAspect, _workspace().default, _dependencyResolver().DependencyResolverAspect, _component().default, _newComponentHelper().default, _graphql().default]);
(0, _defineProperty2().default)(ForkingMain, "runtime", _cli().MainRuntime);

_forking().ForkingAspect.addRuntime(ForkingMain);

//# sourceMappingURL=forking.main.runtime.js.map