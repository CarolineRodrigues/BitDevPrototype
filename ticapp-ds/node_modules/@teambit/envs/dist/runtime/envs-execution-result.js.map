{"version":3,"sources":["envs-execution-result.ts"],"names":["EnvsExecutionResult","constructor","results","hasErrors","Boolean","errors","length","map","envResult","getErrorsOfEnv","execError","error","data","push","throwErrorsIfExist","Error","errorsPerEnvs","getEnvErrorsAsString","errorOutput","join","title","env","id","errorsStr","message","stack"],"mappings":";;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAKO,MAAMA,mBAAN,CAA4D;AACjEC,EAAAA,WAAW,CAAUC,OAAV,EAAmC;AAAA,SAAzBA,OAAyB,GAAzBA,OAAyB;AAAE;;AAEhDC,EAAAA,SAAS,GAAG;AACV,WAAOC,OAAO,CAAC,KAAKC,MAAL,CAAYC,MAAb,CAAd;AACD;AAED;AACF;AACA;;;AACY,MAAND,MAAM,GAAY;AACpB,WAAO,uBAAQ,KAAKH,OAAL,CAAaK,GAAb,CAAkBC,SAAD,IAAe,KAAKC,cAAL,CAAoBD,SAApB,CAAhC,CAAR,CAAP;AACD;;AAEDC,EAAAA,cAAc,CAACD,SAAD,EAAmC;AAC/C,UAAME,SAAS,GAAGF,SAAS,CAACG,KAA5B;AACA,UAAMN,MAAM,GAAGG,SAAS,CAACI,IAAV,GAAiBJ,SAAS,CAACI,IAAV,CAAeP,MAAf,IAAyB,EAA1C,GAA+C,EAA9D;AACA,QAAIK,SAAJ,EAAeL,MAAM,CAACQ,IAAP,CAAYH,SAAZ;AACf,WAAOL,MAAP;AACD;AAED;AACF;AACA;AACA;;;AACES,EAAAA,kBAAkB,GAAG;AACnB,QAAI,CAAC,KAAKT,MAAN,IAAgB,CAAC,KAAKA,MAAL,CAAYC,MAAjC,EAAyC;AACzC,QAAI,KAAKD,MAAL,CAAYC,MAAZ,KAAuB,CAAvB,IAA4B,KAAKD,MAAL,CAAY,CAAZ,aAA0BU,KAA1D,EAAiE,MAAM,KAAKV,MAAL,CAAY,CAAZ,CAAN;AACjE,UAAMW,aAAa,GAAG,KAAKd,OAAL,CAAaK,GAAb,CAAkBC,SAAD,IAAe,KAAKS,oBAAL,CAA0BT,SAA1B,CAAhC,CAAtB;AACA,UAAMU,WAAW,GAAGF,aAAa,CAACG,IAAd,CAAmB,MAAnB,CAApB;AACA,UAAM,IAAIJ,KAAJ,CAAUG,WAAV,CAAN;AACD;;AAEDD,EAAAA,oBAAoB,CAACT,SAAD,EAAkC;AACpD,UAAMH,MAAM,GAAG,KAAKI,cAAL,CAAoBD,SAApB,CAAf;AACA,QAAI,CAACH,MAAM,CAACC,MAAZ,EAAoB,OAAO,EAAP;AACpB,UAAMc,KAAK,GAAI,SAAQf,MAAM,CAACC,MAAO,iBAAgBE,SAAS,CAACa,GAAV,CAAcC,EAAG,EAAtE;AACA,UAAMC,SAAS,GAAGlB,MAAM,CAACE,GAAP,CAAYI,KAAD,IAAY,GAAEA,KAAK,CAACa,OAAQ,KAAIb,KAAK,CAACc,KAAM,EAAvD,EAA0DN,IAA1D,CAA+D,IAA/D,CAAlB;AACA,WAAQ,GAAEC,KAAM,KAAIG,SAAU,EAA9B;AACD;;AAvCgE","sourcesContent":["import { flatten } from 'lodash';\n\nimport { ServiceExecutionResult } from '../services';\nimport { EnvResult } from './runtime';\n\nexport class EnvsExecutionResult<T extends ServiceExecutionResult> {\n  constructor(readonly results: EnvResult<T>[]) {}\n\n  hasErrors() {\n    return Boolean(this.errors.length);\n  }\n\n  /**\n   * execution errors.\n   */\n  get errors(): Error[] {\n    return flatten(this.results.map((envResult) => this.getErrorsOfEnv(envResult)));\n  }\n\n  getErrorsOfEnv(envResult: EnvResult<T>): Error[] {\n    const execError = envResult.error;\n    const errors = envResult.data ? envResult.data.errors || [] : [];\n    if (execError) errors.push(execError);\n    return errors;\n  }\n\n  /**\n   * if only one error is found, throw it. otherwise, summarize the errors per env and throw the\n   * output\n   */\n  throwErrorsIfExist() {\n    if (!this.errors || !this.errors.length) return;\n    if (this.errors.length === 1 && this.errors[0] instanceof Error) throw this.errors[0];\n    const errorsPerEnvs = this.results.map((envResult) => this.getEnvErrorsAsString(envResult));\n    const errorOutput = errorsPerEnvs.join('\\n\\n');\n    throw new Error(errorOutput);\n  }\n\n  getEnvErrorsAsString(envResult: EnvResult<T>): string {\n    const errors = this.getErrorsOfEnv(envResult);\n    if (!errors.length) return '';\n    const title = `found ${errors.length} error(s) for ${envResult.env.id}`;\n    const errorsStr = errors.map((error) => `${error.message}\\n${error.stack}`).join('\\n');\n    return `${title}\\n${errorsStr}`;\n  }\n}\n"]}