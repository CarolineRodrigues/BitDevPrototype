{"version":3,"sources":["environment.ts"],"names":["hasCompiler","obj","getCompiler"],"mappings":";;;;;;;AAAA;;AAoBA;AACA;AACA;AA+LO,SAASA,WAAT,CAAqBC,GAArB,EAA2D;AAChE,SAAO,OAAOA,GAAG,CAACC,WAAX,KAA2B,UAAlC;AACD","sourcesContent":["// TODO: @gilad refactor to an abstract env.\nimport type { Linter, LinterContext } from '@teambit/linter';\nimport type { Formatter, FormatterContext } from '@teambit/formatter';\nimport type { Tester } from '@teambit/tester';\nimport type { Compiler } from '@teambit/compiler';\nimport type { Bundler, BundlerContext, DevServer, DevServerContext } from '@teambit/bundler';\nimport type { BuildTask } from '@teambit/builder';\nimport type { SchemaExtractor } from '@teambit/schema';\nimport type { WebpackConfigTransformer } from '@teambit/webpack';\nimport type { PackageJsonProps } from '@teambit/pkg';\nimport type { EnvPolicyConfigObject } from '@teambit/dependency-resolver';\nimport { ElementsWrapperContext } from '@teambit/elements';\nimport type { Capsule } from '@teambit/isolator';\nimport type { Component } from '@teambit/component';\nimport { EnvPreviewConfig } from '@teambit/preview';\n\nexport type EnvDescriptor = {\n  type: string;\n};\n\n/**\n * add a custom type and include all properties from within the environment.\n */\nexport interface Environment {\n  /**\n   * name of the environment.\n   */\n  name?: string;\n\n  /**\n   * description of the environment.\n   */\n  description?: string;\n\n  /**\n   * icon of the environment.\n   */\n  icon?: string;\n\n  [key: string]: any; // :TODO need to define an abstract type for service handlers (now using any)\n\n  /**\n   * Returns the Environment descriptor\n   * Required for any task\n   */\n  __getDescriptor?: () => Promise<EnvDescriptor>;\n\n  /**\n   * Returns a schema generator instance\n   */\n  getSchemaExtractor?: (config?: any) => SchemaExtractor;\n}\n\nexport interface DependenciesEnv extends Environment {\n  /**\n   * Returns the list of dependencies\n   * Required for any task\n   */\n  getDependencies?: () => EnvPolicyConfigObject | Promise<EnvPolicyConfigObject>;\n\n  /**\n   * Returns a list of additional host dependencies\n   * this list will be provided as globals on the window after bit preview bundle\n   * by default bit will merge this list with the peers from the getDependencies function\n   * If you want full control use the getHostDependencies function\n   */\n  getAdditionalHostDependencies?: () => string[] | Promise<string[]>;\n\n  /**\n   * Returns a list of host dependencies\n   * this list will be provided as globals on the window after bit preview bundle\n   * If this is provided, bit won't merge getAdditionalHostDependencies and the peers from getDependencies\n   * but give you full control over the list\n   *\n   * The reason we provided both options is the following:\n   * in most cases when you override the deps from you env, you want bit to take your peers\n   * however, if we only provide the getHostDependencies, during the env composition, you will get the peers of the\n   * original env. which doesn't contain your peers.\n   * In that case you might think that we only need the first option of getAdditionalHostDependencies + getDependencies peers\n   * but there are cases when you want a peer to your component, but you don't want it as part of the bundle.\n   * such an example is react-native env which adds react-native as peer, but you don't want it in the bundle as it's not web compatible\n   * so you want full control over it\n   */\n  getHostDependencies?: () => string[] | Promise<string[]>;\n}\n\nexport type GetNpmIgnoreContext = {\n  capsule: Capsule;\n  component: Component;\n};\nexport interface PackageEnv extends Environment {\n  /**\n   * define the package json properties to add to each component.\n   * Used by `bit link` to augment package.json with new properties\n   */\n  getPackageJsonProps?: () => PackageJsonProps;\n\n  /**\n   * return `.npmignore` entries to be written before packing the component\n   */\n  getNpmIgnore?: (npmIgnoreContext?: GetNpmIgnoreContext) => string[];\n}\n\nexport interface LinterEnv extends Environment {\n  /**\n   * Returns & configures the linter to use (ESLint, ...)\n   * Required for `bit lint`\n   */\n  getLinter?: (context: LinterContext, transformers: any[]) => Linter;\n}\n\nexport interface FormatterEnv extends Environment {\n  /**\n   * Returns & configures the formatter to use (prettier, ...)\n   * Required for `bit format`\n   */\n  getFormatter?: (context: FormatterContext, transformers: any[]) => Formatter;\n}\n\nexport interface PreviewEnv extends Environment {\n  /**\n   * Returns a paths to a function which mounts a given component to DOM\n   * Required for `bit start` & `bit build`\n   */\n  getMounter?: () => string;\n\n  /**\n   * Returns a path to a docs template.\n   * Required for `bit start` & `bit build`\n   */\n  getDocsTemplate?: () => string;\n\n  /**\n   * Returns a bundler for the preview.\n   * Required for `bit build` & `bit start`\n   */\n  getBundler?: (context: BundlerContext, transformers: any[]) => Promise<Bundler>;\n\n  /**\n   * Returns preview config like the strategy name to use when bundling the components for the preview\n   */\n  getPreviewConfig?: () => EnvPreviewConfig;\n\n  /**\n   * Returns a bundler for the env template.\n   * this bundler will be used to bundle the docs/compositions (or other preview) apps\n   * Required for `bit build` & `bit tag`\n   */\n  getTemplateBundler?: (context: BundlerContext, transformers?: any[]) => Promise<Bundler>;\n}\n\nexport interface ElementsEnv extends Environment {\n  /**\n   * Returns a function that gets the context and wrap the component with a web component\n   * Required for `bit build`\n   */\n  getElementsWrapper: (context: ElementsWrapperContext) => string;\n\n  /**\n   * Returns a bundler for elements.\n   * Required for `bit build``\n   */\n  getElementsBundler: (context: BundlerContext, transformers: any[]) => Promise<Bundler>;\n}\n\nexport type PipeServiceModifiersMap = Record<string, PipeServiceModifier>;\n\nexport interface PipeServiceModifier {\n  transformers?: Function[];\n  module?: any;\n}\n\nexport interface BuilderEnv extends PreviewEnv {\n  /**\n   * @deprecated Fatal: a breaking API was introduced. Use getBuildPipe() instead.\n   */\n  getPipe?: () => BuildTask[];\n\n  /**\n   * Returns the component build pipeline\n   * Either `getBuildPipe`, `getTagPipe`, or `getSnapPipe` is required for `bit build`\n   */\n  getBuildPipe?: (modifiersMap?: PipeServiceModifiersMap) => BuildTask[];\n\n  /**\n   * Returns the component tag pipeline\n   * Either `getBuildPipe`, `getTagPipe`, or `getSnapPipe` is required for `bit build`\n   */\n  getTagPipe?: (modifiersMap?: PipeServiceModifiersMap) => BuildTask[];\n\n  /**\n   * Returns the component snap pipeline\n   * Either `getBuildPipe`, `getTagPipe`, or `getSnapPipe` is required for `bit build`\n   */\n  getSnapPipe?: (modifiersMap?: PipeServiceModifiersMap) => BuildTask[];\n}\n\nexport interface TesterEnv extends Environment {\n  /**\n   * Returns a tester\n   * Required for `bit start` & `bit test`\n   */\n  getTester?: (path: string, tester: any) => Tester;\n}\n\nexport interface CompilerEnv {\n  /**\n   * Returns a compiler\n   * Required for making and reading dists, especially for `bit compile`\n   */\n  getCompiler: () => Compiler;\n}\n\nexport function hasCompiler(obj: Environment): obj is CompilerEnv {\n  return typeof obj.getCompiler === 'function';\n}\n\nexport interface DevEnv extends PreviewEnv {\n  /**\n   * Required for `bit start`\n   */\n  getDevEnvId?: (context?: any) => string;\n\n  /**\n   * Returns and configures the dev server\n   * Required for `bit start`\n   */\n  getDevServer?: (\n    context: DevServerContext,\n    transformers: WebpackConfigTransformer[]\n  ) => DevServer | Promise<DevServer>;\n}\n"]}