"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IssuesMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _issuesCmd() {
  const data = require("./issues-cmd");

  _issuesCmd = function () {
    return data;
  };

  return data;
}

function _issues() {
  const data = require("./issues.aspect");

  _issues = function () {
    return data;
  };

  return data;
}

class IssuesMain {
  constructor(config) {
    this.config = config;
  }

  getIssuesToIgnore() {
    const allIssues = this.listIssues().map(issue => issue.name);
    const issuesToIgnore = this.config.ignoreIssues || [];
    issuesToIgnore.forEach(issueToIgnore => {
      if (!allIssues.includes(issueToIgnore)) {
        throw new (_bitError().BitError)(`fatal: a non-existing component-issue "${issueToIgnore}" was configured for ${_issues().IssuesAspect.id} aspect`);
      }
    });
    return issuesToIgnore;
  }

  listIssues() {
    const instances = Object.keys(_componentIssues().IssuesClasses).map(issueClass => new (_componentIssues().IssuesClasses[issueClass])());
    const issuesList = new (_componentIssues().IssuesList)(instances);
    const nonLegacyIssues = issuesList.getHarmonyIssues();
    return nonLegacyIssues.map(issueInstance => {
      return {
        name: issueInstance.constructor.name,
        description: issueInstance.description,
        solution: issueInstance.solution,
        isTagBlocker: issueInstance.isTagBlocker
      };
    });
  }

  static async provider([cli], config) {
    const issuesMain = new IssuesMain(config);
    cli.register(new (_issuesCmd().ComponentIssuesCmd)(issuesMain));
    return issuesMain;
  }

}

exports.IssuesMain = IssuesMain;
(0, _defineProperty2().default)(IssuesMain, "slots", []);
(0, _defineProperty2().default)(IssuesMain, "dependencies", [_cli().CLIAspect]);
(0, _defineProperty2().default)(IssuesMain, "defaultConfig", {
  ignoreIssues: []
});
(0, _defineProperty2().default)(IssuesMain, "runtime", _cli().MainRuntime);

_issues().IssuesAspect.addRuntime(IssuesMain);

//# sourceMappingURL=issues.main.runtime.js.map