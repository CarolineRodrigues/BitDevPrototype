{"version":3,"sources":["logger.ts"],"names":["Logger","constructor","extensionName","trace","message","meta","logger","colorMessage","debug","info","warn","error","fatal","isLoaderStarted","loader","isStarted","createLongProcessLogger","processDescription","totalItems","LongProcessLogger","setStatusLine","text","setTextAndRestart","clearStatusLine","stop","console","shouldWriteToConsole","log","stopAndPersist","consoleTitle","chalk","bold","consoleSuccess","succeed","off","on","profile","id","consoleFailure","fail","consoleWarning","isJsonFormat","hex"],"mappings":"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","sourcesContent":["import loader from '@teambit/legacy/dist/cli/loader';\nimport logger, { IBitLogger } from '@teambit/legacy/dist/logger/logger';\nimport chalk from 'chalk';\nimport stc from 'string-to-color';\n\nimport { LongProcessLogger } from './long-process-logger';\n\nexport class Logger implements IBitLogger {\n  constructor(private extensionName: string) {}\n\n  trace(message: string, ...meta: any[]) {\n    logger.trace(this.colorMessage(message), ...meta);\n  }\n  debug(message: string, ...meta: any[]) {\n    logger.debug(this.colorMessage(message), ...meta);\n  }\n  info(message: string, ...meta: any[]) {\n    logger.info(this.colorMessage(message), ...meta);\n  }\n  warn(message: string, ...meta: any[]) {\n    logger.warn(this.colorMessage(message), ...meta);\n  }\n  error(message: string, ...meta: any[]) {\n    logger.error(this.colorMessage(message), ...meta);\n  }\n  fatal(message: string, ...meta: any[]) {\n    logger.fatal(this.colorMessage(message), ...meta);\n  }\n\n  get isLoaderStarted() {\n    return loader.isStarted;\n  }\n  /**\n   * use it for a long running process. upon creation it logs the `processDescription`.\n   * if the process involves iteration over a list of items, such as running tag on a list of\n   * components, then pass the `totalItems` as the total of the total components in the list.\n   * later, during the iteration, call `LongProcessLogger.logProgress(componentName)`.\n   * once done, call `LongProcessLogger.end()`\n   * the status-line will show all messages in the terminal.\n   */\n  createLongProcessLogger(processDescription: string, totalItems?: number): LongProcessLogger {\n    return new LongProcessLogger(this, this.extensionName, processDescription, totalItems);\n  }\n  /**\n   * single status-line on the bottom of the screen.\n   * the text is replaced every time this method is called.\n   */\n  setStatusLine(text: string) {\n    loader.setTextAndRestart(text);\n  }\n  /**\n   * remove the text from the last line on the screen.\n   */\n  clearStatusLine() {\n    loader.stop();\n  }\n  /**\n   * print to the screen. if message is empty, print the last logged message.\n   */\n  console(message?: string) {\n    if (message) this.info(message);\n    if (!loader.isStarted && logger.shouldWriteToConsole) {\n      // eslint-disable-next-line no-console\n      console.log(message);\n    } else {\n      loader.stopAndPersist({ text: message });\n    }\n  }\n  /**\n   * print to the screen as a title, with bold text.\n   */\n  consoleTitle(message: string) {\n    this.info(message);\n    loader.stopAndPersist({ text: chalk.bold(message) });\n  }\n  /**\n   * print to the screen with a green `✔` prefix. if message is empty, print the last logged message.\n   */\n  consoleSuccess(message?: string) {\n    if (message) this.info(message);\n    loader.succeed(message);\n  }\n\n  /**\n   * turn off the logger.\n   */\n  off() {\n    return loader.off();\n  }\n\n  on() {\n    return loader.on();\n  }\n\n  profile(id: string, console?: boolean) {\n    logger.profile(id, console);\n  }\n\n  /**\n   * print to the screen with a red `✖` prefix. if message is empty, print the last logged message.\n   */\n  consoleFailure(message?: string) {\n    if (message) this.error(message);\n    loader.fail(message);\n  }\n  /**\n   * print to the screen with a red `⚠` prefix. if message is empty, print the last logged message.\n   */\n  consoleWarning(message?: string) {\n    if (message) this.warn(message);\n    loader.warn(message);\n  }\n\n  private colorMessage(message: string) {\n    const text = `${this.extensionName}, ${message}`;\n    if (logger.isJsonFormat) return text;\n    return chalk.hex(stc(this.extensionName))(text);\n  }\n}\n"]}