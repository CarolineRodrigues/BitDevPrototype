"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceComponentLoader = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("@teambit/legacy/dist/consumer/config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _component2() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component"));

  _component2 = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/bit-map/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@teambit/legacy/dist/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _exceptions2() {
  const data = require("@teambit/legacy/dist/scope/exceptions");

  _exceptions2 = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = require("@teambit/legacy/dist/consumer/config");

  _config = function () {
    return data;
  };

  return data;
}

function _inMemoryCache() {
  const data = require("@teambit/legacy/dist/cache/in-memory-cache");

  _inMemoryCache = function () {
    return data;
  };

  return data;
}

function _cacheFactory() {
  const data = require("@teambit/legacy/dist/cache/cache-factory");

  _cacheFactory = function () {
    return data;
  };

  return data;
}

function _componentNotFoundInPath() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/exceptions/component-not-found-in-path"));

  _componentNotFoundInPath = function () {
    return data;
  };

  return data;
}

function _workspaceComponent() {
  const data = require("./workspace-component");

  _workspaceComponent = function () {
    return data;
  };

  return data;
}

class WorkspaceComponentLoader {
  // cache loaded components
  // cache loaded components for capsule, must not use the cache for the workspace
  constructor(workspace, logger, dependencyResolver, envs) {
    this.workspace = workspace;
    this.logger = logger;
    this.dependencyResolver = dependencyResolver;
    this.envs = envs;
    (0, _defineProperty2().default)(this, "componentsCache", void 0);
    (0, _defineProperty2().default)(this, "componentsCacheForCapsule", void 0);
    this.componentsCache = (0, _cacheFactory().createInMemoryCache)({
      maxSize: (0, _inMemoryCache().getMaxSizeForComponents)()
    });
    this.componentsCacheForCapsule = (0, _cacheFactory().createInMemoryCache)({
      maxSize: (0, _inMemoryCache().getMaxSizeForComponents)()
    });
  }

  async getMany(ids, forCapsule = false) {
    const idsWithoutEmpty = (0, _lodash().compact)(ids);
    const errors = [];
    const longProcessLogger = this.logger.createLongProcessLogger('loading components', ids.length);
    const componentsP = (0, _pMapSeries().default)(idsWithoutEmpty, async id => {
      longProcessLogger.logProgress(id.toString());
      return this.get(id, forCapsule).catch(err => {
        if (this.isComponentNotExistsError(err)) {
          errors.push({
            id,
            err
          });
          return undefined;
        }

        throw err;
      });
    });
    const components = await componentsP;
    errors.forEach(err => {
      if (!this.workspace.consumer.isLegacy) {
        this.logger.console(`failed loading component ${err.id.toString()}, see full error in debug.log file`);
      }

      this.logger.warn(`failed loading component ${err.id.toString()}`, err.err);
    }); // remove errored components

    const filteredComponents = (0, _lodash().compact)(components);
    longProcessLogger.end();
    return filteredComponents;
  }

  async getInvalid(ids) {
    const idsWithoutEmpty = (0, _lodash().compact)(ids);
    const errors = [];
    const longProcessLogger = this.logger.createLongProcessLogger('loading components', ids.length);
    await (0, _pMapSeries().default)(idsWithoutEmpty, async id => {
      longProcessLogger.logProgress(id.toString());

      try {
        await this.workspace.consumer.loadComponent(id._legacy);
      } catch (err) {
        if (_component2().default.isComponentInvalidByErrorType(err)) {
          errors.push({
            id,
            err
          });
          return;
        }

        throw err;
      }
    });
    return errors;
  }

  async get(componentId, forCapsule = false, legacyComponent, useCache = true, storeInCache = true) {
    const bitIdWithVersion = (0, _utils().getLatestVersionNumber)(this.workspace.consumer.bitmapIdsFromCurrentLane, componentId._legacy);
    const id = bitIdWithVersion.version ? componentId.changeVersion(bitIdWithVersion.version) : componentId;
    const fromCache = this.getFromCache(id, forCapsule);

    if (fromCache && useCache) {
      return fromCache;
    }

    const consumerComponent = legacyComponent || (await this.getConsumerComponent(id, forCapsule)); // in case of out-of-sync, the id may changed during the load process

    const updatedId = consumerComponent ? _component().ComponentID.fromLegacy(consumerComponent.id, id.scope) : id;
    const component = await this.loadOne(updatedId, consumerComponent);

    if (storeInCache) {
      this.addMultipleEnvsIssueIfNeeded(component); // it's in storeInCache block, otherwise, it wasn't fully loaded

      this.saveInCache(component, forCapsule);
    }

    return component;
  }

  async getIfExist(componentId) {
    try {
      return await this.get(componentId);
    } catch (err) {
      if (this.isComponentNotExistsError(err)) {
        return undefined;
      }

      throw err;
    }
  }

  addMultipleEnvsIssueIfNeeded(component) {
    const envs = this.envs.getAllEnvsConfiguredOnComponent(component);
    const envIds = (0, _lodash().uniq)(envs.map(env => env.id));

    if (envIds.length < 2) {
      return;
    }

    component.state.issues.getOrCreate(_componentIssues().IssuesClasses.MultipleEnvs).data = envIds;
  }

  clearCache() {
    this.componentsCache.deleteAll();
    this.componentsCacheForCapsule.deleteAll();
  }

  clearComponentCache(id) {
    const idStr = id.toString();
    this.componentsCache.delete(idStr);
    this.componentsCacheForCapsule.delete(idStr);
  }

  async loadOne(id, consumerComponent) {
    const componentFromScope = await this.workspace.scope.get(id);

    if (!consumerComponent) {
      if (!componentFromScope) throw new (_exceptions().MissingBitMapComponent)(id.toString());
      return componentFromScope;
    }

    const {
      extensions
    } = await this.workspace.componentExtensions(id, componentFromScope);
    const extensionsFromConsumerComponent = consumerComponent.extensions || new (_extensionData().ExtensionDataList)(); // Merge extensions added by the legacy code in memory (for example data of dependency resolver)

    const extensionDataList = _extensionData().ExtensionDataList.mergeConfigs([extensionsFromConsumerComponent, extensions]).filterRemovedExtensions(); // temporarily mutate consumer component extensions until we remove all direct access from legacy to extensions data
    // TODO: remove this once we remove all direct access from legacy code to extensions data


    consumerComponent.extensions = extensionDataList;
    const state = new (_component().State)(new (_component().Config)(consumerComponent.mainFile, extensionDataList), await this.workspace.createAspectList(extensionDataList), _component().ComponentFS.fromVinyls(consumerComponent.files), consumerComponent.dependencies, consumerComponent);

    if (componentFromScope) {
      // Removed by @gilad. do not mutate the component from the scope
      // componentFromScope.state = state;
      // const workspaceComponent = WorkspaceComponent.fromComponent(componentFromScope, this.workspace);
      const workspaceComponent = new (_workspaceComponent().WorkspaceComponent)(componentFromScope.id, componentFromScope.head, state, componentFromScope.tags, this.workspace);
      return this.executeLoadSlot(workspaceComponent);
    }

    return this.executeLoadSlot(this.newComponentFromState(id, state));
  }

  saveInCache(component, forCapsule) {
    if (forCapsule) {
      this.componentsCacheForCapsule.set(component.id.toString(), component);
    } else {
      this.componentsCache.set(component.id.toString(), component);
    }
  }
  /**
   * make sure that not only the id-str match, but also the legacy-id.
   * this is needed because the ComponentID.toString() is the same whether or not the legacy-id has
   * scope-name, as it includes the defaultScope if the scope is empty.
   * as a result, when out-of-sync is happening and the id is changed to include scope-name in the
   * legacy-id, the component is the cache has the old id.
   */


  getFromCache(id, forCapsule) {
    const fromCache = forCapsule ? this.componentsCacheForCapsule.get(id.toString()) : this.componentsCache.get(id.toString());

    if (fromCache && fromCache.id._legacy.isEqual(id._legacy)) {
      return fromCache;
    }

    return undefined;
  }

  async getConsumerComponent(id, forCapsule = false) {
    try {
      return forCapsule ? // eslint-disable-next-line @typescript-eslint/return-await
      await this.workspace.consumer.loadComponentForCapsule(id._legacy) : // eslint-disable-next-line @typescript-eslint/return-await
      await this.workspace.consumer.loadComponent(id._legacy);
    } catch (err) {
      // don't return undefined for any error. otherwise, if the component is invalid (e.g. main
      // file is missing) it returns the model component later unexpectedly, or if it's new, it
      // shows MissingBitMapComponent error incorrectly.
      if (this.isComponentNotExistsError(err)) {
        this.logger.debug(`failed loading component "${id.toString()}" from the workspace due to "${err.name}" error\n${err.message}`);
        return undefined;
      }

      throw err;
    }
  }

  isComponentNotExistsError(err) {
    return err instanceof _exceptions2().ComponentNotFound || err instanceof _exceptions().MissingBitMapComponent || err instanceof _componentNotFoundInPath().default;
  }

  async executeLoadSlot(component) {
    const entries = this.workspace.onComponentLoadSlot.toArray();
    const promises = entries.map(async ([extension, onLoad]) => {
      const data = await onLoad(component);
      return this.upsertExtensionData(component, extension, data);
    }); // Special load events which runs from the workspace but should run from the correct aspect
    // TODO: remove this once those extensions dependent on workspace

    const envsData = await this.workspace.getEnvSystemDescriptor(component); // Move to deps resolver main runtime once we switch ws<> deps resolver direction

    const policy = await this.dependencyResolver.mergeVariantPolicies(component.config.extensions);
    const dependencies = await this.dependencyResolver.extractDepsFromLegacy(component, policy);
    const depResolverData = {
      dependencies,
      policy: policy.serialize()
    };
    promises.push(this.upsertExtensionData(component, _envs().EnvsAspect.id, envsData));
    promises.push(this.upsertExtensionData(component, _dependencyResolver().DependencyResolverAspect.id, depResolverData));
    await Promise.all(promises); // Update the aspect list to have changes happened during the on load slot (new data added above)

    const updatedAspectList = await this.workspace.createAspectList(component.state.config.extensions);
    component.state.aspects = updatedAspectList;
    return component;
  }

  newComponentFromState(id, state) {
    return new (_workspaceComponent().WorkspaceComponent)(id, null, state, new (_component().TagMap)(), this.workspace);
  }

  async upsertExtensionData(component, extension, data) {
    const existingExtension = component.state.config.extensions.findExtension(extension);

    if (existingExtension) {
      // Only merge top level of extension data
      Object.assign(existingExtension.data, data);
      return;
    }

    component.state.config.extensions.push(await this.getDataEntry(extension, data));
  }

  async getDataEntry(extension, data) {
    // TODO: @gilad we need to refactor the extension data entry api.
    return new (_config().ExtensionDataEntry)(undefined, undefined, extension, undefined, data);
  }

}

exports.WorkspaceComponentLoader = WorkspaceComponentLoader;

//# sourceMappingURL=workspace-component-loader.js.map