import type { PubsubMain } from '@teambit/pubsub';
import { IssuesList } from '@teambit/component-issues';
import type { AspectLoaderMain, AspectDefinition } from '@teambit/aspect-loader';
import { ComponentMain, Component, ComponentFactory, ComponentID, ComponentMap, AspectList, AspectData, InvalidComponent } from '@teambit/component';
import { ComponentScopeDirMap } from '@teambit/config';
import { WorkspaceDependencyLifecycleType, DependencyResolverMain, LinkingOptions, LinkResults } from '@teambit/dependency-resolver';
import { EnvsMain } from '@teambit/envs';
import { GraphqlMain } from '@teambit/graphql';
import { Harmony } from '@teambit/harmony';
import { IsolatorMain } from '@teambit/isolator';
import { Logger } from '@teambit/logger';
import type { ScopeMain } from '@teambit/scope';
import { RequireableComponent } from '@teambit/harmony.modules.requireable-component';
import { ResolvedComponent } from '@teambit/harmony.modules.resolved-component';
import type { VariantsMain } from '@teambit/variants';
import LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';
import { BitIds } from '@teambit/legacy/dist/bit-id';
import { BitId } from '@teambit/legacy-bit-id';
import { LocalLaneId, RemoteLaneId } from '@teambit/legacy/dist/lane-id/lane-id';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { GetBitMapComponentOptions } from '@teambit/legacy/dist/consumer/bit-map/bit-map';
import type { AddActionResults, Warnings } from '@teambit/legacy/dist/consumer/component-ops/add-components/add-components';
import ComponentsList from '@teambit/legacy/dist/consumer/component/components-list';
import { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';
import { PathOsBased, PathOsBasedRelative, PathOsBasedAbsolute } from '@teambit/legacy/dist/utils/path';
import ConsumerComponent from '@teambit/legacy/dist/consumer/component';
import type { ComponentLog } from '@teambit/legacy/dist/scope/models/model-component';
import { CompilationInitiator } from '@teambit/compiler';
import { Lane } from '@teambit/legacy/dist/scope/models';
import { OnComponentAdd, OnComponentChange, OnComponentEventResult, OnComponentLoad, OnComponentRemove } from './on-component-events';
import { WorkspaceExtConfig } from './types';
import { Watcher, WatchOptions } from './watch/watcher';
import { ComponentStatus } from './workspace-component/component-status';
import { OnComponentAddSlot, OnComponentChangeSlot, OnComponentLoadSlot, OnComponentRemoveSlot, OnPreWatch, OnPreWatchSlot } from './workspace.provider';
import { WorkspaceComponentLoader } from './workspace-component/workspace-component-loader';
import { ShouldIgnoreFunc } from './build-graph-from-fs';
import { BitMap } from './bit-map';
export declare type EjectConfResult = {
    configPath: string;
};
export declare const AspectSpecificField = "__specific";
export declare const ComponentAdded = "componentAdded";
export declare const ComponentChanged = "componentChanged";
export declare const ComponentRemoved = "componentRemoved";
export interface EjectConfOptions {
    propagate?: boolean;
    override?: boolean;
}
export declare type WorkspaceInstallOptions = {
    addMissingPeers?: boolean;
    variants?: string;
    lifecycleType?: WorkspaceDependencyLifecycleType;
    dedupe: boolean;
    import: boolean;
    copyPeerToRuntimeOnRoot?: boolean;
    copyPeerToRuntimeOnComponents?: boolean;
    updateExisting: boolean;
    savePrefix?: string;
};
export declare type ModulesInstallOptions = Omit<WorkspaceInstallOptions, 'updateExisting' | 'lifecycleType' | 'import'>;
export declare type WorkspaceLinkOptions = LinkingOptions;
export declare type TrackData = {
    rootDir: PathOsBasedRelative;
    componentName?: string;
    mainFile?: string;
    defaultScope?: string;
    config?: {
        [aspectName: string]: any;
    };
};
export declare type ExtensionsOrigin = 'BitmapFile' | 'ModelSpecific' | 'ModelNonSpecific' | 'WorkspaceVariants' | 'ComponentJsonFile' | 'WorkspaceDefault' | 'FinalAfterMerge';
export declare type TrackResult = {
    componentName: string;
    files: string[];
    warnings: Warnings;
};
/**
 * API of the Bit Workspace
 */
export declare class Workspace implements ComponentFactory {
    /**
     * private pubsub.
     */
    private pubsub;
    private config;
    /**
     * private access to the legacy consumer instance.
     */
    consumer: Consumer;
    /**
     * access to the workspace `Scope` instance
     */
    readonly scope: ScopeMain;
    /**
     * access to the `ComponentProvider` instance
     */
    private componentAspect;
    private isolator;
    private dependencyResolver;
    private variants;
    private aspectLoader;
    private logger;
    private componentList;
    /**
     * private reference to the instance of Harmony.
     */
    private harmony;
    /**
     * on component load slot.
     */
    onComponentLoadSlot: OnComponentLoadSlot;
    /**
     * on component change slot.
     */
    private onComponentChangeSlot;
    private envs;
    /**
     * on component add slot.
     */
    private onComponentAddSlot;
    private onComponentRemoveSlot;
    private onPreWatchSlot;
    private graphql;
    priority: boolean;
    owner?: string;
    componentsScopeDirsMap: ComponentScopeDirMap;
    componentLoader: WorkspaceComponentLoader;
    bitMap: BitMap;
    private componentLoadedSelfAsAspects;
    constructor(
    /**
     * private pubsub.
     */
    pubsub: PubsubMain, config: WorkspaceExtConfig, 
    /**
     * private access to the legacy consumer instance.
     */
    consumer: Consumer, 
    /**
     * access to the workspace `Scope` instance
     */
    scope: ScopeMain, 
    /**
     * access to the `ComponentProvider` instance
     */
    componentAspect: ComponentMain, isolator: IsolatorMain, dependencyResolver: DependencyResolverMain, variants: VariantsMain, aspectLoader: AspectLoaderMain, logger: Logger, componentList: ComponentsList, 
    /**
     * private reference to the instance of Harmony.
     */
    harmony: Harmony, 
    /**
     * on component load slot.
     */
    onComponentLoadSlot: OnComponentLoadSlot, 
    /**
     * on component change slot.
     */
    onComponentChangeSlot: OnComponentChangeSlot, envs: EnvsMain, 
    /**
     * on component add slot.
     */
    onComponentAddSlot: OnComponentAddSlot, onComponentRemoveSlot: OnComponentRemoveSlot, onPreWatchSlot: OnPreWatchSlot, graphql: GraphqlMain);
    private validateConfig;
    /**
     * watcher api.
     */
    readonly watcher: Watcher;
    /**
     * root path of the Workspace.
     */
    get path(): string;
    /** get the `node_modules` folder of this workspace */
    private get modulesPath();
    get isLegacy(): boolean;
    onComponentLoad(loadFn: OnComponentLoad): this;
    registerOnComponentChange(onComponentChangeFunc: OnComponentChange): this;
    registerOnComponentAdd(onComponentAddFunc: OnComponentAdd): this;
    registerOnComponentRemove(onComponentRemoveFunc: OnComponentRemove): this;
    registerOnPreWatch(onPreWatchFunc: OnPreWatch): this;
    /**
     * name of the workspace as configured in either `workspace.json`.
     * defaults to workspace root directory name.
     */
    get name(): string;
    get icon(): string;
    hasModifiedDependencies(component: Component): Promise<boolean>;
    /**
     * get Component issues
     */
    getComponentIssues(component: Component): IssuesList | null;
    /**
     * provides status of all components in the workspace.
     */
    getComponentStatus(component: Component): Promise<ComponentStatus>;
    /**
     * list all workspace components.
     */
    list(filter?: {
        offset: number;
        limit: number;
    }): Promise<Component[]>;
    /**
     * list all invalid components.
     * (see the invalid criteria in ConsumerComponent.isComponentInvalidByErrorType())
     */
    listInvalid(): Promise<InvalidComponent[]>;
    /**
     * get ids of all workspace components.
     */
    listIds(): Promise<ComponentID[]>;
    /**
     * Check if a specific id exist in the workspace
     * @param componentId
     */
    hasId(componentId: ComponentID): Promise<boolean>;
    /**
     * whether or not a workspace has a component with the given name
     */
    hasName(name: string): Promise<boolean>;
    /**
     * Check if a specific id exist in the workspace or in the scope
     * @param componentId
     */
    hasIdNested(componentId: ComponentID, includeCache?: boolean): Promise<boolean>;
    /**
     * list all modified components in the workspace.
     */
    modified(): Promise<Component[]>;
    /**
     * list all new components in the workspace.
     */
    newComponents(): Promise<Component[]>;
    /**
     * get all workspace component-ids, include vendor components.
     * (exclude nested dependencies in case dependencies are saved as components and not packages)
     */
    getAllComponentIds(): Promise<ComponentID[]>;
    getNewAndModifiedIds(): Promise<ComponentID[]>;
    newAndModified(): Promise<Component[]>;
    getLogs(id: ComponentID, shortHash?: boolean, startsFrom?: string): Promise<ComponentLog[]>;
    getLegacyGraph(ids?: ComponentID[]): Promise<LegacyGraph>;
    /**
     * given component ids, find their dependents in the workspace
     */
    getDependentsIds(ids: ComponentID[]): Promise<ComponentID[]>;
    loadCapsules(bitIds: string[]): Promise<import("@teambit/isolator").Capsule[]>;
    /**
     * fully load components, including dependency resolution and prepare them for runtime.
     * @todo: remove the string option, use only BitId
     */
    load(ids: Array<BitId | string>): Promise<ResolvedComponent[]>;
    createAspectList(extensionDataList: ExtensionDataList): Promise<AspectList>;
    private extensionDataEntryToAspectEntry;
    /**
     * get a component from workspace
     * @param id component ID
     */
    get(componentId: ComponentID, forCapsule?: boolean, legacyComponent?: ConsumerComponent, useCache?: boolean, storeInCache?: boolean): Promise<Component>;
    getEnvSystemDescriptor(component: Component): Promise<AspectData>;
    clearCache(): void;
    clearComponentCache(id: ComponentID): void;
    triggerOnComponentChange(id: ComponentID, files: string[], initiator?: CompilationInitiator): Promise<OnComponentEventResult[]>;
    triggerOnComponentAdd(id: ComponentID): Promise<OnComponentEventResult[]>;
    triggerOnComponentRemove(id: ComponentID): Promise<OnComponentEventResult[]>;
    getState(id: ComponentID, hash: string): Promise<import("@teambit/component").State>;
    getSnap(id: ComponentID, hash: string): Promise<import("@teambit/component").Snap>;
    getCurrentLaneId(): LocalLaneId;
    /**
     * if checked out to a lane and the lane exists in the remote,
     * return the remote lane id (name+scope). otherwise, return null.
     */
    getCurrentRemoteLaneId(): Promise<{
        laneId: RemoteLaneId;
        lane: Lane;
    } | null>;
    getDefaultExtensions(): ExtensionDataList;
    ejectMultipleConfigs(ids: ComponentID[], options: EjectConfOptions): Promise<EjectConfResult[]>;
    ejectConfig(id: ComponentID, options: EjectConfOptions): Promise<EjectConfResult>;
    /**
     * see component-aspect, createAspectListFromLegacy() method for a context why this is needed.
     */
    private resolveScopeAspectListIds;
    /**
     * load components into the workspace through a variants pattern.
     * @param pattern variants.
     * @param scope scope name.
     */
    byPattern(pattern: string, scope?: string): Promise<Component[]>;
    /**
     * get component-ids matching the given pattern. a pattern can have multiple patterns separated by a comma.
     * it supports negate (!) character to exclude ids.
     */
    idsByPattern(pattern: string, throwForNoMatch?: boolean): Promise<ComponentID[]>;
    /**
     * useful for workspace commands, such as `bit build`, `bit compile`.
     * by default, it should be running on new and modified components.
     * a user can specify `--all` to run on all components or specify a pattern to limit to specific components.
     * some commands such as build/test needs to run also on the dependents.
     */
    getComponentsByUserInput(all?: boolean, pattern?: string, includeDependents?: boolean): Promise<Component[]>;
    getComponentsUsingEnv(env: string, throwIfNotFound?: boolean): Promise<Component[]>;
    getMany(ids: Array<ComponentID>, forCapsule?: boolean): Promise<Component[]>;
    getManyByLegacy(components: ConsumerComponent[]): Promise<Component[]>;
    /**
     * don't throw an error if the component was not found, simply return undefined.
     */
    getIfExist(componentId: ComponentID): Promise<Component | undefined>;
    /**
     * whether a component exists in the workspace
     */
    exists(componentId: ComponentID): boolean;
    /**
     * This will make sure to fetch the objects prior to load them
     * do not use it if you are not sure you need it.
     * It will influence the performance
     * currently it used only for get many of aspects
     * @param ids
     * @param forCapsule
     */
    importAndGetMany(ids: Array<ComponentID>, forCapsule?: boolean): Promise<Component[]>;
    /**
     * @deprecated use this.track() instead
     * track a new component. (practically, add it to .bitmap).
     *
     * @param componentPaths component paths relative to the workspace dir
     * @param id if not set, will be concluded from the filenames
     * @param main if not set, will try to guess according to some strategies and throws if failed
     * @param override whether add details to an existing component or re-define it
     */
    add(componentPaths: PathOsBasedRelative[], id?: string, main?: string, override?: boolean): Promise<AddActionResults>;
    /**
     * add a new component to the .bitmap file.
     * this method only adds the records in memory but doesn't persist to the filesystem.
     * to write the .bitmap file once completed, run "await this.bitMap.write();"
     */
    track(trackData: TrackData): Promise<TrackResult>;
    /**
     * scopes in bit.dev are "owner.collection".
     * we might have the scope-name only without the owner and we need to retrieve it from the defaultScope in the
     * workspace.jsonc file.
     *
     * @param scopeName scopeName that might not have the owner part.
     * @returns full scope name
     */
    private addOwnerToScopeName;
    write(rootPath: string, component: Component): Promise<void>;
    /**
     * Get the component root dir in the file system (relative to workspace or full)
     * @param componentId
     * @param relative return the path relative to the workspace or full path
     */
    componentDir(componentId: ComponentID, bitMapOptions?: GetBitMapComponentOptions, options?: {
        relative: boolean;
    }): PathOsBased;
    /**
     * component's files in the workspace are symlinked to the node_modules, and a package.json file is generated on that
     * package directory to simulate a valid node package.
     * @returns the package directory inside the node_module.
     * by default the absolute path, unless `options.relative` was set
     */
    componentPackageDir(component: Component, options?: {
        relative: boolean;
    }): string;
    private componentDirFromLegacyId;
    componentDirToAbsolute(relativeComponentDir: PathOsBasedRelative): PathOsBasedAbsolute;
    componentDefaultScope(componentId: ComponentID): Promise<string | undefined>;
    componentDefaultScopeFromComponentDirAndName(relativeComponentDir: PathOsBasedRelative, name: string): Promise<string | undefined>;
    get defaultScope(): string;
    private componentDefaultScopeFromComponentDirAndNameWithoutConfigFile;
    /**
     * Calculate the component config based on:
     * the config property in the .bitmap file
     * the component.json file in the component folder
     * matching pattern in the variants config
     * defaults extensions from workspace config
     * extensions from the model.
     */
    componentExtensions(componentId: ComponentID, componentFromScope?: Component, excludeOrigins?: ExtensionsOrigin[]): Promise<{
        extensions: ExtensionDataList;
        beforeMerge: Array<{
            extensions: ExtensionDataList;
            origin: ExtensionsOrigin;
            extraData: any;
        }>;
    }>;
    private filterEnvsFromExtensionsIfNeeded;
    triggerOnPreWatch(componentIds: ComponentID[], watchOpts: WatchOptions): Promise<void>;
    addSpecificComponentConfig(id: ComponentID, aspectId: string, config?: Record<string, any>): Promise<void>;
    removeSpecificComponentConfig(id: ComponentID, aspectId: string, markWithMinusIfNotExist: boolean): Promise<void>;
    getSpecificComponentConfig(id: ComponentID, aspectId: string): Promise<any>;
    /**
     * This will mutate the entries with extensionId prop to have resolved legacy id
     * This should be worked on the extension data list not the new aspect list
     * @param extensionList
     */
    private resolveExtensionListIds;
    private isVendorComponentByComponentDir;
    /**
     * return the component config from its folder (component.json)
     * @param componentId
     */
    private componentConfigFile;
    private componentConfigFileFromComponentDirAndName;
    getAspectsGraphWithoutCore(components: Component[], isAspect?: ShouldIgnoreFunc): Promise<LegacyGraph>;
    /**
     * load aspects from the workspace and if not exists in the workspace, load from the scope.
     * keep in mind that the graph may have circles.
     */
    loadAspects(ids?: string[], throwOnError?: boolean, neededFor?: ComponentID): Promise<string[]>;
    /**
     * Note - this gets called from Harmony only.
     * returns one graph that includes all dependencies types. each edge has a label of the dependency
     * type. the nodes content is the Component object.
     */
    buildOneGraphForComponents(ids: BitId[], ignoreIds?: BitIds, shouldIgnoreFunc?: ShouldIgnoreFunc): Promise<LegacyGraph>;
    resolveAspects(runtimeName?: string, componentIds?: ComponentID[]): Promise<AspectDefinition[]>;
    private groupIdsByWorkspaceAndScope;
    private groupComponentsByWorkspaceAndScope;
    /**
     * Load all unloaded extensions from a list
     * @param extensions list of extensions with config to load
     */
    loadExtensions(extensions: ExtensionDataList, originatedFrom?: ComponentID, throwOnError?: boolean): Promise<void>;
    /**
     * Provides a cache folder, unique per key.
     * Return value may be undefined, if workspace folder is unconventional (bare-scope, no node_modules, etc)
     */
    getTempDir(id: string): string;
    requireComponents(components: Component[]): Promise<RequireableComponent[]>;
    private getComponentsDirectory;
    /**
     * Install dependencies for all components in the workspace
     *
     * @returns
     * @memberof Workspace
     */
    install(packages?: string[], options?: WorkspaceInstallOptions): Promise<ComponentMap<string>>;
    private _addPackages;
    private _getComponentsWithDependencyPolicies;
    /**
     * Updates out-of-date dependencies in the workspace.
     *
     * @param options.all {Boolean} updates all outdated dependencies without showing a prompt.
     */
    updateDependencies(options: {
        all: boolean;
    }): Promise<ComponentMap<string>>;
    private _variantPatternsToDepPolicesDict;
    private _updateVariantsPolicies;
    private _saveManyComponentConfigFiles;
    private _installModules;
    link(options?: WorkspaceLinkOptions): Promise<LinkResults>;
    /**
     * Generate a filter to pass to the installer
     * This will filter deps which are come from remotes which defined in scope.json
     * those components comes from local remotes, usually doesn't have a package in a registry
     * so no reason to try to install them (it will fail)
     */
    private generateFilterFnForDepsFromLocalRemote;
    /**
     * whether a scope is hosted by Bit cloud.
     * otherwise, it is self-hosted
     */
    private isHostedByBit;
    /**
     * same as `this.importAndGetMany()` with a specific error handling of ComponentNotFound
     */
    private importAndGetAspects;
    private importObjects;
    /**
     * this should be rarely in-use.
     * it's currently used by watch extension as a quick workaround to load .bitmap and the components
     */
    _reloadConsumer(): Promise<void>;
    getComponentPackagePath(component: ConsumerComponent | Component): string;
    get defaultDirectory(): string;
    get legacyDefaultDirectory(): string;
    /**
     * Transform the id to ComponentId and get the exact id as appear in bitmap
     *
     * @param {(string | ComponentID | BitId)} id
     * @returns {Promise<ComponentID>}
     * @memberof Workspace
     */
    resolveComponentId(id: string | ComponentID | BitId): Promise<ComponentID>;
    resolveMultipleComponentIds(ids: Array<string | ComponentID | BitId>): Promise<ComponentID[]>;
    /**
     * This will mutate the original extensions list and resolve it's ids
     *
     * @param {ExtensionDataList} extensions
     * @returns {Promise<void[]>}
     * @memberof Workspace
     */
    resolveExtensionsList(extensions: ExtensionDataList): Promise<void[]>;
    /**
     * This will mutate the original extensions list and make sure all extensions has the ids with the scope / default scope
     *
     * @param {ExtensionDataList} extensions
     * @returns {Promise<void[]>}
     * @memberof Workspace
     */
    addDefaultScopeToExtensionsList(extensions: ExtensionDataList): Promise<void[]>;
    /**
     * Uninstall the specified packages from dependencies.
     *
     * @param {string[]} the list of packages that should be removed from dependencies.
     */
    uninstallDependencies(packages: string[]): Promise<ComponentMap<string>>;
    /**
     * configure an environment to the given components in the .bitmap file, this configuration overrides other, such as
     * overrides in workspace.jsonc.
     */
    setEnvToComponents(envId: ComponentID, componentIds: ComponentID[]): Promise<void>;
    /**
     * remove env configuration from the .bitmap file, so then other configuration, such as "variants" will take place
     */
    unsetEnvFromComponents(ids: ComponentID[]): Promise<{
        changed: ComponentID[];
        unchanged: ComponentID[];
    }>;
}
export default Workspace;
