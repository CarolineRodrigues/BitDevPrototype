"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeOutdatedPkgChoices = makeOutdatedPkgChoices;
exports.pickOutdatedPkgs = pickOutdatedPkgs;

function _colorizeSemverDiff() {
  const data = _interopRequireDefault(require("@pnpm/colorize-semver-diff"));

  _colorizeSemverDiff = function () {
    return data;
  };

  return data;
}

function _semverDiff() {
  const data = _interopRequireDefault(require("@pnpm/semver-diff"));

  _semverDiff = function () {
    return data;
  };

  return data;
}

function _table() {
  const data = require("table");

  _table = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _enquirer() {
  const data = require("enquirer");

  _enquirer = function () {
    return data;
  };

  return data;
}

/**
 * Lets the user pick the packages that should be updated.
 */
async function pickOutdatedPkgs(outdatedPkgs) {
  const {
    updateDependencies
  } = await (0, _enquirer().prompt)({
    choices: makeOutdatedPkgChoices(outdatedPkgs),
    footer: '\nEnter to start updating. Ctrl-c to cancel.',
    indicator: (state, choice) => ` ${choice.enabled ? '●' : '○'}`,
    message: 'Choose which packages to update ' + `(Press ${_chalk().default.cyan('<space>')} to select, ` + `${_chalk().default.cyan('<a>')} to toggle all, ` + `${_chalk().default.cyan('<i>')} to invert selection)
${_chalk().default.green('Green')} - indicates a semantically safe update
${_chalk().default.red('Red')} - indicates a semantically breaking change`,
    name: 'updateDependencies',
    pointer: '❯',
    styles: {
      dark: _chalk().default.white,
      em: _chalk().default.bgBlack.whiteBright,
      success: _chalk().default.white
    },
    type: 'multiselect',

    validate(value) {
      if (value.length === 0) {
        return 'You must choose at least one package.';
      }

      return true;
    },

    j() {
      return this.down();
    },

    k() {
      return this.up();
    }

  });
  return updateDependencies.filter(updateDependency => typeof updateDependency !== 'string');
}

const DEP_TYPE_PRIORITY = {
  dependencies: 0,
  devDependencies: 1,
  peerDependencies: 2
};
/**
 * Groups the outdated packages and makes choices for enquirer's prompt.
 */

function makeOutdatedPkgChoices(outdatedPkgs) {
  outdatedPkgs.sort((pkg1, pkg2) => {
    if (pkg1.targetField === pkg2.targetField) return pkg1.name.localeCompare(pkg2.name);
    return DEP_TYPE_PRIORITY[pkg1.targetField] - DEP_TYPE_PRIORITY[pkg2.targetField];
  });
  const renderedTable = alignColumns(outdatedPkgsRows(outdatedPkgs));
  const groupedChoices = {};
  outdatedPkgs.forEach((outdatedPkg, index) => {
    const context = renderContext(outdatedPkg);

    if (!groupedChoices[context]) {
      groupedChoices[context] = [];
    }

    groupedChoices[context].push({
      message: renderedTable[index],
      name: outdatedPkg
    });
  });
  const choices = Object.entries(groupedChoices).map(([context, subChoices]) => ({
    message: _chalk().default.cyan(context),
    choices: subChoices
  }));
  return choices;
}

function renderContext(outdatedPkg) {
  if (outdatedPkg.variantPattern) {
    return `${outdatedPkg.variantPattern} (variant)`;
  }

  if (outdatedPkg.componentId) {
    return `${outdatedPkg.componentId} (component)`;
  }

  return 'Root policies';
}

const TARGET_FIELD_TO_DEP_TYPE = {
  devDependencies: 'dev',
  dependencies: 'runtime',
  peerDependencies: 'peer'
};

function outdatedPkgsRows(outdatedPkgs) {
  return outdatedPkgs.map(outdatedPkg => {
    const {
      change,
      diff
    } = (0, _semverDiff().default)(outdatedPkg.currentRange, outdatedPkg.latestRange);
    let colorizeChange = change !== null && change !== void 0 ? change : 'breaking';

    if (change === 'feature') {
      colorizeChange = 'fix';
    }

    const latest = (0, _colorizeSemverDiff().default)({
      change: colorizeChange,
      diff
    });
    return [outdatedPkg.name, _chalk().default.grey(`(${TARGET_FIELD_TO_DEP_TYPE[outdatedPkg.targetField]})`), outdatedPkg.currentRange, '❯', latest];
  });
}

function alignColumns(rows) {
  return (0, _table().table)(rows, {
    border: (0, _table().getBorderCharacters)('void'),
    columnDefault: {
      paddingLeft: 0,
      paddingRight: 1
    },
    columns: {
      // This is the current range column
      2: {
        alignment: 'right'
      }
    },
    drawHorizontalLine: () => false
  }).split('\n');
}

//# sourceMappingURL=pick-outdated-pkgs.js.map