{"version":3,"sources":["build-graph-from-fs.ts"],"names":["GraphFromFsBuilder","constructor","workspace","logger","ignoreIds","BitIds","shouldLoadItsDeps","LegacyGraph","consumer","buildGraph","ids","debug","length","start","Date","now","components","loadManyComponents","processManyComponents","graph","getAllDepsUnfiltered","component","getAllDependenciesIds","difference","getAllDepsFiltered","depsWithoutIgnore","shouldLoadFunc","deps","depId","shouldLoad","push","fromArray","depth","importObjects","allDependencies","processOneComponent","allDependenciesFlattened","allDeps","map","c","flat","allDepsWithScope","filter","dep","hasScope","scopeComponentsImporter","ScopeComponentsImporter","scope","importMany","uniqFromArray","throwForDependencyNotFound","shouldThrowOnMissingDep","idStr","id","toString","completed","includes","allIds","Object","entries","depsIdsGroupedByType","forEach","depType","depsIds","has","hasNode","Error","setEdge","componentsIds","dependenciesOf","comp","fromGraph","node","loadComponent","setNode","err","ComponentNotFound","BitError","error","componentId","componentMap","bitMap","getComponentIfExist","isOnWorkspace","Boolean","loadComponentForCapsule","componentFromModel","loadComponentFromModel","clone"],"mappings":"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","sourcesContent":["import mapSeries from 'p-map-series';\nimport { flatten } from 'lodash';\nimport { Consumer } from '@teambit/legacy/dist/consumer';\nimport BitIds from '@teambit/legacy/dist/bit-id/bit-ids';\nimport Component from '@teambit/legacy/dist/consumer/component/consumer-component';\nimport LegacyGraph from '@teambit/legacy/dist/scope/graph/graph';\nimport ScopeComponentsImporter from '@teambit/legacy/dist/scope/component-ops/scope-components-importer';\nimport compact from 'lodash.compact';\nimport { BitId } from '@teambit/legacy-bit-id';\nimport { Logger } from '@teambit/logger';\nimport { ComponentNotFound } from '@teambit/scope';\nimport { BitError } from '@teambit/bit-error';\nimport { Workspace } from './workspace';\n\nexport type ShouldIgnoreFunc = (bitId: BitId) => Promise<boolean>;\n\nexport class GraphFromFsBuilder {\n  private graph = new LegacyGraph();\n  private completed: string[] = [];\n  private depth = 1;\n  private shouldThrowOnMissingDep = true;\n  private consumer: Consumer;\n  constructor(\n    private workspace: Workspace,\n    private logger: Logger,\n    private ignoreIds = new BitIds(),\n    private shouldLoadItsDeps?: ShouldIgnoreFunc\n  ) {\n    this.consumer = this.workspace.consumer;\n  }\n\n  /**\n   * create a graph with all dependencies and flattened dependencies of the given components.\n   * the nodes are components and the edges has a label of the dependency type.\n   *\n   * the way how it is done is iterations by depths. each depth we gather all the dependencies of\n   * that depths, make sure all objects exist and then check their dependencies for the next depth.\n   * once there is no dependency left, we're on the last depth level and the graph is ready.\n   *\n   * for example, imagine the following graph:\n   * A1 -> A2 -> A3\n   * B1 -> B2 -> B3\n   * C1 -> C2 -> C3\n   *\n   * where the buildGraph is given [A1, B1, C1].\n   * first, it saves all these components as nodes in the graph. then, it finds the dependencies of\n   * the next level, in this case they're [A2, B2, C2]. it runs `importMany` in case some objects\n   * are missing. then, it loads them all (some from FS, some from the model) and sets the edges\n   * between the component and the dependencies.\n   * once done, it finds all their dependencies, which are [A3, B3, C3] and repeat the process\n   * above. since there are no more dependencies, the graph is completed.\n   * in this case, the total depth levels are 3.\n   *\n   * even with a huge project, there are not many depth levels. by iterating through depth levels\n   * we keep performance sane as the importMany doesn't run multiple time and therefore the round\n   * trips to the remotes are minimal.\n   *\n   * normally, one importMany of the seeders is enough as importMany knows to fetch all flattened.\n   * however, since this buildGraph is performed on the workspace, a dependency may be new or\n   * modified and as such, we don't know its flattened yet.\n   */\n  async buildGraph(ids: BitId[]): Promise<LegacyGraph> {\n    this.logger.debug(`GraphFromFsBuilder, buildGraph with ${ids.length} seeders`);\n    const start = Date.now();\n    const components = await this.loadManyComponents(ids, '<none>');\n    await this.processManyComponents(components);\n    this.logger.debug(\n      `GraphFromFsBuilder, buildGraph with ${ids.length} seeders completed (${(Date.now() - start) / 1000} sec)`\n    );\n    return this.graph;\n  }\n\n  private getAllDepsUnfiltered(component: Component) {\n    return component.getAllDependenciesIds().difference(this.ignoreIds);\n  }\n\n  private async getAllDepsFiltered(component: Component): Promise<BitIds> {\n    const depsWithoutIgnore = this.getAllDepsUnfiltered(component);\n    const shouldLoadFunc = this.shouldLoadItsDeps;\n    if (!shouldLoadFunc) return depsWithoutIgnore;\n    const deps = await mapSeries(depsWithoutIgnore, async (depId) => {\n      const shouldLoad = await shouldLoadFunc(depId);\n      if (!shouldLoad) this.ignoreIds.push(depId);\n      return shouldLoad ? depId : null;\n    });\n    return BitIds.fromArray(compact(deps));\n  }\n\n  private async processManyComponents(components: Component[]) {\n    this.logger.debug(`GraphFromFsBuilder.processManyComponents depth ${this.depth}, ${components.length} components`);\n    this.depth += 1;\n    await this.importObjects(components);\n    const allDependencies = await mapSeries(components, (component) => this.processOneComponent(component));\n    const allDependenciesFlattened = flatten(allDependencies);\n    if (allDependenciesFlattened.length) await this.processManyComponents(allDependenciesFlattened);\n  }\n\n  private async importObjects(components: Component[]) {\n    const allDeps = components.map((c) => this.getAllDepsUnfiltered(c)).flat();\n    const allDepsWithScope = allDeps.filter((dep) => dep.hasScope());\n    const scopeComponentsImporter = new ScopeComponentsImporter(this.consumer.scope);\n    await scopeComponentsImporter.importMany({\n      ids: BitIds.uniqFromArray(allDepsWithScope),\n      throwForDependencyNotFound: this.shouldThrowOnMissingDep,\n    });\n  }\n\n  private async processOneComponent(component: Component) {\n    const idStr = component.id.toString();\n    if (this.completed.includes(idStr)) return [];\n    const allIds = await this.getAllDepsFiltered(component);\n\n    const allDependencies = await this.loadManyComponents(allIds, idStr);\n    Object.entries(component.depsIdsGroupedByType).forEach(([depType, depsIds]) => {\n      depsIds.forEach((depId) => {\n        if (this.ignoreIds.has(depId)) return;\n        if (!this.graph.hasNode(depId.toString())) {\n          throw new Error(`buildOneComponent: missing node of ${depId.toString()}`);\n        }\n        this.graph.setEdge(idStr, depId.toString(), depType);\n      });\n    });\n    this.completed.push(idStr);\n    return allDependencies;\n  }\n\n  private async loadManyComponents(componentsIds: BitId[], dependenciesOf: string): Promise<Component[]> {\n    const components = await mapSeries(componentsIds, async (comp: BitId) => {\n      const idStr = comp.toString();\n      const fromGraph = this.graph.node(idStr);\n      if (fromGraph) return fromGraph;\n      try {\n        const component = await this.loadComponent(comp);\n        this.graph.setNode(idStr, component);\n        return component;\n      } catch (err: any) {\n        if (err instanceof ComponentNotFound) {\n          throw new BitError(\n            `error: component \"${idStr}\" was not found.\\nthis component is a dependency of \"${dependenciesOf}\" and is needed as part of the graph generation`\n          );\n        }\n        this.logger.error(`failed loading dependencies of ${dependenciesOf}`);\n        throw err;\n      }\n    });\n    return components;\n  }\n  private async loadComponent(componentId: BitId): Promise<Component> {\n    const componentMap = this.consumer.bitMap.getComponentIfExist(componentId);\n    const isOnWorkspace = Boolean(componentMap);\n    if (isOnWorkspace) {\n      return this.consumer.loadComponentForCapsule(componentId);\n    }\n    // a dependency might have been installed as a package in the workspace, and as such doesn't\n    // have a componentMap.\n    const componentFromModel = await this.consumer.loadComponentFromModel(componentId);\n    return componentFromModel.clone();\n  }\n}\n"]}