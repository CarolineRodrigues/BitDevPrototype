"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YarnPackageManager = void 0;

function _parsePackageName() {
  const data = _interopRequireDefault(require("parse-package-name"));

  _parsePackageName = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _core() {
  const data = require("@yarnpkg/core");

  _core = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@yarnpkg/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _fslib() {
  const data = require("@yarnpkg/fslib");

  _fslib = function () {
    return data;
  };

  return data;
}

function _pluginNpm() {
  const data = _interopRequireDefault(require("@yarnpkg/plugin-npm"));

  _pluginNpm = function () {
    return data;
  };

  return data;
}

function _parseOverrides() {
  const data = _interopRequireDefault(require("@pnpm/parse-overrides"));

  _parseOverrides = function () {
    return data;
  };

  return data;
}

function _userHome() {
  const data = _interopRequireDefault(require("user-home"));

  _userHome = function () {
    return data;
  };

  return data;
}

function _versionSelectorType2() {
  const data = _interopRequireDefault(require("version-selector-type"));

  _versionSelectorType2 = function () {
    return data;
  };

  return data;
}

class YarnPackageManager {
  constructor(depResolver, pkg, logger) {
    this.depResolver = depResolver;
    this.pkg = pkg;
    this.logger = logger;
  }

  async install(rootDir, rootPolicy, componentDirectoryMap, installOptions = {}) {
    this.logger.setStatusLine('installing dependencies');
    const options = {
      filterComponentsFromManifests: true,
      createManifestForComponentsWithoutDependencies: true,
      dedupe: true,
      dependencyFilterFn: installOptions.dependencyFilterFn
    };
    const components = componentDirectoryMap.components;
    const workspaceManifest = await this.depResolver.getWorkspaceManifest(undefined, undefined, rootPolicy, rootDir, components, options);

    const rootDirPath = _fslib().npath.toPortablePath(rootDir);

    const cacheDir = this.getCacheFolder(installOptions.cacheRootDir);
    const config = await this.computeConfiguration(rootDirPath, cacheDir, {
      nodeLinker: installOptions.nodeLinker,
      packageManagerConfigRootDir: installOptions.packageManagerConfigRootDir
    });
    const project = new (_core().Project)(rootDirPath, {
      configuration: config
    });
    const rootManifest = workspaceManifest.toJsonWithDir({
      copyPeerToRuntime: installOptions.copyPeerToRuntimeOnRoot,
      installPeersFromEnvs: installOptions.installPeersFromEnvs
    }).manifest; // @ts-ignore

    project.setupResolutions();
    const rootWs = await this.createWorkspace(rootDir, project, rootManifest, installOptions.overrides); // const manifests = Array.from(workspaceManifest.componentsManifestsMap.entries());

    const manifests = this.computeComponents(workspaceManifest.componentsManifestsMap, componentDirectoryMap, installOptions.copyPeerToRuntimeOnComponents);
    await (0, _dependencyResolver().extendWithComponentsFromDir)(rootDir, manifests);
    this.logger.debug('root manifest for installation', rootManifest);
    this.logger.debug('components manifests for installation', manifests);
    const workspacesIdents = {};
    const workspacesP = Object.keys(manifests).map(async path => {
      const manifest = manifests[path];
      const workspace = await this.createWorkspace(path, project, manifest);
      const workspaceIdentHash = workspace.locator.identHash; //

      if (workspacesIdents[workspaceIdentHash]) {
        this.logger.debug(`overriding internal workspace fields to prevent duplications for workspace ${workspace.cwd}`);
        this.overrideInternalWorkspaceParams(workspace);
      }

      workspacesIdents[workspace.locator.identHash] = true;
      return workspace;
    });
    const workspaces = await Promise.all(workspacesP);
    this.setupWorkspaces(project, workspaces.concat(rootWs));
    const cache = await _core().Cache.find(config); // const existingPackageJsons = await this.backupPackageJsons(rootDir, componentDirectoryMap);

    const installReport = await _core().StreamReport.start({
      stdout: process.stdout,
      configuration: config
    }, async report => {
      await project.install({
        persistProject: false,
        cache,
        report
      });
      await project.persistLockfile();
    }); // TODO: check if package.json and link files generation can be prevented through the yarn API or
    // mock the files by hooking to `xfs`.
    // see the persistProject: false above
    // await this.restorePackageJsons(existingPackageJsons);

    if (installReport.hasErrors()) process.exit(installReport.exitCode());
    this.logger.consoleSuccess('installing dependencies');
  }

  getPackageJsonPath(dir) {
    const packageJsonPath = (0, _path().join)(dir, 'package.json');
    return packageJsonPath;
  }

  async backupPackageJsons(rootDir, componentDirectoryMap) {
    const result = {};
    const rootPackageJsonPath = this.getPackageJsonPath(rootDir);
    result[rootPackageJsonPath] = await this.getFileToBackup(rootPackageJsonPath);
    const componentsBackupsP = componentDirectoryMap.toArray().map(async ([component, dir]) => {
      const {
        packageJsonPath,
        file
      } = await this.getComponentPackageJsonToBackup(component, dir);
      result[packageJsonPath] = file;
    });
    await Promise.all(componentsBackupsP);
    return result;
  }

  async restorePackageJsons(backupJsons) {
    const promises = Object.entries(backupJsons).map(async ([packageJsonPath, file]) => {
      const exists = await _fsExtra().default.pathExists(packageJsonPath); // if there is no backup it means it wasn't there before and should be deleted

      if (!file) {
        if (exists) {
          return _fsExtra().default.remove(packageJsonPath);
        }

        return undefined;
      }

      return _fsExtra().default.writeFile(packageJsonPath, file);
    });
    await Promise.all(promises);
  }

  async getFileToBackup(packageJsonPath) {
    const exists = await _fsExtra().default.pathExists(packageJsonPath);

    if (!exists) {
      return undefined;
    }

    const existingFile = await _fsExtra().default.readFile(packageJsonPath);
    return existingFile;
  }

  async getComponentPackageJsonToBackup(component, dir) {
    const packageJsonPath = (0, _path().resolve)((0, _path().join)(dir, 'package.json'));
    const result = {
      packageJsonPath,
      file: await this.getFileToBackup(packageJsonPath)
    };
    return result;
  }

  async createWorkspace(rootDir, project, manifest, overrides) {
    const wsPath = _fslib().npath.toPortablePath(rootDir);

    const name = manifest.name || 'workspace';
    const ws = new (_core().Workspace)(wsPath, {
      project
    });
    await ws.setup();

    const identity = _core().structUtils.parseIdent(name); // const needOverrideInternal = !!ws.manifest.name && !!manifest.name;


    ws.manifest.name = identity;
    ws.manifest.version = manifest.version;
    ws.manifest.dependencies = this.computeDeps(manifest.dependencies);
    ws.manifest.devDependencies = this.computeDeps(manifest.devDependencies);
    ws.manifest.peerDependencies = this.computeDeps(manifest.peerDependencies);

    if (overrides) {
      ws.manifest.resolutions = convertOverridesToResolutions(overrides);
    } // if (needOverrideInternal) this.overrideInternalWorkspaceParams(ws);


    return ws;
  }
  /**
   * This is used to handle cases where in the capsules dirs we have the same component with different versions
   * The yarn ident is calculated by the manifest (package.json) name if exist
   * in our case for the same component with different versions we will get the same ident which will result errors later.
   * This is make sense in the original case of yarn workspace (it make sense you don't have 2 workspace with same name)
   * However in our case it doesn't make sense.
   * This function will make sure the ident will use the version as well
   * @param ws
   */


  overrideInternalWorkspaceParams(ws) {
    var _ws$manifest$name, _ws$manifest$name2;

    const ident = _core().structUtils.makeIdent(((_ws$manifest$name = ws.manifest.name) === null || _ws$manifest$name === void 0 ? void 0 : _ws$manifest$name.scope) || null, `${(_ws$manifest$name2 = ws.manifest.name) === null || _ws$manifest$name2 === void 0 ? void 0 : _ws$manifest$name2.name}-${ws.manifest.version}`);

    ws.manifest.name = ident; // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    ws.locator = _core().structUtils.makeLocator(ident, ws.reference); // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    ws.anchoredDescriptor = _core().structUtils.makeDescriptor(ws.locator, `${_core().WorkspaceResolver.protocol}${ws.relativeCwd}`); // @ts-expect-error: It's ok to initialize it now, even if it's readonly (setup is called right after construction)

    ws.anchoredLocator = _core().structUtils.makeLocator(ws.locator, `${_core().WorkspaceResolver.protocol}${ws.relativeCwd}`);
  }

  setupWorkspaces(project, workspaces) {
    project.workspaces = [];
    project.workspacesByCwd = new Map();
    project.workspacesByIdent = new Map();
    workspaces.forEach(workspace => {
      const dup = project.workspacesByIdent.get(workspace.locator.identHash);

      if (typeof dup !== `undefined`) {
        throw new Error(`Duplicate workspace name: ${workspace.cwd} conflicts with ${dup.cwd}`);
      }

      project.workspaces.push(workspace);
      project.workspacesByCwd.set(workspace.cwd, workspace);
      project.workspacesByIdent.set(workspace.locator.identHash, workspace);
    });
  }

  async getScopedRegistries(registries) {
    const scopedRegistries = Object.keys(registries.scopes).reduce((acc, scopeName) => {
      const regDef = registries.scopes[scopeName];
      const authProp = this.getAuthProp(regDef);
      acc[scopeName] = {
        npmRegistryServer: regDef.uri,
        npmAlwaysAuth: regDef.alwaysAuth
      };

      if (authProp) {
        acc[scopeName][authProp.keyName] = authProp.value;
      }

      return acc;
    }, {});
    return scopedRegistries;
  }

  getAuthProp(registry) {
    if (registry.token) {
      return {
        keyName: 'npmAuthToken',
        value: registry.token
      };
    }

    if (registry.baseToken) {
      return {
        keyName: 'npmAuthIdent',
        value: registry.baseToken
      };
    }

    return undefined;
  }

  getCacheFolder(baseDir = _userHome().default) {
    return `${baseDir}/.yarn/cache`;
  } // TODO: implement this to automate configuration.


  async computeConfiguration(rootDirPath, cacheFolder, options) {
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    const pluginConfig = (0, _cli().getPluginConfiguration)();
    let startingCwd;

    if (options.packageManagerConfigRootDir) {
      startingCwd = _fslib().npath.toPortablePath(options.packageManagerConfigRootDir);
    } else {
      startingCwd = rootDirPath;
    }

    const config = await _core().Configuration.find(startingCwd, pluginConfig);
    const scopedRegistries = await this.getScopedRegistries(registries);
    const defaultRegistry = registries.defaultRegistry;
    const defaultAuthProp = this.getAuthProp(defaultRegistry);
    const data = {
      nodeLinker: options.nodeLinker === 'isolated' ? 'pnpm' : 'node-modules',
      installStatePath: `${rootDirPath}/.yarn/install-state.gz`,
      cacheFolder,
      pnpDataPath: `${rootDirPath}/.pnp.meta.json`,
      npmScopes: scopedRegistries,
      virtualFolder: `${rootDirPath}/.yarn/__virtual__`,
      npmRegistryServer: defaultRegistry.uri || 'https://registry.yarnpkg.com',
      npmAlwaysAuth: defaultRegistry.alwaysAuth,
      httpProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpProxy,
      httpsProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpsProxy,
      enableStrictSsl: proxyConfig.strictSSL,
      // enableInlineBuilds: true,
      globalFolder: `${_userHome().default}/.yarn/global` // TODO: check about support for the following: (see more here - https://github.com/yarnpkg/berry/issues/1434#issuecomment-801449010)
      // ca?: string;
      // cert?: string;
      // key?: string;
      // noProxy?: boolean | string;

    };

    if (defaultAuthProp) {
      data[defaultAuthProp.keyName] = defaultAuthProp.value;
    } // TODO: node-modules is hardcoded now until adding support for pnp.


    config.use('<bit>', data, rootDirPath, {});
    return config;
  }

  computeComponents(componentManifests, componentsDirMap, copyPeer = false) {
    return componentsDirMap.toArray().reduce((acc, [component, dir]) => {
      const packageName = this.pkg.getPackageName(component);

      if (componentManifests.has(packageName)) {
        var _componentManifests$g;

        acc[dir] = (_componentManifests$g = componentManifests.get(packageName)) === null || _componentManifests$g === void 0 ? void 0 : _componentManifests$g.toJson({
          copyPeerToRuntime: copyPeer
        });
      }

      return acc;
    }, {});
  }

  computeDeps(rawDeps) {
    const map = new Map();
    if (!rawDeps) return map;
    Object.keys(rawDeps).forEach(packageName => {
      const ident = _core().structUtils.parseIdent(packageName);

      map.set(ident.identHash, _core().structUtils.makeDescriptor(ident, rawDeps[packageName]));
    });
    return map;
  }

  async resolveRemoteVersion(packageName, options) {
    var _versionSelectorType;

    const parsedPackage = (0, _parsePackageName().default)(packageName);
    const parsedVersion = parsedPackage.version;
    const versionType = parsedVersion && ((_versionSelectorType = (0, _versionSelectorType2().default)(parsedVersion)) === null || _versionSelectorType === void 0 ? void 0 : _versionSelectorType.type);

    if (versionType === 'version') {
      return {
        packageName: parsedPackage.name,
        version: parsedVersion,
        isSemver: true
      };
    }

    if (!_pluginNpm().default.resolvers) {
      throw new Error('npm resolvers for yarn API not found');
    } // eslint-disable-next-line @typescript-eslint/no-unused-vars


    const [_NpmRemapResolver, NpmSemverResolver, NpmTagResolver] = _pluginNpm().default.resolvers;

    let resolver = new NpmSemverResolver();

    const ident = _core().structUtils.parseIdent(parsedPackage.name);

    let range = 'npm:*';

    const rootDirPath = _fslib().npath.toPortablePath(options.rootDir);

    const cacheDir = this.getCacheFolder(options.cacheRootDir);
    const config = await this.computeConfiguration(rootDirPath, cacheDir, {
      packageManagerConfigRootDir: options.packageManagerConfigRootDir
    });
    const project = new (_core().Project)(rootDirPath, {
      configuration: config
    });
    const report = new (_core().LightReport)({
      configuration: config,
      stdout: process.stdout
    }); // Handle cases when the version is a dist tag like dev / latest for example bit install lodash@latest

    if (versionType === 'tag') {
      resolver = new NpmTagResolver();
      range = `npm:${parsedPackage.version}`;
    }

    const descriptor = _core().structUtils.makeDescriptor(ident, range); // @ts-ignore


    project.setupResolutions();
    const resolveOptions = {
      project,
      resolver,
      report
    }; // const candidates = await resolver.getCandidates(descriptor, new Map(), resolveOptions);

    const candidates = await resolver.getCandidates(descriptor, new Map(), resolveOptions);

    const parsedRange = _core().structUtils.parseRange(candidates[0].reference);

    const version = parsedRange.selector;
    return {
      packageName: parsedPackage.name,
      version,
      isSemver: true
    };
  }

}

exports.YarnPackageManager = YarnPackageManager;

function convertOverridesToResolutions(overrides) {
  const parsedOverrides = (0, _parseOverrides().default)(overrides);
  return parsedOverrides.map(override => ({
    pattern: {
      from: override.parentPkg ? toYarnResolutionSelector(override.parentPkg) : undefined,
      descriptor: toYarnResolutionSelector(override.targetPkg)
    },
    reference: override.newPref
  }));
}

function toYarnResolutionSelector({
  name,
  pref
}) {
  return {
    fullName: name,
    description: pref
  };
}

//# sourceMappingURL=yarn.package-manager.js.map