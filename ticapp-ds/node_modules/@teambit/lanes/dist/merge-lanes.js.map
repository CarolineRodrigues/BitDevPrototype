{"version":3,"sources":["merge-lanes.ts"],"names":["mergeLanes","merging","consumer","mergeStrategy","laneName","remoteName","noSnap","snapMessage","existingOnWorkspaceOnly","build","currentLaneId","getCurrentLaneId","name","BitError","localLaneId","localLane","isDefault","scope","loadLane","laneId","LaneId","bitIds","otherLane","remoteLane","otherLaneName","isDefaultLane","DEFAULT_LANE","bitMap","getAuthoredAndImportedBitIdsOfDefaultLane","filter","id","hasVersion","remoteLaneId","RemoteLaneId","from","objects","remoteLanes","getRemoteLane","length","getRemoteBitIds","components","map","c","changeVersion","head","toString","allComponentsStatus","getAllComponentsStatus","mergeSnaps","tmp","Tmp","componentsStatus","Promise","all","bitId","getComponentMergeStatus","clear","err"],"mappings":"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","sourcesContent":["import { BitError } from '@teambit/bit-error';\nimport { BitId } from '@teambit/legacy-bit-id';\nimport { DEFAULT_LANE } from '@teambit/legacy/dist/constants';\nimport { Consumer } from '@teambit/legacy/dist/consumer';\nimport { ApplyVersionResults, MergeStrategy } from '@teambit/legacy/dist/consumer/versions-ops/merge-version';\nimport LaneId, { RemoteLaneId } from '@teambit/legacy/dist/lane-id/lane-id';\nimport { Lane } from '@teambit/legacy/dist/scope/models';\nimport { Tmp } from '@teambit/legacy/dist/scope/repositories';\nimport { MergingMain } from '@teambit/merging';\n\nexport async function mergeLanes({\n  merging,\n  consumer,\n  mergeStrategy,\n  laneName,\n  remoteName,\n  noSnap,\n  snapMessage,\n  existingOnWorkspaceOnly,\n  build,\n}: {\n  merging: MergingMain;\n  consumer: Consumer;\n  mergeStrategy: MergeStrategy;\n  laneName: string;\n  remoteName: string | null;\n  noSnap: boolean;\n  snapMessage: string;\n  existingOnWorkspaceOnly: boolean;\n  build: boolean;\n}): Promise<ApplyVersionResults> {\n  const currentLaneId = consumer.getCurrentLaneId();\n  if (!remoteName && laneName === currentLaneId.name) {\n    throw new BitError(`unable to switch to lane \"${laneName}\", you're already checked out to this lane`);\n  }\n  const localLaneId = consumer.getCurrentLaneId();\n  const localLane = currentLaneId.isDefault() ? null : await consumer.scope.loadLane(localLaneId);\n  const laneId = new LaneId({ name: laneName });\n  let bitIds: BitId[];\n  let otherLane: Lane | null;\n  let remoteLane;\n  let otherLaneName: string;\n  const isDefaultLane = laneName === DEFAULT_LANE;\n\n  if (isDefaultLane) {\n    bitIds = consumer.bitMap.getAuthoredAndImportedBitIdsOfDefaultLane().filter((id) => id.hasVersion());\n    otherLaneName = DEFAULT_LANE;\n  } else if (remoteName) {\n    const remoteLaneId = RemoteLaneId.from(laneId.name, remoteName);\n    remoteLane = await consumer.scope.objects.remoteLanes.getRemoteLane(remoteLaneId);\n    if (!remoteLane.length) {\n      throw new BitError(\n        `unable to switch to \"${laneName}\" of \"${remoteName}\", the remote lane was not found or not fetched locally`\n      );\n    }\n    bitIds = await consumer.scope.objects.remoteLanes.getRemoteBitIds(remoteLaneId);\n    otherLaneName = `${remoteName}/${laneId.name}`;\n  } else {\n    otherLane = await consumer.scope.loadLane(laneId);\n    if (!otherLane) throw new BitError(`unable to switch to \"${laneName}\", the lane was not found`);\n    bitIds = otherLane.components.map((c) => c.id.changeVersion(c.head.toString()));\n    otherLaneName = laneId.name;\n  }\n  const allComponentsStatus = await getAllComponentsStatus();\n\n  return merging.mergeSnaps({\n    mergeStrategy,\n    allComponentsStatus,\n    remoteName,\n    laneId,\n    localLane,\n    noSnap,\n    snapMessage,\n    build,\n  });\n\n  async function getAllComponentsStatus() {\n    const tmp = new Tmp(consumer.scope);\n    try {\n      const componentsStatus = await Promise.all(\n        bitIds.map((bitId) => merging.getComponentMergeStatus(bitId, localLane, otherLaneName, existingOnWorkspaceOnly))\n      );\n      await tmp.clear();\n      return componentsStatus;\n    } catch (err: any) {\n      await tmp.clear();\n      throw err;\n    }\n  }\n}\n"]}