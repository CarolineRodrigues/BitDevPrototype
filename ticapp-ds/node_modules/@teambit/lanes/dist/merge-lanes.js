"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeLanes = mergeLanes;

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = _interopRequireWildcard(require("@teambit/legacy/dist/lane-id/lane-id"));

  _laneId = function () {
    return data;
  };

  return data;
}

function _repositories() {
  const data = require("@teambit/legacy/dist/scope/repositories");

  _repositories = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function mergeLanes({
  merging,
  consumer,
  mergeStrategy,
  laneName,
  remoteName,
  noSnap,
  snapMessage,
  existingOnWorkspaceOnly,
  build
}) {
  const currentLaneId = consumer.getCurrentLaneId();

  if (!remoteName && laneName === currentLaneId.name) {
    throw new (_bitError().BitError)(`unable to switch to lane "${laneName}", you're already checked out to this lane`);
  }

  const localLaneId = consumer.getCurrentLaneId();
  const localLane = currentLaneId.isDefault() ? null : await consumer.scope.loadLane(localLaneId);
  const laneId = new (_laneId().default)({
    name: laneName
  });
  let bitIds;
  let otherLane;
  let remoteLane;
  let otherLaneName;

  const isDefaultLane = laneName === _constants().DEFAULT_LANE;

  if (isDefaultLane) {
    bitIds = consumer.bitMap.getAuthoredAndImportedBitIdsOfDefaultLane().filter(id => id.hasVersion());
    otherLaneName = _constants().DEFAULT_LANE;
  } else if (remoteName) {
    const remoteLaneId = _laneId().RemoteLaneId.from(laneId.name, remoteName);

    remoteLane = await consumer.scope.objects.remoteLanes.getRemoteLane(remoteLaneId);

    if (!remoteLane.length) {
      throw new (_bitError().BitError)(`unable to switch to "${laneName}" of "${remoteName}", the remote lane was not found or not fetched locally`);
    }

    bitIds = await consumer.scope.objects.remoteLanes.getRemoteBitIds(remoteLaneId);
    otherLaneName = `${remoteName}/${laneId.name}`;
  } else {
    otherLane = await consumer.scope.loadLane(laneId);
    if (!otherLane) throw new (_bitError().BitError)(`unable to switch to "${laneName}", the lane was not found`);
    bitIds = otherLane.components.map(c => c.id.changeVersion(c.head.toString()));
    otherLaneName = laneId.name;
  }

  const allComponentsStatus = await getAllComponentsStatus();
  return merging.mergeSnaps({
    mergeStrategy,
    allComponentsStatus,
    remoteName,
    laneId,
    localLane,
    noSnap,
    snapMessage,
    build
  });

  async function getAllComponentsStatus() {
    const tmp = new (_repositories().Tmp)(consumer.scope);

    try {
      const componentsStatus = await Promise.all(bitIds.map(bitId => merging.getComponentMergeStatus(bitId, localLane, otherLaneName, existingOnWorkspaceOnly)));
      await tmp.clear();
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }
}

//# sourceMappingURL=merge-lanes.js.map