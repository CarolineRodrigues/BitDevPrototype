"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LaneTrackCmd = exports.LaneShowCmd = exports.LaneRemoveCmd = exports.LaneMergeCmd = exports.LaneListCmd = exports.LaneCreateCmd = exports.LaneCmd = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _yn() {
  const data = _interopRequireDefault(require("yn"));

  _yn = function () {
    return data;
  };

  return data;
}

function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");

  _mergeVersion = function () {
    return data;
  };

  return data;
}

function _merging() {
  const data = require("@teambit/merging");

  _merging = function () {
    return data;
  };

  return data;
}

function _featureToggle() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/feature-toggle");

  _featureToggle = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _prompts() {
  const data = require("@teambit/legacy/dist/prompts");

  _prompts = function () {
    return data;
  };

  return data;
}

// eslint-disable-next-line max-classes-per-file
class LaneListCmd {
  constructor(lanes, workspace, scope) {
    this.lanes = lanes;
    this.workspace = workspace;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'list');
    (0, _defineProperty2().default)(this, "description", `list lanes`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['d', 'details', 'show more details on the state of each component in each lane'], ['j', 'json', 'show lanes details in json format'], ['r', 'remote <string>', 'show remote lanes'], ['', 'merged', 'show merged lanes'], ['', 'not-merged', 'show not merged lanes']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
  }

  async report(args, laneOptions) {
    const {
      details,
      remote,
      merged,
      notMerged
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      remote,
      merged,
      notMerged,
      showDefaultLane: true
    });

    if (merged) {
      const mergedLanes = lanes.filter(l => l.isMerged);
      if (!mergedLanes.length) return _chalk().default.green('None of the lanes is merged');
      return _chalk().default.green(mergedLanes.map(m => m.name).join('\n'));
    }

    if (notMerged) {
      const unmergedLanes = lanes.filter(l => !l.isMerged);
      if (!unmergedLanes.length) return _chalk().default.green('All lanes are merged');
      return _chalk().default.green(unmergedLanes.map(m => m.name).join('\n'));
    }

    const currentLane = this.lanes.getCurrentLane();
    let currentLaneStr = currentLane ? `current lane - ${_chalk().default.bold(currentLane)}` : '';

    if (details) {
      const laneDataOfCurrentLane = lanes.find(l => l.name === currentLane);
      const remoteOfCurrentLane = laneDataOfCurrentLane ? laneDataOfCurrentLane.remote : null;
      const currentLaneComponents = laneDataOfCurrentLane ? outputComponents(laneDataOfCurrentLane.components) : '';

      if (currentLaneStr) {
        currentLaneStr += `${outputRemoteLane(remoteOfCurrentLane)}\n${currentLaneComponents}`;
      }
    }

    const availableLanes = lanes.filter(l => l.name !== currentLane) // @ts-ignore
    .map(laneData => {
      if (details) {
        const laneTitle = `> ${_chalk().default.green(laneData.name)}${outputRemoteLane(laneData.remote)}\n`;
        const components = outputComponents(laneData.components);
        return laneTitle + components;
      }

      return `    > ${_chalk().default.green(laneData.name)} (${laneData.components.length} components)`;
    }).join('\n');

    const outputFooter = () => {
      let footer = '\n';

      if (details) {
        footer += 'You can use --merged and --not-merged to see which of the lanes is fully merged.';
      } else {
        footer += "to get more info on all lanes in workspace use 'bit lane list --details' or 'bit lane show <lane-name>' for a specific lane.";
      }

      if (!remote && this.workspace) footer += `\nswitch lanes using 'bit switch <name>'.`;
      return footer;
    };

    return outputCurrentLane() + outputAvailableLanes() + outputFooter();

    function outputCurrentLane() {
      return currentLaneStr ? `${currentLaneStr}\n` : '';
    }

    function outputAvailableLanes() {
      if (!availableLanes) return '';
      return remote ? `${availableLanes}\n` : `\nAvailable lanes:\n${availableLanes}\n`;
    }
  }

  async json(args, laneOptions) {
    const {
      remote,
      merged = false,
      notMerged = false
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      remote,
      showDefaultLane: true,
      merged,
      notMerged
    });
    const currentLane = this.lanes.getCurrentLane();
    return {
      lanes,
      currentLane
    };
  }

}

exports.LaneListCmd = LaneListCmd;

class LaneShowCmd {
  constructor(lanes, workspace, scope) {
    this.lanes = lanes;
    this.workspace = workspace;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'show <name>');
    (0, _defineProperty2().default)(this, "description", `show lane details`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['j', 'json', 'show the lane details in json format'], ['r', 'remote <string>', 'show remote lanes']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
  }

  async report([name], laneOptions) {
    const {
      remote
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      name,
      remote
    });
    const onlyLane = lanes[0];
    const title = `showing information for ${_chalk().default.bold(name)}${outputRemoteLane(onlyLane.remote)}\n`;
    return title + outputComponents(onlyLane.components);
  }

  async json([name], laneOptions) {
    const {
      remote
    } = laneOptions;
    const lanes = await this.lanes.getLanes({
      name,
      remote
    });
    return lanes[0];
  }

}

exports.LaneShowCmd = LaneShowCmd;

class LaneCreateCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'create <name>');
    (0, _defineProperty2().default)(this, "description", `create and switch to a new lane`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'remote-scope <string>', 'remote scope where this lane will be exported to (can be changed later with "bit lane track")'], ['', 'remote-name <string>', 'lane name on the remote, default to the local name (can be changed later with "bit lane track")']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }

  async report([name], createLaneOptions) {
    const result = await this.lanes.createLane(name, createLaneOptions);
    const remoteScopeOrDefaultScope = createLaneOptions.remoteScope ? `the remote scope ${_chalk().default.bold(createLaneOptions.remoteScope)}` : `the default-scope ${_chalk().default.bold(result.remoteScope)}. to change it, please run "bit lane track" command`;

    const title = _chalk().default.green(`successfully added and checked out to a new lane ${_chalk().default.bold(result.localLane)}`);

    const remoteScopeOutput = `this lane will be exported to ${remoteScopeOrDefaultScope}`;
    return `${title}\n${remoteScopeOutput}`;
  }

}

exports.LaneCreateCmd = LaneCreateCmd;

class LaneTrackCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'track <local-name> <remote-scope> [remote-name]');
    (0, _defineProperty2().default)(this, "description", `change the remote scope or remote lane of the local lane`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }

  async report([localName, remoteScope, remoteName]) {
    const {
      beforeTrackData,
      afterTrackData
    } = await this.lanes.trackLane(localName, remoteScope, remoteName);
    const remoteScopeChanges = afterTrackData.remoteScope === (beforeTrackData === null || beforeTrackData === void 0 ? void 0 : beforeTrackData.remoteScope) ? `the remote-scope has not been changed` : `the remote-scope has been changed from ${_chalk().default.bold((beforeTrackData === null || beforeTrackData === void 0 ? void 0 : beforeTrackData.remoteScope) || '<n/a>')} to ${_chalk().default.bold(afterTrackData.remoteScope)}`;
    const remoteNameChanges = afterTrackData.remoteLane === (beforeTrackData === null || beforeTrackData === void 0 ? void 0 : beforeTrackData.remoteLane) ? `the remote-name has not been changed` : `the remote-name has been changed from ${_chalk().default.bold((beforeTrackData === null || beforeTrackData === void 0 ? void 0 : beforeTrackData.remoteLane) || '<n/a>')} to ${_chalk().default.bold(afterTrackData.remoteLane)}`;
    return `${remoteScopeChanges}\n${remoteNameChanges}`;
  }

}

exports.LaneTrackCmd = LaneTrackCmd;

class LaneMergeCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'merge <lane>');
    (0, _defineProperty2().default)(this, "description", `merge a local or a remote lane`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['', 'remote <name>', 'remote scope name'], ['', 'ours', 'in case of a conflict, override the used version with the current modification'], ['', 'theirs', 'in case of a conflict, override the current modification with the specified version'], ['', 'manual', 'in case of a conflict, leave the files with a conflict state to resolve them manually later'], ['', 'existing', 'checkout only components in a lane that exist in the workspace'], ['', 'no-snap', 'do not auto snap in case the merge completed without conflicts'], ['', 'build', 'in case of snap during the merge, run the build-pipeline (similar to bit snap --build)'], ['m', 'message <message>', 'override the default message for the auto snap']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }

  async report([name], {
    ours = false,
    theirs = false,
    manual = false,
    remote: remoteName,
    build,
    existing: existingOnWorkspaceOnly = false,
    noSnap = false,
    message: snapMessage = ''
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;
    const mergeStrategy = (0, _mergeVersion().getMergeStrategy)(ours, theirs, manual);
    if (noSnap && snapMessage) throw new (_bitError().BitError)('unable to use "noSnap" and "message" flags together');
    const results = await this.lanes.mergeLane(name, {
      // @ts-ignore
      remoteName,
      build,
      // @ts-ignore
      mergeStrategy,
      existingOnWorkspaceOnly,
      noSnap,
      snapMessage
    });
    return (0, _merging().mergeReport)(results);
  }

}

exports.LaneMergeCmd = LaneMergeCmd;

class LaneRemoveCmd {
  constructor(lanes) {
    this.lanes = lanes;
    (0, _defineProperty2().default)(this, "name", 'remove <lane...>');
    (0, _defineProperty2().default)(this, "description", `remove lanes`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['r', 'remote', 'remove a remote lane (in the lane arg, use remote/lane-id syntax)'], ['f', 'force', 'removes the component from the scope, even if used as a dependency. WARNING: components that depend on this component will corrupt'], ['s', 'silent', 'skip confirmation']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }

  async report([names], {
    remote = false,
    force = false,
    silent = false
  }) {
    if (!silent) {
      const removePromptResult = await (0, _prompts().removePrompt)(); // @ts-ignore

      if (!(0, _yn().default)(removePromptResult.shouldRemove)) {
        throw new (_bitError().BitError)('the operation has been canceled');
      }
    }

    const laneResults = await this.lanes.removeLanes(names, {
      remote,
      force
    });
    return _chalk().default.green(`successfully removed the following lane(s): ${_chalk().default.bold(laneResults.join(', '))}`);
  }

}

exports.LaneRemoveCmd = LaneRemoveCmd;

class LaneCmd {
  constructor(lanes, workspace, scope, docsDomain) {
    this.lanes = lanes;
    this.workspace = workspace;
    this.scope = scope;
    (0, _defineProperty2().default)(this, "name", 'lane [name]');
    (0, _defineProperty2().default)(this, "shortDescription", 'show lanes details');
    (0, _defineProperty2().default)(this, "description", void 0);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "options", [['d', 'details', 'show more details on the state of each component in each lane'], ['j', 'json', 'show lanes details in json format'], ['r', 'remote <string>', 'show remote lanes'], ['', 'merged', 'show merged lanes'], ['', 'not-merged', 'show not merged lanes']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
    (0, _defineProperty2().default)(this, "commands", []);
    this.description = `show lanes details
https://${docsDomain}/components/lanes`;
  }

  async report([name], laneOptions) {
    return new LaneListCmd(this.lanes, this.workspace, this.scope).report([name], laneOptions);
  }

}

exports.LaneCmd = LaneCmd;

function outputComponents(components) {
  const componentsTitle = `\tcomponents (${components.length})\n`;
  const componentsStr = components.map(c => `\t  ${c.id.toString()} - ${c.head}`).join('\n');
  return componentsTitle + componentsStr;
}

function outputRemoteLane(remoteLane) {
  if (!remoteLane) return '';
  return ` - (remote lane - ${remoteLane})`;
}

//# sourceMappingURL=lane.cmd.js.map