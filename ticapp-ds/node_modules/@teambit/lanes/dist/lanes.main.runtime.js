"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.LanesMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("@teambit/scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _graphql() {
  const data = require("@teambit/graphql");

  _graphql = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = require("@teambit/workspace");

  _workspace = function () {
    return data;
  };

  return data;
}

function _getRemoteByName() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/remotes/get-remote-by-name"));

  _getRemoteByName = function () {
    return data;
  };

  return data;
}

function _lanesModules() {
  const data = require("@teambit/lanes.modules.diff");

  _lanesModules = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/lane-id/lane-id"));

  _laneId = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _createLane() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/lanes/create-lane"));

  _createLane = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _community() {
  const data = require("@teambit/community");

  _community = function () {
    return data;
  };

  return data;
}

function _removeLanes() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/lanes/remove-lanes"));

  _removeLanes = function () {
    return data;
  };

  return data;
}

function _merging() {
  const data = require("@teambit/merging");

  _merging = function () {
    return data;
  };

  return data;
}

function _lanes() {
  const data = require("./lanes.aspect");

  _lanes = function () {
    return data;
  };

  return data;
}

function _lane() {
  const data = require("./lane.cmd");

  _lane = function () {
    return data;
  };

  return data;
}

function _lanes2() {
  const data = require("./lanes.graphql");

  _lanes2 = function () {
    return data;
  };

  return data;
}

function _switch() {
  const data = require("./switch.cmd");

  _switch = function () {
    return data;
  };

  return data;
}

function _mergeLanes() {
  const data = require("./merge-lanes");

  _mergeLanes = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

class LanesMain {
  constructor(workspace, scope, merging) {
    this.workspace = workspace;
    this.scope = scope;
    this.merging = merging;
  }

  async getLanes({
    name,
    remote,
    merged,
    showDefaultLane,
    notMerged
  }) {
    var _this$workspace;

    const showMergeData = Boolean(merged || notMerged);
    const consumer = (_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.consumer;

    if (remote) {
      const remoteObj = await (0, _getRemoteByName().default)(remote, consumer);
      const lanes = await remoteObj.listLanes(name, showMergeData);
      return lanes;
    }

    const lanes = await this.scope.legacyScope.lanes.getLanesData(this.scope.legacyScope, name, showMergeData);

    if (showDefaultLane) {
      const defaultLane = this.getLaneDataOfDefaultLane();
      if (defaultLane) lanes.push(defaultLane);
    }

    return lanes;
  }

  getCurrentLane() {
    var _this$workspace2;

    if (!((_this$workspace2 = this.workspace) !== null && _this$workspace2 !== void 0 && _this$workspace2.consumer)) return null;
    return this.scope.legacyScope.lanes.getCurrentLaneName();
  }

  async createLane(name, {
    remoteScope,
    remoteName
  } = {}) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to create a lane outside of Bit workspace`);
    }

    await (0, _createLane().default)(this.workspace.consumer, name);
    this.scope.legacyScope.lanes.setCurrentLane(name);
    const trackLaneData = {
      localLane: name,
      remoteLane: remoteName || name,
      remoteScope: remoteScope || this.workspace.defaultScope
    };
    this.scope.legacyScope.lanes.trackLane(trackLaneData);
    await this.workspace.consumer.onDestroy();
    return trackLaneData;
  }

  async trackLane(localName, remoteScope, remoteName) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to track a lane outside of Bit workspace`);
    }

    const lane = await this.scope.legacyScope.lanes.loadLane(_laneId().default.from(localName));

    if (!lane) {
      throw new (_bitError().BitError)(`unable to find a local lane "${localName}"`);
    }

    const beforeTrackData = this.scope.legacyScope.lanes.getRemoteTrackedDataByLocalLane(localName);
    const beforeTrackDataCloned = beforeTrackData ? _objectSpread({}, beforeTrackData) : undefined;
    const afterTrackData = {
      localLane: localName,
      remoteLane: remoteName || (beforeTrackData === null || beforeTrackData === void 0 ? void 0 : beforeTrackData.remoteLane) || localName,
      remoteScope
    };
    this.scope.legacyScope.lanes.trackLane(afterTrackData);
    await this.workspace.consumer.onDestroy();
    return {
      beforeTrackData: beforeTrackDataCloned,
      afterTrackData
    };
  }

  async removeLanes(laneNames, {
    remote,
    force
  }) {
    var _this$workspace3;

    const results = await (0, _removeLanes().default)((_this$workspace3 = this.workspace) === null || _this$workspace3 === void 0 ? void 0 : _this$workspace3.consumer, laneNames, remote, force);
    if (this.workspace) await this.workspace.consumer.onDestroy();
    return results.laneResults;
  }

  async mergeLane(laneName, options) {
    if (!this.workspace) {
      throw new (_bitError().BitError)(`unable to merge a lane outside of Bit workspace`);
    }

    const mergeResults = await (0, _mergeLanes().mergeLanes)(_objectSpread({
      merging: this.merging,
      consumer: this.workspace.consumer,
      laneName
    }, options));
    await this.workspace.consumer.onDestroy();
    return mergeResults;
  }
  /**
   * the values array may include zero to two values and will be processed as following:
   * [] => diff between the current lane and default lane. (only inside workspace).
   * [to] => diff between the current lane (or default-lane when in scope) and "to" lane.
   * [from, to] => diff between "from" lane and "to" lane.
   */


  getDiff(values, diffOptions = {}) {
    const laneDiffGenerator = new (_lanesModules().LaneDiffGenerator)(this.workspace, this.scope);
    return laneDiffGenerator.generate(values, diffOptions);
  }

  getLaneDataOfDefaultLane() {
    var _this$workspace4;

    const consumer = (_this$workspace4 = this.workspace) === null || _this$workspace4 === void 0 ? void 0 : _this$workspace4.consumer;
    if (!consumer) return null;
    const bitIds = consumer.bitMap.getAuthoredAndImportedBitIdsOfDefaultLane();
    return {
      name: _constants().DEFAULT_LANE,
      remote: null,
      components: bitIds.map(bitId => ({
        id: bitId,
        head: bitId.version
      })),
      isMerged: null
    };
  }

  static async provider([cli, scope, workspace, graphql, community, merging]) {
    const lanesMain = new LanesMain(workspace, scope, merging);
    const isLegacy = workspace && workspace.consumer.isLegacy;
    const switchCmd = new (_switch().SwitchCmd)();

    if (!isLegacy) {
      const laneCmd = new (_lane().LaneCmd)(lanesMain, workspace, scope, community.getDocsDomain());
      laneCmd.commands = [new (_lane().LaneListCmd)(lanesMain, workspace, scope), switchCmd, new (_lane().LaneShowCmd)(lanesMain, workspace, scope), new (_lane().LaneCreateCmd)(lanesMain), new (_lane().LaneMergeCmd)(lanesMain), new (_lane().LaneRemoveCmd)(lanesMain), new (_lane().LaneTrackCmd)(lanesMain), new (_lanesModules().LaneDiffCmd)(workspace, scope)];
      cli.register(laneCmd, switchCmd);
      graphql.register((0, _lanes2().lanesSchema)(lanesMain));
    }

    return lanesMain;
  }

}

exports.LanesMain = LanesMain;
(0, _defineProperty2().default)(LanesMain, "slots", []);
(0, _defineProperty2().default)(LanesMain, "dependencies", [_cli().CLIAspect, _scope().ScopeAspect, _workspace().WorkspaceAspect, _graphql().GraphqlAspect, _community().CommunityAspect, _merging().MergingAspect]);
(0, _defineProperty2().default)(LanesMain, "runtime", _cli().MainRuntime);

_lanes().LanesAspect.addRuntime(LanesMain);

var _default = LanesMain;
exports.default = _default;

//# sourceMappingURL=lanes.main.runtime.js.map