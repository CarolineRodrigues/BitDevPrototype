{"version":3,"sources":["tester.ts"],"names":["Tests","constructor","components","errors","map","comp","flat"],"mappings":";;;;;;;;;;;AAKO,MAAMA,KAAN,CAAY;AACjBC,EAAAA,WAAW,CAAQC,UAAR,EAAyC;AAAA,SAAjCA,UAAiC,GAAjCA,UAAiC;AAAE;;AAC5C,MAANC,MAAM,GAAY;AACpB,WAAO,KAAKD,UAAL,CAAgBE,GAAhB,CAAqBC,IAAD,IAAUA,IAAI,CAACF,MAAL,IAAe,EAA7C,EAAiDG,IAAjD,EAAP;AACD;;AAJgB","sourcesContent":["import { Component, ComponentID, ComponentMap } from '@teambit/component';\nimport { ExecutionContext } from '@teambit/envs';\nimport { AbstractVinyl } from '@teambit/legacy/dist/consumer/component/sources';\nimport { TestsResult } from '@teambit/tests-results';\n\nexport class Tests {\n  constructor(public components: ComponentsResults[]) {}\n  get errors(): Error[] {\n    return this.components.map((comp) => comp.errors || []).flat();\n  }\n}\n\nexport type ComponentsResults = {\n  /**\n   * component id.\n   */\n  componentId: ComponentID;\n  /**\n   * test results for the component.\n   */\n  results?: TestsResult;\n  /**\n   * aggregated errors from all files\n   */\n  errors?: Error[];\n\n  /**\n   * loading.\n   */\n  loading?: boolean;\n};\n\nexport type SpecFiles = ComponentMap<AbstractVinyl[]>;\nexport type ComponentPatternsMap = ComponentMap<{ path: string; relative: string }[]>;\n\nexport interface TesterContext extends ExecutionContext {\n  /**\n   * whether the tester run for release (during bit build/tag) or not (during bit test command).\n   */\n  release: boolean;\n\n  /**\n   * list of components to test.\n   */\n  components: Component[];\n\n  /**\n   * component workspace.\n   */\n  // workspace: Workspace;\n\n  /**\n   * defines whether tester is expected to run in quiet mode.\n   */\n  quiet?: boolean;\n\n  /**\n   * list of spec files to test.\n   */\n  specFiles: SpecFiles;\n\n  /**\n   * rootPath of the component workspace or the capsule root dir (during build).\n   */\n  rootPath: string;\n\n  /**\n   * determines whether tester is expected to run in debug mode.\n   */\n  debug?: boolean;\n\n  /**\n   * is start from ui\n   */\n  ui?: boolean;\n\n  /**\n   * determines whether to start the tester in watch mode.\n   */\n  watch?: boolean;\n\n  /**\n   * whether the tester should show code coverage\n   */\n  coverage?: boolean;\n\n  /**\n   * array of patterns to test.\n   */\n  patterns: ComponentPatternsMap;\n}\n\n/**\n * tester interface allows extensions to implement a component tester into bit.\n */\nexport interface Tester {\n  /**\n   * display name of the tester.\n   */\n  displayName?: string;\n\n  /**\n   * icon of the tester.\n   */\n  icon?: string;\n\n  /**\n   * serialized config of the tester.\n   */\n  displayConfig?(): string;\n\n  /**\n   * path to the config in the filesystem.\n   */\n  configPath?: string;\n\n  /**\n   * id of the tester.\n   */\n  id: string;\n\n  /**\n   * on test run complete. (applies only during watch)\n   * @param callback\n   */\n  onTestRunComplete?(callback: CallbackFn): Promise<void>;\n\n  /**\n   * execute tests on all components in the given execution context.\n   */\n  test(context: TesterContext): Promise<Tests>;\n\n  /**\n   * watch tests on all components\n   */\n  watch?(context: TesterContext): Promise<Tests>;\n  /**\n   * return the tester version.\n   */\n  version(): string;\n}\nexport type CallbackFn = (testSuite: Tests) => void;\n"]}