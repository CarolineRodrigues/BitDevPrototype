"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkspaceGenerator = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _isbinaryfile() {
  const data = require("isbinaryfile");

  _isbinaryfile = function () {
    return data;
  };

  return data;
}

function _bit() {
  const data = require("@teambit/bit");

  _bit = function () {
    return data;
  };

  return data;
}

function _execa() {
  const data = _interopRequireDefault(require("execa"));

  _execa = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _ui() {
  const data = _interopRequireDefault(require("@teambit/ui"));

  _ui = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = require("@teambit/workspace");

  _workspace = function () {
    return data;
  };

  return data;
}

function _pkg() {
  const data = require("@teambit/pkg");

  _pkg = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("@teambit/legacy/dist/api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _compiler() {
  const data = require("@teambit/compiler");

  _compiler = function () {
    return data;
  };

  return data;
}

function _gitExecutable() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/git/git-executable"));

  _gitExecutable = function () {
    return data;
  };

  return data;
}

function _gitNotFound() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/git/exceptions/git-not-found"));

  _gitNotFound = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _componentId() {
  const data = require("@teambit/component-id");

  _componentId = function () {
    return data;
  };

  return data;
}

function _generator() {
  const data = require("./generator.aspect");

  _generator = function () {
    return data;
  };

  return data;
}

class WorkspaceGenerator {
  constructor(workspaceName, options, template, aspectComponent) {
    this.workspaceName = workspaceName;
    this.options = options;
    this.template = template;
    this.aspectComponent = aspectComponent;
    (0, _defineProperty2().default)(this, "workspacePath", void 0);
    (0, _defineProperty2().default)(this, "harmony", void 0);
    (0, _defineProperty2().default)(this, "workspace", void 0);
    (0, _defineProperty2().default)(this, "logger", void 0);
    this.workspacePath = _path().default.resolve(this.workspaceName);
  }

  async generate() {
    if (_fsExtra().default.existsSync(this.workspacePath)) {
      throw new Error(`unable to create a workspace at "${this.workspaceName}", this path already exist`);
    }

    await _fsExtra().default.ensureDir(this.workspacePath);

    try {
      process.chdir(this.workspacePath);
      await this.initGit();
      await (0, _consumer().init)(this.workspacePath, this.options.skipGit, false, false, false, false, {});
      await this.writeWorkspaceFiles();
      await this.reloadBitInWorkspaceDir();
      await this.addComponentsFromRemote();
      await this.workspace.install(undefined, {
        dedupe: true,
        import: false,
        copyPeerToRuntimeOnRoot: true,
        copyPeerToRuntimeOnComponents: false,
        updateExisting: false
      }); // await this.buildUI(); // disabled for now. it takes too long
    } catch (err) {
      await _fsExtra().default.remove(this.workspacePath);
      throw err;
    }

    return this.workspacePath;
  }

  async initGit() {
    if (this.options.skipGit) return;
    const gitExecutablePath = (0, _gitExecutable().default)();
    const params = ['init'];

    try {
      await (0, _execa().default)(gitExecutablePath, params);
    } catch (err) {
      if (err.exitCodeName === 'ENOENT') {
        throw new (_gitNotFound().default)(gitExecutablePath, err);
      }

      throw err;
    }
  }

  async buildUI() {
    const uiMain = this.harmony.get(_ui().default.id);
    await uiMain.createRuntime({});
  }
  /**
   * writes the generated template files to the default directory set in the workspace config
   */


  async writeWorkspaceFiles() {
    const workspaceContext = {
      name: this.workspaceName,
      defaultScope: this.options.defaultScope,
      empty: this.options.empty,
      aspectComponent: this.aspectComponent
    };
    const templateFiles = await this.template.generateFiles(workspaceContext);
    await Promise.all(templateFiles.map(async templateFile => {
      await _fsExtra().default.outputFile(_path().default.join(this.workspacePath, templateFile.relativePath), templateFile.content);
    }));
  }

  async reloadBitInWorkspaceDir() {
    this.harmony = await (0, _bit().loadBit)(this.workspacePath);
    this.workspace = this.harmony.get(_workspace().WorkspaceAspect.id);
    const loggerMain = this.harmony.get(_logger().LoggerAspect.id);
    this.logger = loggerMain.createLogger(_generator().GeneratorAspect.id);
  }

  async addComponentsFromRemote() {
    var _this$template, _this$template$import;

    if (this.options.empty) return;
    const componentsToImport = (_this$template = this.template) === null || _this$template === void 0 ? void 0 : (_this$template$import = _this$template.importComponents) === null || _this$template$import === void 0 ? void 0 : _this$template$import.call(_this$template);
    if (!componentsToImport || !componentsToImport.length) return;
    const dependencyResolver = this.harmony.get(_dependencyResolver().DependencyResolverAspect.id);
    const componentsToImportResolved = await Promise.all(componentsToImport.map(async c => ({
      id: _componentId().ComponentID.fromLegacy(_legacyBitId().BitId.parse(c.id, true)),
      path: c.path,
      targetName: c.targetName
    })));
    const componentIds = componentsToImportResolved.map(c => c.id); // @todo: improve performance by changing `getRemoteComponent` api to accept multiple ids

    const components = await Promise.all(componentIds.map(id => this.workspace.scope.getRemoteComponent(id)));
    const oldAndNewPackageNames = this.getNewPackageNames(components, componentsToImportResolved);
    const oldAndNewComponentIds = this.getNewComponentIds(components, componentsToImportResolved);
    await Promise.all(components.map(comp => this.replaceOriginalPackageNameWithNew(comp, oldAndNewPackageNames, oldAndNewComponentIds)));
    await (0, _pMapSeries().default)(components, async comp => {
      const compData = componentsToImportResolved.find(c => c.id._legacy.isEqualWithoutVersion(comp.id._legacy));
      if (!compData) throw new Error(`workspace-generator, unable to find ${comp.id.toString()} in the given ids`);
      await this.workspace.write(compData.path, comp);
      await this.workspace.track({
        rootDir: compData.path,
        componentName: compData.targetName || compData.id.fullName,
        mainFile: comp.state._consumer.mainFile
      });
      const deps = await dependencyResolver.getDependencies(comp);
      const currentPackages = Object.keys(oldAndNewPackageNames); // only bring auto-resolved dependencies, others should be set in the workspace.jsonc template

      const workspacePolicyEntries = deps.filter(dep => dep.source === 'auto').map(dep => {
        var _dep$getPackageName;

        return {
          dependencyId: ((_dep$getPackageName = dep.getPackageName) === null || _dep$getPackageName === void 0 ? void 0 : _dep$getPackageName.call(dep)) || dep.id,
          lifecycleType: dep.lifecycle === 'dev' ? 'runtime' : dep.lifecycle,
          value: {
            version: dep.version
          }
        };
      }).filter(entry => !currentPackages.includes(entry.dependencyId)); // remove components that are now imported

      dependencyResolver.addToRootPolicy(workspacePolicyEntries, {
        updateExisting: true
      });
    });
    await this.workspace.bitMap.write();
    await dependencyResolver.persistConfig(this.workspace.path);
    this.workspace.clearCache();
    await this.compileComponents();
  }

  async compileComponents() {
    const compiler = this.harmony.get(_compiler().CompilerAspect.id);
    await compiler.compileOnWorkspace();
  }

  getNewPackageNames(components, compsData) {
    const pkg = this.harmony.get(_pkg().PkgAspect.id);
    const packageToReplace = {};
    const scopeToReplace = this.workspace.defaultScope.replace('.', '/');
    components.forEach(comp => {
      const newId = this.resolveNewCompId(comp, compsData);
      const currentPackageName = pkg.getPackageName(comp);
      const newName = newId.fullName.replace(/\//g, '.');
      const newPackageName = `@${scopeToReplace}.${newName}`;
      packageToReplace[currentPackageName] = newPackageName;
    });
    return packageToReplace;
  }

  getNewComponentIds(components, compsData) {
    const componentToReplace = {};
    components.forEach(comp => {
      const newId = this.resolveNewCompId(comp, compsData);
      componentToReplace[comp.id.toStringWithoutVersion()] = newId.toStringWithoutVersion();
    });
    return componentToReplace;
  }

  resolveNewCompId(comp, compsData) {
    const scopeToReplace = this.workspace.defaultScope;
    const compData = compsData.find(c => c.id._legacy.isEqualWithoutScopeAndVersion(comp.id._legacy));

    if (!compData) {
      throw new Error(`workspace-generator: unable to find data for "${comp.id._legacy.toString()}"`);
    }

    return compData.targetName ? _componentId().ComponentID.fromLegacy(_legacyBitId().BitId.parse(compData.targetName, false).changeScope(scopeToReplace)) : comp.id.changeScope(scopeToReplace);
  }

  async replaceOriginalPackageNameWithNew(comp, packageToReplace, oldAndNewComponentIds) {
    await Promise.all(comp.filesystem.files.map(async file => {
      const isBinary = await (0, _isbinaryfile().isBinaryFile)(file.contents);
      if (isBinary) return;
      const strContent = file.contents.toString();
      let newContent = strContent;
      Object.keys(packageToReplace).forEach(currentPackage => {
        if (strContent.includes(currentPackage)) {
          const currentPkgRegex = new RegExp(currentPackage, 'g');
          newContent = newContent.replace(currentPkgRegex, packageToReplace[currentPackage]);
        }
      });
      Object.keys(oldAndNewComponentIds).forEach(currentId => {
        if (strContent.includes(currentId)) {
          const currentIdRegex = new RegExp(currentId, 'g');
          newContent = newContent.replace(currentIdRegex, oldAndNewComponentIds[currentId]);
        }
      });

      if (strContent !== newContent) {
        file.contents = Buffer.from(newContent);
      }
    }));
  }

}

exports.WorkspaceGenerator = WorkspaceGenerator;

//# sourceMappingURL=workspace-generator.js.map