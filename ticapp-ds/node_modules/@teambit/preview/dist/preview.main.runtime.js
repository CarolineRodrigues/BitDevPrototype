"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PreviewMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _builder() {
  const data = require("@teambit/builder");

  _builder = function () {
    return data;
  };

  return data;
}

function _bundler() {
  const data = require("@teambit/bundler");

  _bundler = function () {
    return data;
  };

  return data;
}

function _pubsub() {
  const data = require("@teambit/pubsub");

  _pubsub = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _envs() {
  const data = require("@teambit/envs");

  _envs = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _ui() {
  const data = require("@teambit/ui");

  _ui = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _objectHash() {
  const data = _interopRequireDefault(require("object-hash"));

  _objectHash = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = require("fs-extra");

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _pkg() {
  const data = require("@teambit/pkg");

  _pkg = function () {
    return data;
  };

  return data;
}

function _aspectLoader() {
  const data = require("@teambit/aspect-loader");

  _aspectLoader = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));

  _workspace = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");

  _artifactFiles = function () {
    return data;
  };

  return data;
}

function _graphql() {
  const data = _interopRequireDefault(require("@teambit/graphql"));

  _graphql = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _generateLink() {
  const data = require("./generate-link");

  _generateLink = function () {
    return data;
  };

  return data;
}

function _previewArtifact() {
  const data = require("./preview-artifact");

  _previewArtifact = function () {
    return data;
  };

  return data;
}

function _preview() {
  const data = require("./preview.aspect");

  _preview = function () {
    return data;
  };

  return data;
}

function _preview2() {
  const data = require("./preview.route");

  _preview2 = function () {
    return data;
  };

  return data;
}

function _preview3() {
  const data = require("./preview.task");

  _preview3 = function () {
    return data;
  };

  return data;
}

function _strategies() {
  const data = require("./strategies");

  _strategies = function () {
    return data;
  };

  return data;
}

function _executionRef() {
  const data = require("./execution-ref");

  _executionRef = function () {
    return data;
  };

  return data;
}

function _preview4() {
  const data = require("./preview.start-plugin");

  _preview4 = function () {
    return data;
  };

  return data;
}

function _envPreviewTemplate() {
  const data = require("./env-preview-template.task");

  _envPreviewTemplate = function () {
    return data;
  };

  return data;
}

function _envTemplate() {
  const data = require("./env-template.route");

  _envTemplate = function () {
    return data;
  };

  return data;
}

function _componentPreview() {
  const data = require("./component-preview.route");

  _componentPreview = function () {
    return data;
  };

  return data;
}

function _componentStrategy() {
  const data = require("./strategies/component-strategy");

  _componentStrategy = function () {
    return data;
  };

  return data;
}

function _preview5() {
  const data = require("./preview.graphql");

  _preview5 = function () {
    return data;
  };

  return data;
}

function _previewAssets() {
  const data = require("./preview-assets.route");

  _previewAssets = function () {
    return data;
  };

  return data;
}

const noopResult = {
  results: [],
  toString: () => `updating link file`
};
const DEFAULT_TEMP_DIR = (0, _path().join)(_constants().CACHE_ROOT, _preview().PreviewAspect.id);

class PreviewMain {
  constructor(
  /**
   * harmony context.
   */
  harmony,
  /**
   * slot for preview definitions.
   */
  previewSlot, ui, envs, componentAspect, pkg, aspectLoader, config, bundlingStrategySlot, builder, workspace, logger, dependencyResolver) {
    this.harmony = harmony;
    this.previewSlot = previewSlot;
    this.ui = ui;
    this.envs = envs;
    this.componentAspect = componentAspect;
    this.pkg = pkg;
    this.aspectLoader = aspectLoader;
    this.config = config;
    this.bundlingStrategySlot = bundlingStrategySlot;
    this.builder = builder;
    this.workspace = workspace;
    this.logger = logger;
    this.dependencyResolver = dependencyResolver;
    (0, _defineProperty2().default)(this, "writeHash", new Map());
    (0, _defineProperty2().default)(this, "timestamp", Date.now());
    (0, _defineProperty2().default)(this, "executionRefs", new Map());
    (0, _defineProperty2().default)(this, "handleComponentChange", async (c, updater) => {
      const env = this.envs.getEnv(c);
      const envId = env.id.toString();
      const executionRef = this.executionRefs.get(envId);

      if (!executionRef) {
        this.logger.warn(`failed to update link file for component "${c.id.toString()}" - could not find execution context for ${envId}`);
        return noopResult;
      } // add / remove / etc


      updater(executionRef);
      await this.updateLinkFiles(executionRef.currentComponents, executionRef.executionCtx);
      return noopResult;
    });
    (0, _defineProperty2().default)(this, "handleComponentRemoval", cId => {
      let component;
      this.executionRefs.forEach(components => {
        const found = components.get(cId);
        if (found) component = found;
      });
      if (!component) return Promise.resolve(noopResult);
      return this.handleComponentChange(component, currentComponents => currentComponents.remove(cId));
    });
  }

  get tempFolder() {
    var _this$workspace;

    return ((_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.getTempDir(_preview().PreviewAspect.id)) || DEFAULT_TEMP_DIR;
  }

  getComponentBundleSize(component) {
    const data = this.builder.getDataByAspect(component, _preview().PreviewAspect.id);
    if (!data) return undefined;
    return data[_componentStrategy().COMPONENT_STRATEGY_SIZE_KEY_NAME];
  }

  async getPreview(component) {
    const artifacts = await this.builder.getArtifactsVinylByExtensionAndTaskName(component, _preview().PreviewAspect.id, _preview3().PREVIEW_TASK_NAME);
    if (!artifacts) return undefined;
    return new (_previewArtifact().PreviewArtifact)(artifacts);
  }
  /**
   * Get a list of all the artifact files generated during the GeneratePreview task
   * @param component
   * @returns
   */


  async getPreviewFiles(component) {
    const artifacts = await this.getPreview(component);
    const isBundledWithEnv = await this.isBundledWithEnv(component);
    if (!artifacts) return undefined;
    return {
      files: artifacts.getPaths(),
      isBundledWithEnv
    };
  }
  /**
   * Check if the component preview bundle contain the env as part of the bundle or only the component code
   * (we used in the past to bundle them together, there might also be specific envs which still uses the env strategy)
   * @param component
   * @returns
   */


  async isBundledWithEnv(component) {
    const artifacts = await this.builder.getArtifactsVinylByExtensionAndName(component, _preview().PreviewAspect.id, _componentStrategy().COMPONENT_STRATEGY_ARTIFACT_NAME);
    if (!artifacts || !artifacts.length) return true;
    return false;
  }
  /**
   * Getting the env template artifact
   * This should be called with the env itself or it will return undefined
   * If you want to get the env template from the env of the component,
   * use: getEnvTemplateFromComponentEnv below
   *
   * @param component
   * @returns
   */


  async getEnvTemplate(component) {
    const artifacts = await this.builder.getArtifactsVinylByExtensionAndTaskName(component, _preview().PreviewAspect.id, _envPreviewTemplate().GENERATE_ENV_TEMPLATE_TASK_NAME);
    if (!artifacts || !artifacts.length) return undefined;
    return new (_previewArtifact().PreviewArtifact)(artifacts);
  }
  /**
   * This is a special method to get a core env template
   * As the core envs doesn't exist in the scope we need to bring it from other place
   * We will bring it from the core env package files
   */


  async getCoreEnvTemplate(envId) {
    const coreEnvDir = (0, _aspectLoader().getAspectDir)(envId); // const finalDir = join(coreEnvDir, getEnvTemplateArtifactDirectory());

    const artifactDef = (0, _envPreviewTemplate().getArtifactDef)()[0];
    const artifactFactory = new (_builder().ArtifactFactory)();
    let rootDir = artifactFactory.getRootDir(coreEnvDir, artifactDef);

    if (!(0, _fsExtra().existsSync)(rootDir)) {
      // fallback to the bvm folder
      const coreEnvDirFromBvm = (0, _aspectLoader().getAspectDirFromBvm)(envId);
      rootDir = artifactFactory.getRootDir(coreEnvDirFromBvm, artifactDef);
    }

    if (!(0, _fsExtra().existsSync)(rootDir)) {
      return undefined;
    }

    const paths = artifactFactory.resolvePaths(rootDir, artifactDef);

    if (!paths || !paths.length) {
      return undefined;
    }

    const artifactFiles = new (_artifactFiles().ArtifactFiles)(paths);
    artifactFiles.populateVinylsFromPaths(rootDir);
    return new (_previewArtifact().PreviewArtifact)(artifactFiles.vinyls);
  }
  /**
   * This will fetch the component env, then will take the env template from the component env
   * @param component
   */


  async getEnvTemplateFromComponentEnv(component) {
    const envId = this.envs.getEnvId(component);
    return this.getEnvTemplateByEnvId(envId);
  }
  /**
   * This will fetch the component env, then will take the env template from the component env
   * @param component
   */


  async getEnvTemplateByEnvId(envId) {
    // Special treatment for core envs
    if (this.aspectLoader.isCoreEnv(envId)) {
      return this.getCoreEnvTemplate(envId);
    }

    const host = this.componentAspect.getHost();
    const resolvedEnvId = await host.resolveComponentId(envId);
    const envComponent = await host.get(resolvedEnvId);

    if (!envComponent) {
      throw new (_bitError().BitError)(`can't load env. env id is ${envId}`);
    }

    return this.getEnvTemplate(envComponent);
  }

  getDefs() {
    return this.previewSlot.values();
  }

  /**
   * write a link to load custom modules dynamically.
   * @param prefix write
   * @param moduleMap map of components to module paths to require.
   * @param defaultModule
   * @param dirName
   */
  writeLink(prefix, moduleMap, defaultModule, dirName, isSplitComponentBundle) {
    const contents = (0, _generateLink().generateLink)(prefix, moduleMap, defaultModule, isSplitComponentBundle);
    return this.writeLinkContents(contents, dirName, prefix);
  }

  writeLinkContents(contents, targetDir, prefix) {
    const hash = (0, _objectHash().default)(contents);
    const targetPath = (0, _path().join)(targetDir, `${prefix}-${this.timestamp}.js`); // write only if link has changed (prevents triggering fs watches)

    if (this.writeHash.get(targetPath) !== hash) {
      (0, _fsExtra().writeFileSync)(targetPath, contents);
      this.writeHash.set(targetPath, hash);
    }

    return targetPath;
  }

  async getPreviewTarget(
  /** execution context (of the specific env) */
  context) {
    // store context for later link-file updates
    // also register related envs that this context is acting on their behalf
    [context.id, ...context.relatedContexts].forEach(ctxId => {
      this.executionRefs.set(ctxId, new (_executionRef().ExecutionRef)(context));
    });
    const previewRuntime = await this.writePreviewRuntime(context);
    const linkFiles = await this.updateLinkFiles(context.components, context);
    return [...linkFiles, previewRuntime];
  }

  updateLinkFiles(components = [], context) {
    const previews = this.previewSlot.values();
    const paths = previews.map(async previewDef => {
      var _previewDef$renderTem, _this$getEnvPreviewCo, _environment$getCompi;

      const templatePath = await ((_previewDef$renderTem = previewDef.renderTemplatePath) === null || _previewDef$renderTem === void 0 ? void 0 : _previewDef$renderTem.call(previewDef, context));
      const map = await previewDef.getModuleMap(components);
      const environment = context.envRuntime.env;
      const isSplitComponentBundle = (_this$getEnvPreviewCo = this.getEnvPreviewConfig().splitComponentBundle) !== null && _this$getEnvPreviewCo !== void 0 ? _this$getEnvPreviewCo : false;
      const compilerInstance = (_environment$getCompi = environment.getCompiler) === null || _environment$getCompi === void 0 ? void 0 : _environment$getCompi.call(environment);
      const withPaths = map.map((files, component) => {
        var _compilerInstance$get;

        const modulePath = (compilerInstance === null || compilerInstance === void 0 ? void 0 : (_compilerInstance$get = compilerInstance.getPreviewComponentRootPath) === null || _compilerInstance$get === void 0 ? void 0 : _compilerInstance$get.call(compilerInstance, component)) || this.pkg.getModulePath(component);
        return files.map(file => {
          if (!this.workspace || !compilerInstance) {
            return file.path;
          }

          const distRelativePath = compilerInstance.getDistPathBySrcPath(file.relative);
          return (0, _path().join)(this.workspace.path, modulePath, distRelativePath);
        }); // return files.map((file) => file.path);
      });
      const dirPath = (0, _path().join)(this.tempFolder, context.id);
      if (!(0, _fsExtra().existsSync)(dirPath)) (0, _fsExtra().mkdirSync)(dirPath, {
        recursive: true
      });
      const link = this.writeLink(previewDef.prefix, withPaths, templatePath, dirPath, isSplitComponentBundle);
      return link;
    });
    return Promise.all(paths);
  }

  async writePreviewRuntime(context, aspectsIdsToNotFilterOut = []) {
    const ui = this.ui.getUi();
    if (!ui) throw new Error('ui not found');
    const [name, uiRoot] = ui;
    const resolvedAspects = await uiRoot.resolveAspects(_preview().PreviewRuntime.name);
    const filteredAspects = this.filterAspectsByExecutionContext(resolvedAspects, context, aspectsIdsToNotFilterOut);
    const filePath = await this.ui.generateRoot(filteredAspects, name, 'preview', _preview().PreviewAspect.id);
    return filePath;
  }
  /**
   * Filter the aspects to have only aspects that are:
   * 1. core aspects
   * 2. configured on the host (workspace/scope)
   * 3. used by at least one component from the context
   * @param aspects
   * @param context
   */


  filterAspectsByExecutionContext(aspects, context, aspectsIdsToNotFilterOut = []) {
    let allComponentContextAspects = [];
    allComponentContextAspects = context.components.reduce((acc, curr) => {
      return acc.concat(curr.state.aspects.ids);
    }, allComponentContextAspects);
    const hostAspects = Object.keys(this.harmony.config.toObject());
    const allAspectsToInclude = (0, _lodash().uniq)(hostAspects.concat(allComponentContextAspects));
    const filtered = aspects.filter(aspect => {
      if (!aspect.getId) {
        return false;
      }

      return this.aspectLoader.isCoreAspect(aspect.getId) || allAspectsToInclude.includes(aspect.getId) || aspectsIdsToNotFilterOut.includes(aspect.getId);
    });
    return filtered;
  }

  getDefaultStrategies() {
    return [new (_strategies().EnvBundlingStrategy)(this), new (_strategies().ComponentBundlingStrategy)(this, this.pkg, this.dependencyResolver)];
  } // TODO - executionContext should be responsible for updating components list, and emit 'update' events
  // instead we keep track of changes


  getEnvPreviewConfig(env) {
    const config = env !== null && env !== void 0 && env.getPreviewConfig && typeof (env === null || env === void 0 ? void 0 : env.getPreviewConfig) === 'function' ? env === null || env === void 0 ? void 0 : env.getPreviewConfig() : {};
    return config;
  }
  /**
   * return the configured bundling strategy.
   */


  getBundlingStrategy(env) {
    const defaultStrategies = this.getDefaultStrategies();
    const envPreviewConfig = this.getEnvPreviewConfig(env);
    const strategyFromEnv = envPreviewConfig === null || envPreviewConfig === void 0 ? void 0 : envPreviewConfig.strategyName;
    const strategyName = strategyFromEnv || this.config.bundlingStrategy || 'env';
    const strategies = this.bundlingStrategySlot.values().concat(defaultStrategies);
    const selected = strategies.find(strategy => {
      return strategy.name === strategyName;
    });
    if (!selected) throw new (_exceptions().BundlingStrategyNotFound)(strategyName);
    return selected;
  }
  /**
   * register a new bundling strategy. default available strategies are `env` and ``
   */


  registerBundlingStrategy(bundlingStrategy) {
    this.bundlingStrategySlot.register(bundlingStrategy);
    return this;
  }
  /**
   * register a new preview definition.
   */


  registerDefinition(previewDef) {
    this.previewSlot.register(previewDef);
  }

  static async provider( // eslint-disable-next-line max-len
  [bundler, builder, componentExtension, uiMain, envs, workspace, pkg, pubsub, aspectLoader, loggerMain, dependencyResolver, graphql], config, [previewSlot, bundlingStrategySlot], harmony) {
    const logger = loggerMain.createLogger(_preview().PreviewAspect.id); // app.registerApp(new PreviewApp());

    const preview = new PreviewMain(harmony, previewSlot, uiMain, envs, componentExtension, pkg, aspectLoader, config, bundlingStrategySlot, builder, workspace, logger, dependencyResolver);
    if (workspace) uiMain.registerStartPlugin(new (_preview4().PreviewStartPlugin)(workspace, bundler, uiMain, pubsub, logger));
    componentExtension.registerRoute([new (_preview2().PreviewRoute)(preview, logger), new (_componentPreview().ComponentPreviewRoute)(preview, logger), // @ts-ignore
    new (_envTemplate().EnvTemplateRoute)(preview, logger), new (_previewAssets().PreviewAssetsRoute)(preview, logger)]);
    bundler.registerTarget([{
      entry: preview.getPreviewTarget.bind(preview)
    }]);
    if (!config.disabled) builder.registerBuildTasks([new (_envPreviewTemplate().EnvPreviewTemplateTask)(preview, envs, aspectLoader), new (_preview3().PreviewTask)(bundler, preview)]);

    if (workspace) {
      workspace.registerOnComponentAdd(c => preview.handleComponentChange(c, currentComponents => currentComponents.add(c)));
      workspace.registerOnComponentChange(c => preview.handleComponentChange(c, currentComponents => currentComponents.update(c)));
      workspace.registerOnComponentRemove(cId => preview.handleComponentRemoval(cId));
    }

    graphql.register((0, _preview5().previewSchema)(preview));
    return preview;
  }

}

exports.PreviewMain = PreviewMain;
(0, _defineProperty2().default)(PreviewMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(PreviewMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(PreviewMain, "dependencies", [_bundler().BundlerAspect, _builder().BuilderAspect, _component().ComponentAspect, _ui().UIAspect, _envs().EnvsAspect, _workspace().default, _pkg().PkgAspect, _pubsub().PubsubAspect, _aspectLoader().AspectLoaderAspect, _logger().LoggerAspect, _dependencyResolver().DependencyResolverAspect, _graphql().default]);
(0, _defineProperty2().default)(PreviewMain, "defaultConfig", {
  disabled: false
});

_preview().PreviewAspect.addRuntime(PreviewMain);

//# sourceMappingURL=preview.main.runtime.js.map