"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PREVIEW_ROOT_CHUNK_NAME = exports.PEERS_CHUNK_NAME = exports.GENERATE_ENV_TEMPLATE_TASK_NAME = exports.EnvPreviewTemplateTask = void 0;
exports.getArtifactDef = getArtifactDef;
exports.getArtifactDirectory = getArtifactDirectory;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _builder() {
  const data = require("@teambit/builder");

  _builder = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = require("fs-extra");

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _webpack() {
  const data = require("./webpack");

  _webpack = function () {
    return data;
  };

  return data;
}

const GENERATE_ENV_TEMPLATE_TASK_NAME = 'GenerateEnvTemplate';
exports.GENERATE_ENV_TEMPLATE_TASK_NAME = GENERATE_ENV_TEMPLATE_TASK_NAME;
const PREVIEW_ROOT_CHUNK_NAME = 'previewRoot';
exports.PREVIEW_ROOT_CHUNK_NAME = PREVIEW_ROOT_CHUNK_NAME;
const PEERS_CHUNK_NAME = 'peers';
exports.PEERS_CHUNK_NAME = PEERS_CHUNK_NAME;

class EnvPreviewTemplateTask {
  // readonly dependencies = [CompilerAspect.id];
  constructor(preview, envs, aspectLoader) {
    this.preview = preview;
    this.envs = envs;
    this.aspectLoader = aspectLoader;
    (0, _defineProperty2().default)(this, "aspectId", 'teambit.preview/preview');
    (0, _defineProperty2().default)(this, "name", GENERATE_ENV_TEMPLATE_TASK_NAME);
    (0, _defineProperty2().default)(this, "location", 'end');
  }

  async execute(context) {
    const previewDefs = this.preview.getDefs();
    const htmlConfig = this.generateHtmlConfig(previewDefs, PREVIEW_ROOT_CHUNK_NAME, PEERS_CHUNK_NAME, {
      dev: context.dev
    });
    const originalSeedersIds = context.capsuleNetwork.originalSeedersCapsules.map(c => c.component.id.toString());
    const grouped = {};
    await Promise.all(context.components.map(async component => {
      // Do not run over other components in the graph. it make the process much longer with no need
      if (originalSeedersIds && originalSeedersIds.length && !originalSeedersIds.includes(component.id.toString())) {
        return undefined;
      }

      const envDef = this.envs.getEnvFromComponent(component);
      if (!envDef) return undefined;
      const env = envDef.env;
      const bundlingStrategy = this.preview.getBundlingStrategy(envDef.env);

      if (bundlingStrategy.name === 'env') {
        return undefined;
      }

      const target = await this.getEnvTargetFromComponent(context, component, envDef, htmlConfig);
      if (!target) return undefined;
      const shouldUseDefaultBundler = this.shouldUseDefaultBundler(envDef);
      let envToGetBundler = this.envs.getEnvsEnvDefinition().env;
      let groupEnvId = 'default';

      if (!shouldUseDefaultBundler) {
        envToGetBundler = env;
        groupEnvId = envDef.id;
      }

      if (!grouped[groupEnvId]) {
        grouped[groupEnvId] = {
          env: envToGetBundler,
          targets: [target]
        };
      } else {
        grouped[groupEnvId].targets.push(target);
      }

      return undefined;
    }));

    if ((0, _lodash().isEmpty)(grouped)) {
      return {
        componentsResults: []
      };
    }

    return this.runBundlerForGroups(context, grouped);
  }

  async runBundlerForGroups(context, groups) {
    const bundlerContext = Object.assign((0, _lodash().cloneDeep)(context), {
      targets: [],
      entry: [],
      externalizePeer: false,
      development: context.dev,
      metaData: {
        initiator: `${GENERATE_ENV_TEMPLATE_TASK_NAME} task`,
        envId: context.id
      }
    });
    const bundlerResults = await (0, _pMapSeries().default)(Object.entries(groups), async ([, targetsGroup]) => {
      bundlerContext.targets = targetsGroup.targets;
      const bundler = await targetsGroup.env.getTemplateBundler(bundlerContext);
      const bundlerResult = await bundler.run();
      return bundlerResult;
    });
    const results = await this.computeResults(bundlerContext, (0, _lodash().flatten)(bundlerResults));
    return results;
  }

  shouldUseDefaultBundler(envDef) {
    if (this.aspectLoader.isCoreEnv(envDef.id)) return true;
    const env = envDef.env;
    if (env.getTemplateBundler && typeof env.getTemplateBundler === 'function') return false;
    return true;
  }

  async getEnvTargetFromComponent(context, envComponent, envDef, htmlConfig) {
    var _envPreviewConfig$spl;

    const env = envDef.env;
    const envPreviewConfig = this.preview.getEnvPreviewConfig(envDef.env);
    const isSplitComponentBundle = (_envPreviewConfig$spl = envPreviewConfig.splitComponentBundle) !== null && _envPreviewConfig$spl !== void 0 ? _envPreviewConfig$spl : false;
    let peers;

    if (env.getHostDependencies && typeof env.getHostDependencies === 'function') {
      peers = (await env.getHostDependencies()) || [];
    } else {
      const envComponentPeers = Object.keys((await env.getDependencies()).peerDependencies || {}) || [];
      let additionalHostDeps = [];

      if (env.getAdditionalHostDependencies && typeof env.getAdditionalHostDependencies === 'function') {
        additionalHostDeps = await env.getAdditionalHostDependencies();
      }

      peers = envComponentPeers.concat(additionalHostDeps);
    } // const module = await this.getPreviewModule(envComponent);
    // const entries = Object.keys(module).map((key) => module.exposes[key]);


    const capsule = context.capsuleNetwork.graphCapsules.getCapsule(envComponent.id);
    if (!capsule) throw new Error('no capsule found'); // Passing here the env itself to make sure it's preview runtime will be part of the preview root file
    // that's needed to make sure the providers register there are running correctly

    const previewRoot = await this.preview.writePreviewRuntime(context, [envComponent.id.toString()]);
    const previewModules = await this.getPreviewModules(envDef); // const templatesFile = previewModules.map((template) => {
    //   return this.preview.writeLink(template.name, ComponentMap.create([]), template.path, capsule.path);
    // });

    const outputPath = this.computeOutputPath(context, envComponent);
    if (!(0, _fsExtra().existsSync)(outputPath)) (0, _fsExtra().mkdirpSync)(outputPath);
    const entries = this.getEntries(previewModules, capsule, previewRoot, isSplitComponentBundle, peers);
    return {
      peers,
      runtimeChunkName: 'runtime',
      html: htmlConfig,
      entries,
      chunking: {
        splitChunks: true
      },
      components: [envComponent],
      outputPath
    };
  }

  generateHtmlConfig(previewDefs, previewRootChunkName, peersChunkName, options) {
    const htmlConfigs = previewDefs.map(previewModule => this.generateHtmlConfigForPreviewDef(previewModule, previewRootChunkName, peersChunkName, options));
    return htmlConfigs;
  }

  generateHtmlConfigForPreviewDef(previewDef, previewRootChunkName, peersChunkName, options) {
    var _options$dev;

    const previewDeps = previewDef.include || [];
    const chunks = [...previewDeps, previewDef.prefix, previewRootChunkName];

    if (previewDef.includePeers) {
      chunks.unshift(peersChunkName);
    }

    const config = {
      title: 'Preview',
      templateContent: (0, _webpack().html)('Preview'),
      minify: (_options$dev = options === null || options === void 0 ? void 0 : options.dev) !== null && _options$dev !== void 0 ? _options$dev : true,
      chunks,
      filename: `${previewDef.prefix}.html`
    };
    return config;
  }

  getEntries(previewModules, capsule, previewRoot, isSplitComponentBundle = false, peers = []) {
    const previewRootEntry = {
      filename: 'preview-root.[chunkhash].js',
      import: previewRoot
    };
    const peersRootEntry = {
      filename: 'peers.[chunkhash].js',
      import: peers
    };
    const entries = previewModules.reduce((acc, module) => {
      const linkFile = this.preview.writeLink(module.name, _component().ComponentMap.create([]), module.path, capsule.path, isSplitComponentBundle);
      acc[module.name] = {
        // filename: `${module.name}.[contenthash].js`,
        filename: `${module.name}.[chunkhash].js`,
        // filename: `${module.name}.js`,
        import: linkFile // library: {
        //   name: module.name,
        //   type: 'umd',
        // },

      };

      if (module.include) {
        acc[module.name].dependOn = module.include;
      }

      return acc;
    }, {
      [PREVIEW_ROOT_CHUNK_NAME]: previewRootEntry,
      [PEERS_CHUNK_NAME]: peersRootEntry
    });
    return entries;
  }

  async computeResults(context, results) {
    const allResults = results.map(result => {
      const componentsResults = result.components.map(component => {
        return {
          component,
          errors: result.errors.map(err => typeof err === 'string' ? err : err.message),
          warning: result.warnings,
          startTime: result.startTime,
          endTime: result.endTime
        };
      });
      return componentsResults;
    });
    const componentsResults = (0, _lodash().flatten)(allResults);
    const artifacts = getArtifactDef();
    return {
      componentsResults,
      artifacts
    };
  }

  async getPreviewModules(envDef) {
    const previewDefs = this.preview.getDefs();
    const modules = (0, _lodash().compact)(await Promise.all(previewDefs.map(async def => {
      if (!def.renderTemplatePathByEnv) return undefined;
      return {
        name: def.prefix,
        path: await def.renderTemplatePathByEnv(envDef.env),
        include: def.include
      };
    })));
    return modules;
  }

  computeOutputPath(context, component) {
    const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
    if (!capsule) throw new Error('no capsule found');
    return (0, _path().join)(capsule.path, getArtifactDirectory());
  }

}

exports.EnvPreviewTemplateTask = EnvPreviewTemplateTask;

function getArtifactDirectory() {
  return (0, _path().join)(_builder().CAPSULE_ARTIFACTS_DIR, 'env-template');
}

function getArtifactDef() {
  return [{
    name: 'env-template',
    globPatterns: ['**'],
    rootDir: getArtifactDirectory()
  }];
}

//# sourceMappingURL=env-preview-template.task.js.map