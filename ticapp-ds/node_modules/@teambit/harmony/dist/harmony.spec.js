"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const harmony_1 = require("./harmony");
const chai_1 = require("chai");
const react_aspect_1 = require("./fixtures/aspects/react/react.aspect");
describe('Harmony', () => {
    describe('run()', () => {
        //   it('should return a string', async () => {
        //     const manifest = {
        //       name: 'HelloWorld',
        //       provider: async () => 'hello world'
        //     };
        //     await harmony.run(manifest);
        //     expect(harmony.get('HelloWorld')).eql('hello world');
        //   });
        //   it('should load an array of different extensions', async () => {
        //     await harmony.run([BaseCompiler, TypeScript]);
        //     const compiler = harmony.get<BaseCompiler>('BaseCompiler')
        //     const typescript = harmony.get<TypeScript>('typescript')      
        //     expect(typescript.compile()).to.eq('hello world');
        //     expect(compiler.compile()).to.eq('hello world');
        //   });
        //   it('should load extensions with slots', async () => {
        //     class Env {
        //       build () {
        //         return 'react built';
        //       }
        //     }
        //     it('extension instance should include an ID', async () => {
        //       const React = { 
        //         name: '@teambit/react', 
        //         dependencies: [],
        //         provide: async () => {} 
        //       };      
        //       await harmony.run([React]);
        //       const react = harmony.get<any>(React.name);  
        //       expect(react.id).to.eq(React.name);
        //     });
        //     const Envs: ExtensionManifest = { 
        //       name: '@teambit/envs', 
        //       slots: [Slot.withType<Env>()],
        //       provider: async ([], config: {env: string}, [envSlot]: [SlotRegistry<Env>]) => {
        //         return {
        //           register: (env: Env) => {
        //             envSlot.register(env);
        //           },
        //           start() {
        //             const instance = envSlot.get(config.env);
        //             if (!instance) throw new Error('could not find envs');
        //             return instance.build();
        //           }
        //         };
        //       }
        //     };
        //     const React = { 
        //       name: '@teambit/react', 
        //       dependencies: [Envs],
        //       provide: async ([envs]: [{ register: (env: Env) => void }], config: {}) => {
        //         envs.register(new Env());
        //       } 
        //     };      
        //     const harmony = Harmony.load([Envs, React], {
        //       '@teambit/envs': {
        //         env: '@teambit/react'
        //       }
        //     });
        //     await harmony.run([Envs, React]);
        //     const envs = harmony.get<any>(Envs.name);
        //     expect(envs.start()).to.eq('react built');
        //   });
        //   it('should load extensions with config', async () => {
        //     const e1 = { 
        //       name: '@teambit/typescript', 
        //       provider: async ([], config: { declarations: boolean }) => {
        //         return {
        //           get: () => {
        //             return config.declarations || false
        //           }
        //         };
        //       }
        //     };
        //     const e2 = { name: '@teambit/react', defaultConfig: {ts: false}, provide: async ([], config: any) => {
        //        return {
        //          config: config.ts
        //        };
        //       } 
        //     };
        //     const harmony = Harmony.load([e1], {
        //       '@teambit/typescript': {
        //         declarations: true
        //       },
        //     });
        //     await harmony.run([e1]);
        //     const ts = harmony.get<{get: () => {}}>('@teambit/typescript');
        //     expect(ts.get()).to.eq(true);
        //     harmony.config.set('@teambit/react', {ts: true});
        //     await harmony.set([e2]);
        //     const react = harmony.get<{[key: string]: object}>('@teambit/react');
        //     expect(react.config).to.eq(true);
        //   });
        //   it('should invoke a class extension method', async () => {
        //     await harmony.run(BaseCompiler);
        //     const compiler = harmony.get<BaseCompiler>('BaseCompiler')
        //     expect(compiler.compile()).to.eq('hello world');
        //   });
        //   it('should invoke a class extension with configured dependencies', async () => {
        //     await harmony.run(TypeScript);
        //     const typescript = harmony.get<TypeScript>('typescript')      
        //     expect(typescript.compile()).to.eq('hello world');
        //   });
        //   it('should use prefer id over name', async () => {
        //     const dependency = {
        //       name: 'dependencyName',
        //       id: 'dependencyId',
        //       provider: async () => 'hello world'
        //     };
        //     const dependent = {
        //       name: 'dependentName',
        //       id: 'dependentId',
        //       dependencies: [dependency],
        //       provider: async () => 'hello world'
        //     };
        //     await harmony.run(dependent);
        //     const ids = harmony.extensionsIds;  
        //     expect(ids).to.contain('dependencyId');
        //     expect(ids).to.contain('dependentId');
        //   });
        //   it('should execute bit core extension graph', async () => {
        //     // const bit = await Harmony.run(BitExt);
        //   });
        //   it('should register during run', async () => {
        //     const compiler = await harmony.run(Babel);
        //   });
        it('should execute an aspect in the cli runtime', () => __awaiter(void 0, void 0, void 0, function* () {
            const harmony = yield harmony_1.Harmony.load([react_aspect_1.ReactAspect], 'cli', {});
            yield harmony.run();
            const react = harmony.get('@teambit/react');
        }));
        it('should execute an aspect in the ui runtime', () => __awaiter(void 0, void 0, void 0, function* () {
            const harmony = yield harmony_1.Harmony.load([react_aspect_1.ReactAspect], 'ui', {});
            yield harmony.run();
            const react = harmony.get('@teambit/react');
            chai_1.expect(react.render()).to.exist;
        }));
    });
});
