"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenerateCommandsDoc = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _getCommandId() {
  const data = require("./get-command-id");

  _getCommandId = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

class GenerateCommandsDoc {
  constructor(commands, options) {
    this.commands = commands;
    this.options = options;
  }

  generate() {
    const commands = this.getAllPublicCommandsSorted();

    const metadata = _objectSpread({
      id: 'cli-all',
      title: 'CLI Commands'
    }, this.options.metadata);

    const metadataStr = Object.keys(metadata).map(key => `${key}: ${metadata[key]}`).join('\n');
    let output = `---
${metadataStr}
---

Commands that are marked as workspace only must be executed inside a workspace. Commands that are marked as not workspace only, can be executed from anywhere and will run on a remote server.
`;
    output += commands.map(cmd => this.generateCommand(cmd)).join('\n');
    return output;
  }

  getAllPublicCommandsSorted() {
    const publicCommands = this.commands.filter(cmd => !cmd.private);
    return publicCommands.sort((a, b) => a.name.localeCompare(b.name));
  }

  generateCommand(cmd) {
    const commandName = (0, _getCommandId().getCommandId)(cmd.name);
    let result = `## ${commandName}  \n\n`;

    if (cmd.alias && cmd.alias.length > 0) {
      result += `**Alias**: \`${cmd.alias}\`  \n`;
    }

    result += `**Workspace only**: ${cmd.skipWorkspace ? 'no' : 'yes'}  \n`;
    result += `**Description**: ${this.formatDescription(cmd.description)}`;
    result += `\`bit ${cmd.name}\`  \n\n`;

    if (cmd.commands && cmd.commands.length > 0) {
      result += this.generateSubCommands(cmd.commands);
    }

    result += this.generateOptions(cmd.options);
    result += `---  \n`;
    return result;
  }

  generateSubCommands(subCommands) {
    let ret = '';
    subCommands.forEach(subCommand => {
      // @ts-ignore
      const name = subCommand.name.match(/^([\w-]+)/)[0];
      const usage = subCommand.name;
      ret += `### ${name} \n`;
      ret += `**Usage**: \`${usage}\`  \n\n`;
      ret += `**Description**: ${this.formatDescription(subCommand.description)}`;
      ret += '\n';
      ret += this.generateOptions(subCommand.options);
    });
    return ret;
  }

  generateOptions(options) {
    if (!options || options.length <= 0) return '';
    let output = `| **Option** | **Option alias** | **Description**|  \n`;
    output += `|---|:-----:|---|\n`;
    options.forEach(opt => {
      const [alias, flag, description] = opt;
      const aliasFormatted = alias ? `\`-${alias}\`` : '   ';
      const flagFormatted = `--${flag}`;
      output += `|\`${flagFormatted}\`|${aliasFormatted}|${description}|\n`;
    });
    output += `\n`;
    return output;
  }

  formatDescription(description) {
    return `${description.split('\n').join('  \n')}  \n\n`;
  }

}

exports.GenerateCommandsDoc = GenerateCommandsDoc;

//# sourceMappingURL=generate-doc-md.js.map