"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactSSR = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function () {
    return data;
  };

  return data;
}

function _webpackMerge() {
  const data = require("webpack-merge");

  _webpackMerge = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = _interopRequireDefault(require("lodash.compact"));

  _lodash = function () {
    return data;
  };

  return data;
}

function _reactDom() {
  const data = _interopRequireDefault(require("react-dom"));

  _reactDom = function () {
    return data;
  };

  return data;
}

function _server() {
  const data = _interopRequireDefault(require("react-dom/server"));

  _server = function () {
    return data;
  };

  return data;
}

function _uiFoundationUiRendering() {
  const data = require("@teambit/ui-foundation.ui.rendering.html");

  _uiFoundationUiRendering = function () {
    return data;
  };

  return data;
}

function _baseUiUtils() {
  const data = require("@teambit/base-ui.utils.composer");

  _baseUiUtils = function () {
    return data;
  };

  return data;
}

class ReactSSR {
  constructor( // create array once to keep consistent indexes
  lifecycleHooks) {
    this.lifecycleHooks = lifecycleHooks;
  }
  /** render and rehydrate client-side */


  async renderBrowser(children) {
    // (*) load state from the dom
    const deserializedState = await this.deserialize(); // (1) init setup client plugins

    let renderContexts = await this.triggerBrowserInit(deserializedState); // (2) make react dom

    const reactContexts = this.getReactContexts(renderContexts);

    const app = /*#__PURE__*/_react().default.createElement(_baseUiUtils().Composer, {
      components: reactContexts
    }, children);

    renderContexts = await this.triggerBeforeHydrateHook(renderContexts, app); // (3) render / rehydrate

    const mountPoint = document.getElementById(_uiFoundationUiRendering().mountPointId); // .render() already runs `.hydrate()` behind the scenes.
    // in the future, we may want to replace it with .hydrate()

    _reactDom().default.render(app, mountPoint);

    await this.triggerHydrateHook(renderContexts, mountPoint); // (3.1) remove ssr only styles

    (0, _uiFoundationUiRendering().ssrCleanup)();
  }
  /** render dehydrated server-side */


  async renderServer(children, {
    assets,
    browser,
    server
  } = {}) {
    // (1) init
    let renderContexts = await this.triggerServerInit(browser, server); // (2) make React dom

    const reactContexts = this.getReactContexts(renderContexts);

    const app = /*#__PURE__*/_react().default.createElement(_uiFoundationUiRendering().MountPoint, null, /*#__PURE__*/_react().default.createElement(_baseUiUtils().Composer, {
      components: reactContexts
    }, children));

    renderContexts = await this.triggerBeforeRender(renderContexts, app); // (3) render (to string)

    const renderedApp = _server().default.renderToString(app); // (*) serialize state


    const realtimeAssets = await this.serialize(renderContexts, app); // @ts-ignore // TODO upgrade 'webpack-merge'

    const totalAssets = (0, _webpackMerge().merge)(assets, realtimeAssets); // (4) render html-template (to string)

    const html = /*#__PURE__*/_react().default.createElement(_uiFoundationUiRendering().Html, {
      assets: totalAssets,
      withDevTools: true,
      fullHeight: true,
      ssr: true
    });

    const renderedHtml = `<!DOCTYPE html>${_server().default.renderToStaticMarkup(html)}`;

    const fullHtml = _uiFoundationUiRendering().Html.fillContent(renderedHtml, renderedApp); // (5) serve


    return fullHtml;
  }

  triggerBrowserInit(deserializedState) {
    const {
      lifecycleHooks
    } = this;
    const initPromises = lifecycleHooks.map(([, hooks], idx) => {
      var _hooks$browserInit;

      const state = deserializedState[idx];
      return (_hooks$browserInit = hooks.browserInit) === null || _hooks$browserInit === void 0 ? void 0 : _hooks$browserInit.call(hooks, state);
    });
    return Promise.all(initPromises);
  }

  triggerServerInit(browser, server) {
    const {
      lifecycleHooks
    } = this;
    const promises = lifecycleHooks.map(([, hooks]) => {
      var _hooks$serverInit;

      return (_hooks$serverInit = hooks.serverInit) === null || _hooks$serverInit === void 0 ? void 0 : _hooks$serverInit.call(hooks, {
        browser,
        server
      });
    });
    return Promise.all(promises);
  }

  triggerBeforeHydrateHook(renderContexts, app) {
    const {
      lifecycleHooks
    } = this;
    const promises = lifecycleHooks.map(async ([, hooks], idx) => {
      var _hooks$onBeforeHydrat;

      const ctx = renderContexts[idx];
      const nextCtx = await ((_hooks$onBeforeHydrat = hooks.onBeforeHydrate) === null || _hooks$onBeforeHydrat === void 0 ? void 0 : _hooks$onBeforeHydrat.call(hooks, ctx, app));
      return nextCtx || ctx;
    });
    return Promise.all(promises);
  }

  async triggerHydrateHook(renderContexts, mountPoint) {
    const {
      lifecycleHooks
    } = this;
    const promises = lifecycleHooks.map(([, hooks], idx) => {
      var _hooks$onHydrate;

      const renderCtx = renderContexts[idx];
      return (_hooks$onHydrate = hooks.onHydrate) === null || _hooks$onHydrate === void 0 ? void 0 : _hooks$onHydrate.call(hooks, renderCtx, mountPoint);
    });
    await Promise.all(promises);
  }

  async triggerBeforeRender(renderContexts, app) {
    const {
      lifecycleHooks
    } = this;
    const promises = lifecycleHooks.map(async ([, hooks], idx) => {
      var _hooks$onBeforeRender;

      const ctx = renderContexts[idx];
      const nextCtx = await ((_hooks$onBeforeRender = hooks.onBeforeRender) === null || _hooks$onBeforeRender === void 0 ? void 0 : _hooks$onBeforeRender.call(hooks, ctx, app));
      return nextCtx || ctx;
    });
    await Promise.all(promises);
    return renderContexts;
  }

  getReactContexts(renderContexts) {
    const {
      lifecycleHooks
    } = this;
    return (0, _lodash().default)(lifecycleHooks.map(([, hooks], idx) => {
      const renderCtx = renderContexts[idx];
      const props = {
        renderCtx
      };
      return hooks.reactContext ? [hooks.reactContext, props] : undefined;
    }));
  }

  async deserialize() {
    const {
      lifecycleHooks
    } = this;

    const rawAssets = _uiFoundationUiRendering().Html.popAssets();

    const deserialized = await Promise.all(lifecycleHooks.map(async ([key, hooks]) => {
      try {
        var _hooks$deserialize;

        const raw = rawAssets.get(key);
        return (_hooks$deserialize = hooks.deserialize) === null || _hooks$deserialize === void 0 ? void 0 : _hooks$deserialize.call(hooks, raw);
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error(`failed deserializing server state for aspect ${key}`, e);
        return undefined;
      }
    }));
    return deserialized;
  }

  async serialize(renderContexts, app) {
    const {
      lifecycleHooks
    } = this;
    const json = {};
    const promises = lifecycleHooks.map(async ([key, hooks], idx) => {
      var _hooks$serialize;

      const renderCtx = renderContexts[idx];
      const result = await ((_hooks$serialize = hooks.serialize) === null || _hooks$serialize === void 0 ? void 0 : _hooks$serialize.call(hooks, renderCtx, app));
      if (!result) return;
      if (result.json) json[key] = result.json;
    });
    await Promise.all(promises); // more assets will be available in the future

    return {
      json
    };
  }

}

exports.ReactSSR = ReactSSR;

//# sourceMappingURL=react-ssr.js.map