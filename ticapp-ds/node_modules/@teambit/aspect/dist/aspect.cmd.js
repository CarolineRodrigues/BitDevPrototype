"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateAspectCmd = exports.UnsetAspectCmd = exports.SetAspectCmd = exports.ListAspectCmd = exports.GetAspectCmd = exports.AspectCmd = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _cliTable() {
  const data = require("@teambit/cli-table");

  _cliTable = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

// eslint-disable-next-line max-classes-per-file
class ListAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'list [pattern]');
    (0, _defineProperty2().default)(this, "description", 'list all aspects configured on component(s)');
    (0, _defineProperty2().default)(this, "options", [['d', 'debug', 'show the origins were the aspects were taken from']]);
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "extendedDescription", `${(0, _constants().PATTERN_HELP)('aspect list')}`);
  }

  async report([name], {
    debug
  }) {
    const listAspectsResults = await this.aspect.listAspectsOfComponent(name);
    const rows = Object.keys(listAspectsResults).map(componentId => {
      const longestAspectName = Math.max(...listAspectsResults[componentId].map(_ => _.aspectName.length));
      const aspects = listAspectsResults[componentId].map(aspectSource => {
        const origin = debug ? ` (origin: ${aspectSource.source})` : '';
        const aspectName = aspectSource.aspectName.padEnd(longestAspectName);
        return `${aspectName} (level: ${aspectSource.level})${origin}`;
      }).join('\n');
      return [componentId, aspects];
    });
    const table = new (_cliTable().CLITable)([], rows);
    return table.render();
  }

}

exports.ListAspectCmd = ListAspectCmd;

class SetAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'set <pattern> <aspect-id> [config]');
    (0, _defineProperty2().default)(this, "description", 'set an aspect to component(s) with optional config.');
    (0, _defineProperty2().default)(this, "extendedDescription", `enter the config as stringified JSON (e.g. '{"foo":"bar"}' ).
if no config entered, the aspect will be set with empty config ({}).
${(0, _constants().PATTERN_HELP)('aspect set')}`);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }

  async report([pattern, aspectId, config]) {
    const configParsed = config ? JSON.parse(config) : {};
    const results = await this.aspect.setAspectsToComponents(pattern, aspectId, configParsed);
    if (!results.length) return _chalk().default.yellow(`unable to find any matching for ${_chalk().default.bold(pattern)} pattern`);
    return _chalk().default.green(`the following component(s) have been successfully updated:\n${results.join('\n')}`);
  }

}

exports.SetAspectCmd = SetAspectCmd;

class UpdateAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'update <aspect-id> [pattern]');
    (0, _defineProperty2().default)(this, "description", 'update a version of an aspect');
    (0, _defineProperty2().default)(this, "extendedDescription", `default to all components using the aspect, unless "pattern" is provided.
${(0, _constants().PATTERN_HELP)('aspect update <aspect-id>')}
examples:
"bit aspect update scope.org/aspect '**/ui/**'" - update "ui" components that use scope.org/aspect to the latest version
"bit aspect update scope.org/aspect@2.0.0"      - updates all components using scope.org/aspect to version 2.0.0.`);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }

  async report([aspectId, pattern]) {
    const results = await this.aspect.updateAspectsToComponents(aspectId, pattern);
    if (!results.length) return _chalk().default.yellow(`unable to find any component that use ${_chalk().default.bold(aspectId)}`);
    return _chalk().default.green(`the following component(s) have been successfully updated:\n${results.join('\n')}`);
  }

}

exports.UpdateAspectCmd = UpdateAspectCmd;

class UnsetAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'unset <pattern> <aspect-id>');
    (0, _defineProperty2().default)(this, "description", `unset an aspect from component(s).`);
    (0, _defineProperty2().default)(this, "extendedDescription", `${(0, _constants().PATTERN_HELP)('aspect unset')}`);
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
  }

  async report([pattern, aspectId]) {
    const results = await this.aspect.unsetAspectsFromComponents(pattern, aspectId);
    if (!results.length) return _chalk().default.yellow(`unable to find any matching for ${_chalk().default.bold(pattern)} pattern`);
    return _chalk().default.green(`the following component(s) have been successfully updated:\n${results.join('\n')}`);
  }

}

exports.UnsetAspectCmd = UnsetAspectCmd;

class GetAspectCmd {
  constructor(aspect) {
    this.aspect = aspect;
    (0, _defineProperty2().default)(this, "name", 'get <component-id>');
    (0, _defineProperty2().default)(this, "description", "show aspects' data and configuration of the given component");
    (0, _defineProperty2().default)(this, "options", [['d', 'debug', 'show the origins were the aspects were taken from'], ['j', 'json', 'format as json']]);
    (0, _defineProperty2().default)(this, "group", 'development');
  }

  async report([componentName], {
    debug
  }) {
    const {
      extensions: mergedExtensions,
      beforeMerge
    } = await this.aspect.getAspectsOfComponent(componentName);

    const extensionsDetailsToString = extensions => extensions.map(e => {
      const {
        name,
        data,
        config,
        extensionId
      } = e.toComponentObject();
      return `${_chalk().default.bold('name:')}   ${name || (extensionId === null || extensionId === void 0 ? void 0 : extensionId.toString())}
${_chalk().default.bold('config:')} ${JSON.stringify(config, undefined, 2)}
${_chalk().default.bold('data:')}   ${JSON.stringify(data, undefined, 2)}
`;
    }).join('\n');

    if (debug) {
      const beforeMergeOutput = beforeMerge.map(({
        origin,
        extensions,
        extraData
      }) => {
        const title = _chalk().default.green.bold(`Origin: ${origin}`);

        const details = extensionsDetailsToString(extensions);
        const moreData = extraData ? `\n${_chalk().default.bold('Extra Data:')} ${JSON.stringify(extraData, undefined, 2)}` : '';
        return `${title}\n${details}${moreData}`;
      }).join('\n\n');

      const afterMergeTitle = _chalk().default.green.bold('Final - after merging all origins');

      const afterMergeOutput = `${afterMergeTitle}\n${extensionsDetailsToString(mergedExtensions)}`;
      return `${beforeMergeOutput}\n\n\n${afterMergeOutput}`;
    }

    return extensionsDetailsToString(mergedExtensions);
  }

  async json([componentName], {
    debug
  }) {
    const {
      extensions: mergedExtensions,
      beforeMerge
    } = await this.aspect.getAspectsOfComponent(componentName);

    const extensionsDetailsToObject = extensions => extensions.reduce((acc, current) => {
      const {
        name,
        data,
        config,
        extensionId
      } = current.toComponentObject();
      const aspectName = name || (extensionId === null || extensionId === void 0 ? void 0 : extensionId.toString()) || '<no-name>';
      acc[aspectName] = {
        name: aspectName,
        config,
        data
      };
      return acc;
    }, {});

    if (debug) {
      const jsonObj = {};
      beforeMerge.forEach(({
        origin,
        extensions,
        extraData
      }) => {
        jsonObj[origin] = {
          extensions: extensionsDetailsToObject(extensions),
          extraData
        };
      });
      jsonObj.FinalAfterMerge = {
        extensions: extensionsDetailsToObject(mergedExtensions)
      };
      return jsonObj;
    }

    return extensionsDetailsToObject(mergedExtensions);
  }

}

exports.GetAspectCmd = GetAspectCmd;

class AspectCmd {
  constructor() {
    (0, _defineProperty2().default)(this, "name", 'aspect <sub-command>');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "description", 'EXPERIMENTAL. manage aspects');
    (0, _defineProperty2().default)(this, "options", []);
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "commands", []);
  }

  async report([unrecognizedSubcommand]) {
    return _chalk().default.red(`"${unrecognizedSubcommand}" is not a subcommand of "aspect", please run "bit aspect --help" to list the subcommands`);
  }

}

exports.AspectCmd = AspectCmd;

//# sourceMappingURL=aspect.cmd.js.map