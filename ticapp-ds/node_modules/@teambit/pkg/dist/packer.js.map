{"version":3,"sources":["packer.ts"],"names":["DEFAULT_TAR_DIR_IN_CAPSULE","PACK_CONCURRENCY","TAR_FILE_ARTIFACT_NAME","Packer","constructor","isolator","logger","host","scope","legacyPacker","LegacyPacker","packComponent","componentId","scopePath","options","loadScopeFromCache","undefined","legacyScope","LegacyScope","load","ScopeNotFound","isLegacyScope","isLegacy","res","pack","Object","assign","id","capsule","getCapsule","packCapsule","writeOptions","dryRun","_","omit","packMultipleCapsules","capsules","override","omitFullTarPath","results","concurrency","concreteWriteOpts","outDir","packResult","npmPack","path","component","fieldsToRemove","push","metadata","omitBy","isUndefined","value","errors","warnings","startTime","endTime","getArtifactDefInCapsule","rootDir","def","name","globPatterns","componentIdStr","resolveComponentId","network","isolateComponents","baseDir","seedersCapsules","Error"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport { ComponentFactory } from '@teambit/component';\nimport { ComponentResult, ArtifactDefinition } from '@teambit/builder';\nimport { Capsule, IsolatorMain } from '@teambit/isolator';\nimport { ScopeMain } from '@teambit/scope';\nimport LegacyScope from '@teambit/legacy/dist/scope/scope';\nimport { Packer as LegacyPacker, PackWriteOptions, PackOptions } from '@teambit/legacy/dist/pack';\nimport { Logger } from '@teambit/logger';\nimport pMap from 'p-map';\n\n// @ts-ignore (for some reason the tsc -w not found this)\nimport { ScopeNotFound } from './exceptions/scope-not-found';\n\nexport { PackOptions };\n\nexport type PackResult = Omit<ComponentResult, 'component'>;\nexport type PackResultWithId = PackResult & {\n  id: string;\n};\n\nconst DEFAULT_TAR_DIR_IN_CAPSULE = 'package-tar';\nconst PACK_CONCURRENCY = 10;\nexport const TAR_FILE_ARTIFACT_NAME = 'package tar file';\n\nexport class Packer {\n  legacyPacker: LegacyPacker;\n  constructor(\n    private isolator: IsolatorMain,\n    private logger: Logger,\n    private host: ComponentFactory,\n    private scope?: ScopeMain\n  ) {\n    this.legacyPacker = new LegacyPacker(this.logger);\n  }\n\n  async packComponent(\n    componentId: string,\n    scopePath: string | undefined,\n    options: PackOptions\n  ): Promise<PackResultWithId> {\n    // By default do not load scope from cache when packing\n    const loadScopeFromCache =\n      options && options.loadScopeFromCache !== undefined ? !!options.loadScopeFromCache : false;\n    const legacyScope = scopePath ? await LegacyScope.load(scopePath, loadScopeFromCache) : this.scope?.legacyScope;\n    if (!legacyScope) {\n      throw new ScopeNotFound(scopePath);\n    }\n    // Or the scope we are operate on is legacy, or the host (workspace) is legacy\n    const isLegacyScope = (scopePath && legacyScope.isLegacy) || this.host.isLegacy;\n\n    // Handle legacy\n    if (isLegacyScope) {\n      const res = await this.legacyPacker.pack(componentId, legacyScope, options);\n      // @ts-ignore\n      return Object.assign({}, res, { id: componentId });\n    }\n\n    const capsule = await this.getCapsule(componentId, legacyScope);\n    const res = await this.packCapsule(capsule, options.writeOptions, options.dryRun);\n\n    return Object.assign({}, _.omit(res, ['component']), { id: componentId });\n  }\n\n  async packMultipleCapsules(\n    capsules: Capsule[],\n    writeOptions: PackWriteOptions = { override: true },\n    dryRun = false,\n    omitFullTarPath = false\n  ): Promise<ComponentResult[]> {\n    // const description = `packing components${dryRun ? ' (dry-run)' : ''}`;\n    const results = pMap(\n      capsules,\n      (capsule) => {\n        return this.packCapsule(capsule, writeOptions, dryRun, omitFullTarPath);\n      },\n      { concurrency: PACK_CONCURRENCY }\n    );\n    return results;\n  }\n\n  async packCapsule(\n    capsule: Capsule,\n    writeOptions: PackWriteOptions = { override: true },\n    dryRun = false,\n    omitFullTarPath = false\n  ): Promise<ComponentResult> {\n    const concreteWriteOpts = writeOptions;\n    // Set the package-tar as out dir to easily read the tar later\n    concreteWriteOpts.outDir = concreteWriteOpts.outDir ?? DEFAULT_TAR_DIR_IN_CAPSULE;\n    const packResult = await this.legacyPacker.npmPack(\n      capsule.path,\n      concreteWriteOpts.outDir || capsule.path,\n      concreteWriteOpts.override,\n      dryRun\n    );\n    const component = capsule.component;\n    const fieldsToRemove: string[] = [];\n    if (omitFullTarPath) {\n      fieldsToRemove.push('tarPath');\n    }\n    // TODO: @gilad please make sure to fix this type error now that I added lodash types\n    const metadata = _(packResult.metadata).omitBy(_.isUndefined).omit(fieldsToRemove).value() as any;\n\n    return {\n      component,\n      metadata,\n      errors: packResult.errors,\n      warnings: packResult.warnings,\n      startTime: packResult.startTime,\n      endTime: packResult.endTime,\n    };\n  }\n\n  getArtifactDefInCapsule(outDir?: string): ArtifactDefinition {\n    const rootDir = outDir || DEFAULT_TAR_DIR_IN_CAPSULE;\n    const def: ArtifactDefinition = {\n      name: TAR_FILE_ARTIFACT_NAME,\n      globPatterns: [`${rootDir}/*.tgz`],\n    };\n    return def;\n  }\n\n  private async getCapsule(componentIdStr: string, legacyScope: LegacyScope): Promise<Capsule> {\n    const componentId = await this.host.resolveComponentId(componentIdStr);\n    const network = await this.isolator.isolateComponents([componentId], { baseDir: this.host.path }, legacyScope);\n    const capsule = network.seedersCapsules.getCapsule(componentId);\n\n    if (!capsule) throw new Error(`capsule not found for ${componentId}`);\n    return capsule;\n  }\n}\n"]}