{"version":3,"sources":["workspace-manifest-factory.ts"],"names":["DEFAULT_CREATE_OPTIONS","filterComponentsFromManifests","createManifestForComponentsWithoutDependencies","dedupe","WorkspaceManifestFactory","constructor","dependencyResolver","createFromComponents","name","version","rootPolicy","rootDir","components","options","optsWithDefaults","Object","assign","componentDependenciesMap","buildComponentDependenciesMap","dependencyFilterFn","dedupedDependencies","rootDependencies","toManifest","envPeers","getEnvsPeersPolicy","componentsManifestsMap","getComponentsManifests","workspaceManifest","WorkspaceManifest","foundEnvs","Promise","all","map","component","getComponentEnvPolicy","peersPolicies","policy","peersAutoDetectPolicy","mergedPolicies","PeersAutoDetectPolicy","mergePolices","buildResultsP","packageName","state","_consumer","depList","getDependencies","componentPolicy","getPolicy","filterComponents","filterResolvedFromEnv","filter","dep","id","updateDependenciesVersions","depManifest","toDependenciesManifest","result","Map","length","results","forEach","currResult","set","dependencyList","mergeVariantPolicies","config","extensions","componentsToFilterOut","filtered","ComponentDependency","componentId","hasVersion","existingComponent","find","toString","ignoreVersion","_legacy","isEqual","fromPolicy","value","resolveFromEnv","componentsManifests","has","blankDependencies","dependencies","devDependencies","peerDependencies","get","getVersion","isVersionSnap","manifest","ComponentManifest","SemVer"],"mappings":";;;;;;;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAgBA,MAAMA,sBAAmD,GAAG;AAC1DC,EAAAA,6BAA6B,EAAE,IAD2B;AAE1DC,EAAAA,8CAA8C,EAAE,IAFU;AAG1DC,EAAAA,MAAM,EAAE;AAHkD,CAA5D;;AAKO,MAAMC,wBAAN,CAA+B;AACpCC,EAAAA,WAAW,CAASC,kBAAT,EAAqD;AAAA,SAA5CA,kBAA4C,GAA5CA,kBAA4C;AAAE;;AAExC,QAApBC,oBAAoB,CACxBC,IADwB,EAExBC,OAFwB,EAGxBC,UAHwB,EAIxBC,OAJwB,EAKxBC,UALwB,EAMxBC,OAAoC,GAAGb,sBANf,EAOI;AAC5B;AACA,UAAMc,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBhB,sBAAlB,EAA0Ca,OAA1C,CAAzB;AACA,UAAMI,wBAAkD,GAAG,MAAM,KAAKC,6BAAL,CAC/DN,UAD+D,EAE/DE,gBAAgB,CAACb,6BAF8C,EAG/DS,UAH+D,EAI/DI,gBAAgB,CAACK,kBAJ8C,CAAjE;AAMA,QAAIC,mBAAmB,GAAG,8CAA1B;;AACA,QAAIP,OAAO,CAACV,MAAZ,EAAoB;AAClBiB,MAAAA,mBAAmB,GAAG,oCAAmBV,UAAnB,EAA+BO,wBAA/B,CAAtB;AACD,KAFD,MAEO;AACLG,MAAAA,mBAAmB,CAACC,gBAApB,GAAuCX,UAAU,CAACY,UAAX,EAAvC;AACAF,MAAAA,mBAAmB,CAACH,wBAApB,GAA+CA,wBAA/C;AACD;;AACD,UAAMM,QAAQ,GAAG,MAAM,KAAKC,kBAAL,CAAwBZ,UAAxB,CAAvB;AACA,UAAMa,sBAAsB,GAAGC,sBAAsB,CACnDN,mBADmD,EAEnDR,UAFmD,EAGnDE,gBAAgB,CAACZ,8CAHkC,CAArD;AAKA,UAAMyB,iBAAiB,GAAG,KAAIC,sCAAJ,EACxBpB,IADwB,EAExBC,OAFwB,EAGxBW,mBAAmB,CAACC,gBAHI,EAIxBE,QAJwB,EAKxBZ,OALwB,EAMxBc,sBANwB,CAA1B;AAQA,WAAOE,iBAAP;AACD;;AAE+B,QAAlBH,kBAAkB,CAACZ,UAAD,EAA0B;AACxD,UAAMiB,SAAsB,GAAG,MAAMC,OAAO,CAACC,GAAR,CACnCnB,UAAU,CAACoB,GAAX,CAAgBC,SAAD,IAAe,KAAK3B,kBAAL,CAAwB4B,qBAAxB,CAA8CD,SAA9C,CAA9B,CADmC,CAArC;AAGA,UAAME,aAAa,GAAGN,SAAS,CAACG,GAAV,CAAeI,MAAD,IAAYA,MAAM,CAACC,qBAAjC,CAAtB,CAJwD,CAKxD;AACA;;AACA,UAAMC,cAAc,GAAGC,gCAAsBC,YAAtB,CAAmCL,aAAnC,CAAvB;;AACA,WAAOG,cAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AAC6C,QAA7BpB,6BAA6B,CACzCN,UADyC,EAEzCX,6BAA6B,GAAG,IAFS,EAGzCS,UAHyC,EAIzCS,kBAJyC,EAKN;AACnC,UAAMsB,aAAa,GAAG7B,UAAU,CAACoB,GAAX,CAAe,MAAOC,SAAP,IAAqB;AACxD,YAAMS,WAAW,GAAG,yCAAyBT,SAAS,CAACU,KAAV,CAAgBC,SAAzC,CAApB;AACA,UAAIC,OAAO,GAAG,MAAM,KAAKvC,kBAAL,CAAwBwC,eAAxB,CAAwCb,SAAxC,CAApB;AACA,YAAMc,eAAe,GAAG,MAAM,KAAKzC,kBAAL,CAAwB0C,SAAxB,CAAkCf,SAAlC,CAA9B;;AACA,UAAIhC,6BAAJ,EAAmC;AACjC4C,QAAAA,OAAO,GAAGI,gBAAgB,CAACJ,OAAD,EAAUjC,UAAV,CAA1B;AACD;;AACDiC,MAAAA,OAAO,GAAGK,qBAAqB,CAACL,OAAD,EAAUE,eAAV,CAA/B,CAPwD,CAQxD;;AACAF,MAAAA,OAAO,GAAGA,OAAO,CAACM,MAAR,CAAgBC,GAAD,IAASA,GAAG,CAACC,EAAJ,KAAW,iBAAnC,CAAV;;AACA,UAAIlC,kBAAJ,EAAwB;AACtB0B,QAAAA,OAAO,GAAG1B,kBAAkB,CAAC0B,OAAD,CAA5B;AACD;;AACD,YAAM,KAAKS,0BAAL,CAAgCrB,SAAhC,EAA2CvB,UAA3C,EAAuDmC,OAAvD,CAAN;AACA,YAAMU,WAAW,GAAG,MAAMV,OAAO,CAACW,sBAAR,EAA1B;AAEA,aAAO;AAAEd,QAAAA,WAAF;AAAea,QAAAA;AAAf,OAAP;AACD,KAjBqB,CAAtB;AAkBA,UAAME,MAAM,GAAG,IAAIC,GAAJ,EAAf;;AAEA,QAAIjB,aAAa,CAACkB,MAAlB,EAA0B;AACxB,YAAMC,OAAO,GAAG,MAAM9B,OAAO,CAACC,GAAR,CAAYU,aAAZ,CAAtB;AACAmB,MAAAA,OAAO,CAACC,OAAR,CAAiBC,UAAD,IAAgB;AAC9BL,QAAAA,MAAM,CAACM,GAAP,CAAWD,UAAU,CAACpB,WAAtB,EAAmCoB,UAAU,CAACP,WAA9C;AACD,OAFD;AAGD;;AAED,WAAOE,MAAP;AACD;;AAEuC,QAA1BH,0BAA0B,CACtCrB,SADsC,EAEtCvB,UAFsC,EAGtCsD,cAHsC,EAIvB;AACf,UAAM1B,cAAc,GAAG,MAAM,KAAKhC,kBAAL,CAAwB2D,oBAAxB,CAA6ChC,SAAS,CAACiC,MAAV,CAAiBC,UAA9D,CAA7B;AACAH,IAAAA,cAAc,CAACH,OAAf,CAAwBT,GAAD,IAAS;AAC9B,8DAAwBA,GAAxB,EAA6B1C,UAA7B,EAAyC4B,cAAzC;AACD,KAFD;AAGD;;AA1GmC;;;;AA6GtC,SAASW,gBAAT,CAA0Be,cAA1B,EAA0DI,qBAA1D,EAA8G;AAC5G,QAAMC,QAAQ,GAAGL,cAAc,CAACb,MAAf,CAAuBC,GAAD,IAAS;AAC9C;AACA,QAAI,EAAEA,GAAG,YAAYkB,mCAAjB,CAAJ,EAA2C;AACzC,aAAO,IAAP;AACD,KAJ6C,CAK9C;;;AACA,QAAI,CAAClB,GAAG,CAACmB,WAAJ,CAAgBC,UAAhB,EAAL,EAAmC,OAAO,KAAP;AACnC,UAAMC,iBAAiB,GAAGL,qBAAqB,CAACM,IAAtB,CAA4BzC,SAAD,IAAe;AAClE;AACA,UAAI,CAACA,SAAS,CAACoB,EAAV,CAAamB,UAAb,EAAL,EAAgC;AAC9B,eAAOvC,SAAS,CAACoB,EAAV,CAAasB,QAAb,OAA4BvB,GAAG,CAACmB,WAAJ,CAAgBI,QAAhB,CAAyB;AAAEC,UAAAA,aAAa,EAAE;AAAjB,SAAzB,CAAnC;AACD,OAJiE,CAKlE;AACA;AACA;AACA;;;AACA,aACE3C,SAAS,CAACoB,EAAV,CAAawB,OAAb,CAAqBC,OAArB,CAA6B1B,GAAG,CAACmB,WAAJ,CAAgBM,OAA7C,KACA5C,SAAS,CAACU,KAAV,CAAgBC,SAAhB,CAA0BS,EAA1B,CAA6ByB,OAA7B,CAAqC1B,GAAG,CAACmB,WAAJ,CAAgBM,OAArD,CAFF;AAID,KAbyB,CAA1B;AAcA,QAAIJ,iBAAJ,EAAuB,OAAO,KAAP;AACvB,WAAO,IAAP;AACD,GAvBgB,CAAjB;AAwBA,SAAOJ,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASnB,qBAAT,CAA+Bc,cAA/B,EAA+DjB,eAA/D,EAA+G;AAC7G,QAAMsB,QAAQ,GAAGL,cAAc,CAACb,MAAf,CAAuBC,GAAD,IAAS;AAC9C,UAAM2B,UAAU,GAAGhC,eAAe,CAAC2B,IAAhB,CAAqBtB,GAAG,CAACC,EAAzB,CAAnB;;AACA,QAAI,CAAC0B,UAAL,EAAiB;AACf,aAAO,IAAP;AACD;;AACD,QAAIA,UAAU,CAACC,KAAX,CAAiBC,cAArB,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD,GATgB,CAAjB;AAUA,SAAOZ,QAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS3C,sBAAT,CACEN,mBADF,EAEER,UAFF,EAGEV,8CAA8C,GAAG,IAHnD,EAI0B;AACxB,QAAMgF,mBAA2C,GAAG,IAAIxB,GAAJ,EAApD;AACA9C,EAAAA,UAAU,CAACiD,OAAX,CAAoB5B,SAAD,IAAe;AAChC,UAAMS,WAAW,GAAG,yCAAyBT,SAAS,CAACU,KAAV,CAAgBC,SAAzC,CAApB;;AACA,QACExB,mBAAmB,CAACH,wBAApB,CAA6CkE,GAA7C,CAAiDzC,WAAjD,KACAxC,8CAFF,EAGE;AACA,YAAMkF,iBAA6C,GAAG;AACpDC,QAAAA,YAAY,EAAE,EADsC;AAEpDC,QAAAA,eAAe,EAAE,EAFmC;AAGpDC,QAAAA,gBAAgB,EAAE;AAHkC,OAAtD;AAKA,UAAIF,YAAY,GAAGD,iBAAnB;;AACA,UAAIhE,mBAAmB,CAACH,wBAApB,CAA6CkE,GAA7C,CAAiDzC,WAAjD,CAAJ,EAAmE;AACjE2C,QAAAA,YAAY,GAAGjE,mBAAmB,CAACH,wBAApB,CAA6CuE,GAA7C,CAAiD9C,WAAjD,CAAf;AACD;;AAED,YAAM+C,UAAU,GAAG,MAAc;AAC/B,YAAI,CAACxD,SAAS,CAACoB,EAAV,CAAamB,UAAb,EAAL,EAAgC,OAAO,WAAP;AAChC,YAAIvC,SAAS,CAACoB,EAAV,CAAawB,OAAb,CAAqBa,aAArB,EAAJ,EAA0C,OAAQ,SAAQzD,SAAS,CAACoB,EAAV,CAAa5C,OAAQ,EAArC;AAC1C,eAAOwB,SAAS,CAACoB,EAAV,CAAa5C,OAApB;AACD,OAJD;;AAMA,YAAMA,OAAO,GAAGgF,UAAU,EAA1B;AACA,YAAME,QAAQ,GAAG,KAAIC,sCAAJ,EAAsBlD,WAAtB,EAAmC,KAAImD,gBAAJ,EAAWpF,OAAX,CAAnC,EAAwD4E,YAAxD,EAAsEpD,SAAtE,CAAjB;AACAiD,MAAAA,mBAAmB,CAACnB,GAApB,CAAwBrB,WAAxB,EAAqCiD,QAArC;AACD;AACF,GA1BD;AA2BA,SAAOT,mBAAP;AACD","sourcesContent":["import { Component } from '@teambit/component';\nimport componentIdToPackageName from '@teambit/legacy/dist/utils/bit/component-id-to-package-name';\nimport { SemVer } from 'semver';\nimport { ComponentDependency, DependencyList, PackageName } from '../dependencies';\nimport { VariantPolicy, WorkspacePolicy, EnvPolicy, PeersAutoDetectPolicy } from '../policy';\n\nimport { DependencyResolverMain } from '../dependency-resolver.main.runtime';\nimport { ComponentsManifestsMap } from '../types';\nimport { ComponentManifest } from './component-manifest';\nimport { DedupedDependencies, dedupeDependencies, getEmptyDedupedDependencies } from './deduping';\nimport { ManifestToJsonOptions, ManifestDependenciesObject } from './manifest';\nimport { updateDependencyVersion } from './update-dependency-version';\nimport { WorkspaceManifest } from './workspace-manifest';\n\nexport type DepsFilterFn = (dependencies: DependencyList) => DependencyList;\n\nexport type ComponentDependenciesMap = Map<PackageName, ManifestDependenciesObject>;\nexport interface WorkspaceManifestToJsonOptions extends ManifestToJsonOptions {\n  includeDir?: boolean;\n}\n\nexport type CreateFromComponentsOptions = {\n  filterComponentsFromManifests: boolean;\n  createManifestForComponentsWithoutDependencies: boolean;\n  dedupe?: boolean;\n  dependencyFilterFn?: DepsFilterFn;\n};\n\nconst DEFAULT_CREATE_OPTIONS: CreateFromComponentsOptions = {\n  filterComponentsFromManifests: true,\n  createManifestForComponentsWithoutDependencies: true,\n  dedupe: true,\n};\nexport class WorkspaceManifestFactory {\n  constructor(private dependencyResolver: DependencyResolverMain) {}\n\n  async createFromComponents(\n    name: string,\n    version: SemVer,\n    rootPolicy: WorkspacePolicy,\n    rootDir: string,\n    components: Component[],\n    options: CreateFromComponentsOptions = DEFAULT_CREATE_OPTIONS\n  ): Promise<WorkspaceManifest> {\n    // Make sure to take other default if passed options with only one option\n    const optsWithDefaults = Object.assign({}, DEFAULT_CREATE_OPTIONS, options);\n    const componentDependenciesMap: ComponentDependenciesMap = await this.buildComponentDependenciesMap(\n      components,\n      optsWithDefaults.filterComponentsFromManifests,\n      rootPolicy,\n      optsWithDefaults.dependencyFilterFn\n    );\n    let dedupedDependencies = getEmptyDedupedDependencies();\n    if (options.dedupe) {\n      dedupedDependencies = dedupeDependencies(rootPolicy, componentDependenciesMap);\n    } else {\n      dedupedDependencies.rootDependencies = rootPolicy.toManifest();\n      dedupedDependencies.componentDependenciesMap = componentDependenciesMap;\n    }\n    const envPeers = await this.getEnvsPeersPolicy(components);\n    const componentsManifestsMap = getComponentsManifests(\n      dedupedDependencies,\n      components,\n      optsWithDefaults.createManifestForComponentsWithoutDependencies\n    );\n    const workspaceManifest = new WorkspaceManifest(\n      name,\n      version,\n      dedupedDependencies.rootDependencies,\n      envPeers,\n      rootDir,\n      componentsManifestsMap\n    );\n    return workspaceManifest;\n  }\n\n  private async getEnvsPeersPolicy(components: Component[]) {\n    const foundEnvs: EnvPolicy[] = await Promise.all(\n      components.map((component) => this.dependencyResolver.getComponentEnvPolicy(component))\n    );\n    const peersPolicies = foundEnvs.map((policy) => policy.peersAutoDetectPolicy);\n    // TODO: At the moment we are just merge everything, so in case of conflicts one will be taken\n    // TODO: once we have root for each env, we should know to handle it differently\n    const mergedPolicies = PeersAutoDetectPolicy.mergePolices(peersPolicies);\n    return mergedPolicies;\n  }\n\n  /**\n   * Get the components and build a map with the package name (from the component) as key and the dependencies as values\n   *\n   * @param {Component[]} components\n   * @param {boolean} [filterComponentsFromManifests=true] - filter existing components from the dep graphs\n   * @returns\n   */\n  private async buildComponentDependenciesMap(\n    components: Component[],\n    filterComponentsFromManifests = true,\n    rootPolicy: WorkspacePolicy,\n    dependencyFilterFn?: DepsFilterFn\n  ): Promise<ComponentDependenciesMap> {\n    const buildResultsP = components.map(async (component) => {\n      const packageName = componentIdToPackageName(component.state._consumer);\n      let depList = await this.dependencyResolver.getDependencies(component);\n      const componentPolicy = await this.dependencyResolver.getPolicy(component);\n      if (filterComponentsFromManifests) {\n        depList = filterComponents(depList, components);\n      }\n      depList = filterResolvedFromEnv(depList, componentPolicy);\n      // Remove bit bin from dep list\n      depList = depList.filter((dep) => dep.id !== '@teambit/legacy');\n      if (dependencyFilterFn) {\n        depList = dependencyFilterFn(depList);\n      }\n      await this.updateDependenciesVersions(component, rootPolicy, depList);\n      const depManifest = await depList.toDependenciesManifest();\n\n      return { packageName, depManifest };\n    });\n    const result = new Map<PackageName, ManifestDependenciesObject>();\n\n    if (buildResultsP.length) {\n      const results = await Promise.all(buildResultsP);\n      results.forEach((currResult) => {\n        result.set(currResult.packageName, currResult.depManifest);\n      });\n    }\n\n    return result;\n  }\n\n  private async updateDependenciesVersions(\n    component: Component,\n    rootPolicy: WorkspacePolicy,\n    dependencyList: DependencyList\n  ): Promise<void> {\n    const mergedPolicies = await this.dependencyResolver.mergeVariantPolicies(component.config.extensions);\n    dependencyList.forEach((dep) => {\n      updateDependencyVersion(dep, rootPolicy, mergedPolicies);\n    });\n  }\n}\n\nfunction filterComponents(dependencyList: DependencyList, componentsToFilterOut: Component[]): DependencyList {\n  const filtered = dependencyList.filter((dep) => {\n    // Do not filter non components (like packages) dependencies\n    if (!(dep instanceof ComponentDependency)) {\n      return true;\n    }\n    // Remove dependencies which has no version (they are new in the workspace)\n    if (!dep.componentId.hasVersion()) return false;\n    const existingComponent = componentsToFilterOut.find((component) => {\n      // For new components, the component has no version but the dependency id has version 0.0.1\n      if (!component.id.hasVersion()) {\n        return component.id.toString() === dep.componentId.toString({ ignoreVersion: true });\n      }\n      // We are checking against both component.id._legacy and component.state._consumer.id\n      // Because during tag operation, the component.id._legacy has the current version (before the tag)\n      // while the component.state._consumer.id has the upcoming version (the version that will be after the tag)\n      // The dependency in some cases is already updated to the upcoming version\n      return (\n        component.id._legacy.isEqual(dep.componentId._legacy) ||\n        component.state._consumer.id.isEqual(dep.componentId._legacy)\n      );\n    });\n    if (existingComponent) return false;\n    return true;\n  });\n  return filtered;\n}\n\n/**\n * Filter deps which should be resolved from the env, we don't want to install them, they will be linked manually later\n * @param dependencyList\n * @param componentPolicy\n */\nfunction filterResolvedFromEnv(dependencyList: DependencyList, componentPolicy: VariantPolicy): DependencyList {\n  const filtered = dependencyList.filter((dep) => {\n    const fromPolicy = componentPolicy.find(dep.id);\n    if (!fromPolicy) {\n      return true;\n    }\n    if (fromPolicy.value.resolveFromEnv) {\n      return false;\n    }\n    return true;\n  });\n  return filtered;\n}\n\n/**\n * Get the components manifests based on the calculated dedupedDependencies\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {Component[]} components\n * @returns {ComponentsManifestsMap}\n */\nfunction getComponentsManifests(\n  dedupedDependencies: DedupedDependencies,\n  components: Component[],\n  createManifestForComponentsWithoutDependencies = true\n): ComponentsManifestsMap {\n  const componentsManifests: ComponentsManifestsMap = new Map();\n  components.forEach((component) => {\n    const packageName = componentIdToPackageName(component.state._consumer);\n    if (\n      dedupedDependencies.componentDependenciesMap.has(packageName) ||\n      createManifestForComponentsWithoutDependencies\n    ) {\n      const blankDependencies: ManifestDependenciesObject = {\n        dependencies: {},\n        devDependencies: {},\n        peerDependencies: {},\n      };\n      let dependencies = blankDependencies;\n      if (dedupedDependencies.componentDependenciesMap.has(packageName)) {\n        dependencies = dedupedDependencies.componentDependenciesMap.get(packageName) as ManifestDependenciesObject;\n      }\n\n      const getVersion = (): string => {\n        if (!component.id.hasVersion()) return '0.0.1-new';\n        if (component.id._legacy.isVersionSnap()) return `0.0.1-${component.id.version}`;\n        return component.id.version as string;\n      };\n\n      const version = getVersion();\n      const manifest = new ComponentManifest(packageName, new SemVer(version), dependencies, component);\n      componentsManifests.set(packageName, manifest);\n    }\n  });\n  return componentsManifests;\n}\n"]}