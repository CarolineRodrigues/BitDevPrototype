{"version":3,"sources":["hoist-dependencies.ts"],"names":["hoistDependencies","depIdIndex","result","getEmptyDedupedDependencies","forEach","indexItem","packageName","toContinue","handlePreserved","addOneOccurrenceToRoot","componentItems","handlePeersOnly","groupedByRangeOrVersion","groupByRangeOrVersion","versions","length","ranges","handleExactVersionsOnly","handleRangesOnly","handleRangesAndVersions","dedupedDependencies","preservedVersion","metadata","preservedLifecycleType","keyName","KEY_NAME_BY_LIFECYCLE_TYPE","rootDependencies","filterFunc","item","intersectNoThrow","range","map","addToComponentDependenciesMapInDeduped","indexItems","lifecycleType","nonPeerItems","filter","PEER_DEP_LIFECYCLE_TYPE","allRanges","e","conflictedComponents","componentPackageName","origin","issue","conflictMessage","message","issus","peerConflicts","push","allVersions","mostCommonVersion","findMostCommonVersion","version","lifeCycleType","getLifecycleType","depKeyName","rangesVersions","bestRange","findBestRange","intersectedRange","includes","groups","count","sortedByTotal","getSortedRangesCombination","i","combinationWithTotal","combination","total","counts","uniqRanges","rangesCombinations","arrayCombinations","countMultipleRanges","items","reduce","acc","curr","rangesCombinationsWithTotalCount","reverse","DEV_DEP_LIFECYCLE_TYPE","RUNTIME_DEP_LIFECYCLE_TYPE","toFilter","compEntry","componentDependenciesMap","get","dependencies","devDependencies","peerDependencies","Object","assign","set","parsed","semver","validRange","condition","array","fn","n","src","got","all","j","slice","concat","Map","args","undefined"],"mappings":"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","sourcesContent":["import forEachObjIndexed from 'ramda/src/forEachObjIndexed';\nimport { countBy, property, sortBy, uniq } from 'lodash';\nimport semver from 'semver';\nimport { intersect, parseRange } from 'semver-intersect';\n\nimport {\n  DEV_DEP_LIFECYCLE_TYPE,\n  KEY_NAME_BY_LIFECYCLE_TYPE,\n  PEER_DEP_LIFECYCLE_TYPE,\n  RUNTIME_DEP_LIFECYCLE_TYPE,\n} from '../../dependencies/constants';\nimport { ManifestDependenciesObject } from '../manifest';\nimport { DependencyLifecycleType, SemverVersion, PackageName } from '../../dependencies';\nimport { DedupedDependencies, DedupedDependenciesPeerConflicts } from './dedupe-dependencies';\nimport { PackageNameIndex, PackageNameIndexItem, PackageNameIndexComponentItem } from './index-by-dep-id';\n\ntype ItemsGroupedByRangeOrVersion = {\n  ranges: PackageNameIndexComponentItem[];\n  versions: PackageNameIndexComponentItem[];\n};\n\ntype MostCommonVersion = {\n  version: SemverVersion;\n  count: number;\n};\n\ntype BestRange = {\n  count: number;\n  ranges: SemverVersion[];\n  intersectedRange: SemverVersion;\n};\n\ntype CombinationWithTotal = {\n  combination: SemverVersion[];\n  total: number;\n};\n\n/**\n * This is the second phase of the deduping process.\n * It will get the index calculated in the first phase (with dep id as key)\n * and will find the most intersect range for each dep and move it to the root\n * it will also move deps which are both dev deps and runtime deps to be runtime deps\n *\n * @param {PackageNameIndex} depIdIndex\n * @returns {DedupedDependencies}\n */\nexport function hoistDependencies(depIdIndex: PackageNameIndex): DedupedDependencies {\n  const result: DedupedDependencies = getEmptyDedupedDependencies();\n\n  // TODO: handle git urls\n\n  depIdIndex.forEach((indexItem, packageName) => {\n    let toContinue;\n    toContinue = handlePreserved(result, packageName, indexItem);\n    if (!toContinue) return;\n    toContinue = addOneOccurrenceToRoot(result, packageName, indexItem.componentItems);\n    if (!toContinue) return;\n    toContinue = handlePeersOnly(result, packageName, indexItem.componentItems);\n    if (!toContinue) return;\n    const groupedByRangeOrVersion = groupByRangeOrVersion(indexItem.componentItems);\n    if (groupedByRangeOrVersion.versions.length > 0 && groupedByRangeOrVersion.ranges.length === 0) {\n      handleExactVersionsOnly(result, packageName, indexItem.componentItems);\n    } else if (groupedByRangeOrVersion.versions.length === 0 && groupedByRangeOrVersion.ranges.length > 0) {\n      handleRangesOnly(result, packageName, indexItem.componentItems);\n    } else {\n      handleRangesAndVersions(result, packageName, indexItem.componentItems, groupedByRangeOrVersion);\n    }\n  });\n\n  return result;\n}\n\nfunction handlePreserved(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItem: PackageNameIndexItem\n): boolean {\n  const preservedVersion = indexItem.metadata.preservedVersion;\n  // Not preserved, move on\n  if (!preservedVersion) {\n    return true;\n  }\n\n  const preservedLifecycleType = indexItem.metadata.preservedLifecycleType;\n\n  const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[preservedLifecycleType || 'dependencies'];\n  dedupedDependencies.rootDependencies[keyName][packageName] = preservedVersion;\n\n  const filterFunc = (item: PackageNameIndexComponentItem) => {\n    // items which are intersect with the preserved version won't needed to be installed nested in the component\n    // this in very rare cases might create bugs in case the version are intersects, but the real version in the registry\n    // which satisfies the preserved not satisfy the item range.\n    // In such case I would expect to get version not exist when coming to install the version in the nested component\n    return !!intersectNoThrow(item.range, preservedVersion);\n  };\n\n  indexItem.componentItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n  return false;\n}\n\n/**\n * In case there is only one component with a specific dependency, add it to the root if it's not peer\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem} indexItem\n */\nfunction addOneOccurrenceToRoot(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): boolean {\n  if (indexItems.length > 1) {\n    return true;\n  }\n  const indexItem = indexItems[0];\n  // if (indexItem.lifecycleType !== PEER_DEP_LIFECYCLE_TYPE) {\n  const keyName = KEY_NAME_BY_LIFECYCLE_TYPE[indexItem.lifecycleType];\n  dedupedDependencies.rootDependencies[keyName][packageName] = indexItem.range;\n  return false;\n  // }\n  // return true;\n}\n\n/**\n * Handle a case where the package appear as a peer for all its deponents\n * in that case we won't hoist it to the root, we will only notify about conflicts\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @returns {boolean}\n */\nfunction handlePeersOnly(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): boolean {\n  const nonPeerItems = indexItems.filter((item) => {\n    return item.lifecycleType !== PEER_DEP_LIFECYCLE_TYPE;\n  });\n  if (nonPeerItems.length > 0) {\n    return true;\n  }\n  const allRanges = indexItems.map((item) => item.range);\n  try {\n    intersect(...allRanges);\n    // Add to peers for each component to make sure we are getting warning from the package manager about missing peers\n    indexItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName));\n  } catch (e: any) {\n    indexItems.map(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName));\n    // There are peer version with conflicts, let the user know about it\n    const conflictedComponents = indexItems.map((item) => {\n      return {\n        componentPackageName: item.origin,\n        range: item.range,\n      };\n    });\n    const issue: DedupedDependenciesPeerConflicts = {\n      packageName,\n      conflictedComponents,\n      conflictMessage: e.message,\n    };\n    dedupedDependencies.issus?.peerConflicts.push(issue);\n  }\n  return false;\n}\n\n/**\n * This will handle a case when there is only exact version in the index\n * In such case it will take the most common version and hoist it to the root\n * It will set all the other version in the corresponding components\n * This assume the items has been already checked to contain only exact versions\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n */\nfunction handleExactVersionsOnly(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): void {\n  const allVersions = indexItems.map((item) => item.range);\n\n  // Add most common version to root\n  const mostCommonVersion = findMostCommonVersion(allVersions).version;\n  const lifeCycleType = getLifecycleType(indexItems);\n  const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];\n  dedupedDependencies.rootDependencies[depKeyName][packageName] = mostCommonVersion;\n\n  const filterFunc = (item) => {\n    if (item.range === mostCommonVersion) return true;\n    return false;\n  };\n\n  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n}\n\n/**\n * This will handle a case when there is only ranges in the index\n * In such case it will search for an intersection with the most components and hoist it to the root\n * It will set all the other ranges in the corresponding components\n * This assume the items has been already checked to contain only ranges\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n */\nfunction handleRangesOnly(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[]\n): void {\n  const rangesVersions = indexItems.map((item) => item.range);\n  const bestRange = findBestRange(rangesVersions);\n  const lifeCycleType = getLifecycleType(indexItems);\n  const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];\n  dedupedDependencies.rootDependencies[depKeyName][packageName] = bestRange.intersectedRange;\n\n  indexItems.forEach((item) => {\n    if (bestRange.ranges.includes(item.range)) return;\n    addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName)(item);\n  });\n\n  const filterFunc = (item) => {\n    if (bestRange.ranges.includes(item.range)) return true;\n    return false;\n  };\n\n  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n}\n\n/**\n * This will handle a case when there is both ranges and exact versions in the index\n * it will find the best range and see how many components it fits\n * it will find the most common version and see how many components it fits\n * Then it will take the best of them and hoist into the root and put others in the components\n * TODO: this can be improved by adding to the ranges count the satisfying exact versions\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @param {ItemsGroupedByRangeOrVersion} groups\n */\nfunction handleRangesAndVersions(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  indexItems: PackageNameIndexComponentItem[],\n  groups: ItemsGroupedByRangeOrVersion\n): void {\n  const allVersions = groups.versions.map((item) => item.range);\n  const mostCommonVersion = findMostCommonVersion(allVersions);\n  // Include versions here since we might have a specific version which match the best version as well\n  const rangesVersions = indexItems.map((item) => item.range);\n  const bestRange = findBestRange(rangesVersions);\n  const lifeCycleType = getLifecycleType(indexItems);\n  const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[lifeCycleType];\n\n  let filterFunc = (item) => {\n    if (bestRange.ranges.includes(item.range)) return true;\n    return false;\n  };\n\n  if (bestRange.count < mostCommonVersion.count) {\n    dedupedDependencies.rootDependencies[depKeyName][packageName] = mostCommonVersion.version;\n    filterFunc = (item) => {\n      if (item.range === mostCommonVersion) return true;\n      return false;\n    };\n  } else {\n    dedupedDependencies.rootDependencies[depKeyName][packageName] = bestRange.intersectedRange;\n  }\n  indexItems.forEach(addToComponentDependenciesMapInDeduped(dedupedDependencies, packageName, filterFunc));\n}\n\n/**\n * Finding the best range - a range the intersect as many ranges as possible\n * it will work by create all the possible combination of the ranges\n * then try to intersect them based on the number of the ranges (items) and how many times they appear in the original array\n *\n * @param {SemverVersion[]} ranges\n * @returns {BestRange}\n */\nfunction findBestRange(ranges: SemverVersion[]): BestRange {\n  const result: BestRange = {\n    ranges: [],\n    intersectedRange: '0.0.0',\n    count: 0,\n  };\n\n  const sortedByTotal = getSortedRangesCombination(ranges);\n  let i = 0;\n  // Since it's already sorted by count, once we found match we can stop looping\n  while (result.count === 0 && i < sortedByTotal.length) {\n    const combinationWithTotal = sortedByTotal[i];\n    try {\n      const intersectedRange = intersect(...combinationWithTotal.combination);\n      result.intersectedRange = intersectedRange;\n      result.ranges = combinationWithTotal.combination;\n      result.count = combinationWithTotal.total;\n      // eslint-disable-next-line\n    } catch (e: any) {}\n    i += 1;\n  }\n  return result;\n}\n\n// function getSortedVersionsWithTotal(versions: SemverVersion[]): VersionWithTotal[] {\n//   const counts = countBy((item) => item)(versions);\n//   const uniqVersions = uniq(versions);\n//   const versionsWithTotalCount = uniqVersions.map((version) => {\n//     return {\n//       version,\n//       total: counts[version],\n//     };\n//   });\n\n//   const sortByTotal = sortBy(prop('total'));\n//   const sortedByTotal = sortByTotal(versionsWithTotalCount).reverse();\n//   return sortedByTotal;\n// }\n\nfunction getSortedRangesCombination(ranges: SemverVersion[]): CombinationWithTotal[] {\n  const counts = countBy(ranges, (item) => item);\n  const uniqRanges = uniq(ranges);\n  const rangesCombinations = arrayCombinations<SemverVersion>(uniqRanges);\n  const countMultipleRanges = (items: SemverVersion[]): number => {\n    return items.reduce((acc, curr) => {\n      return acc + counts[curr];\n    }, 0);\n  };\n  // The count is count of the items and for each item how many times it appear in the original ranges\n  // Since there might be same range multiple time in the original ranges array.\n\n  const rangesCombinationsWithTotalCount = rangesCombinations.map((combination) => {\n    return {\n      combination,\n      total: countMultipleRanges(combination),\n    };\n  });\n\n  const sortedByTotal = sortBy(rangesCombinationsWithTotalCount, property('total')).reverse();\n  return sortedByTotal;\n}\n\n/**\n * Check if a package should be a dev dependency or runtime dependency by checking if it appears as runtime dependency at least once\n *\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @returns {DependencyLifecycleType}\n */\nfunction getLifecycleType(indexItems: PackageNameIndexComponentItem[]): DependencyLifecycleType {\n  let result: DependencyLifecycleType = DEV_DEP_LIFECYCLE_TYPE;\n  indexItems.forEach((item) => {\n    if (item.lifecycleType === RUNTIME_DEP_LIFECYCLE_TYPE) {\n      result = RUNTIME_DEP_LIFECYCLE_TYPE;\n    }\n  });\n  return result;\n}\n\n/**\n * Find the version that appears the most\n *\n * @param {SemverVersion[]} versions\n * @returns {MostCommonVersion}\n */\nfunction findMostCommonVersion(versions: SemverVersion[]): MostCommonVersion {\n  const counts = countBy(versions, (item) => item);\n  const result: MostCommonVersion = {\n    version: '0.0.0',\n    count: 0,\n  };\n  forEachObjIndexed((count, version) => {\n    if (count > result.count) {\n      result.version = version;\n      result.count = count;\n    }\n  }, counts);\n  return result;\n}\n\n/**\n * A wrapper function used to be passed to map on index items and add it to a component dependency in the deduped dependencies if it's filter function return false\n *\n * @param {DedupedDependencies} dedupedDependencies\n * @param {PackageName} packageName\n * @param {(item: PackageNameIndexComponentItem) => boolean} [filterFunc]\n * @returns\n */\nfunction addToComponentDependenciesMapInDeduped(\n  dedupedDependencies: DedupedDependencies,\n  packageName: PackageName,\n  filterFunc?: (item: PackageNameIndexComponentItem) => boolean\n) {\n  return (indexItem: PackageNameIndexComponentItem) => {\n    if (filterFunc && typeof filterFunc === 'function') {\n      const toFilter = filterFunc(indexItem);\n      if (toFilter) return;\n    }\n    let compEntry = dedupedDependencies.componentDependenciesMap.get(indexItem.origin);\n    const depKeyName = KEY_NAME_BY_LIFECYCLE_TYPE[indexItem.lifecycleType];\n    if (!compEntry) {\n      compEntry = {\n        dependencies: {},\n        devDependencies: {},\n        peerDependencies: {},\n      };\n    }\n    compEntry[depKeyName] = Object.assign({}, compEntry[depKeyName], { [packageName]: indexItem.range });\n    dedupedDependencies.componentDependenciesMap.set(indexItem.origin, compEntry);\n  };\n}\n\n/**\n * Get an array of index items and group them to items with ranges and items with exact version\n *\n * @param {PackageNameIndexComponentItem[]} indexItems\n * @returns {ItemsGroupedByRangeOrVersion}\n */\nfunction groupByRangeOrVersion(indexItems: PackageNameIndexComponentItem[]): ItemsGroupedByRangeOrVersion {\n  const result: ItemsGroupedByRangeOrVersion = {\n    ranges: [],\n    versions: [],\n  };\n  indexItems.forEach((item) => {\n    const parsed = parseRange(semver.validRange(item.range));\n    if (parsed.condition === '=') {\n      result.versions.push(item);\n      return;\n    }\n    result.ranges.push(item);\n  });\n  return result;\n}\n\n// Taken from https://web.archive.org/web/20140418004051/http://dzone.com/snippets/calculate-all-combinations\n/**\n * Return all combinations of array items. for example:\n * arrayCombinations([1,2]) == [[1], [2], [1,2]];\n *\n * @param {Array<T>} array\n * @returns {Array<T[]>}\n */\nfunction arrayCombinations<T>(array: Array<T>): Array<T[]> {\n  const fn = function (n, src, got, all) {\n    if (n === 0) {\n      if (got.length > 0) {\n        all[all.length] = got;\n      }\n      return;\n    }\n    // eslint-disable-next-line\n    for (let j = 0; j < src.length; j++) {\n      fn(n - 1, src.slice(j + 1), got.concat([src[j]]), all);\n    }\n  };\n  const all: Array<T[]> = [];\n  // eslint-disable-next-line\n  for (let i = 0; i < array.length; i++) {\n    fn(i, array, [], all);\n  }\n  all.push(array);\n  return all;\n}\n\nexport function getEmptyDedupedDependencies(): DedupedDependencies {\n  const result: DedupedDependencies = {\n    rootDependencies: {\n      dependencies: {},\n      devDependencies: {},\n      peerDependencies: {},\n    },\n    componentDependenciesMap: new Map<PackageName, ManifestDependenciesObject>(),\n    issus: {\n      peerConflicts: [],\n    },\n  };\n  return result;\n}\n\nfunction intersectNoThrow(...args): string | undefined {\n  try {\n    return intersect(...args);\n  } catch (e: any) {\n    return undefined;\n  }\n}\n"]}