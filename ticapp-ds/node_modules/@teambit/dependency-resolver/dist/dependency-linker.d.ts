import { ComponentMap, ComponentMain } from '@teambit/component';
import { Logger } from '@teambit/logger';
import { LinksResult as LegacyLinksResult } from '@teambit/legacy/dist/links/node-modules-linker';
import { CodemodResult } from '@teambit/legacy/dist/consumer/component-ops/codemod-components';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { EnvsMain } from '@teambit/envs';
import { AspectLoaderMain } from '@teambit/aspect-loader';
import { WorkspacePolicy } from './policy';
import { DependencyResolverMain } from './dependency-resolver.main.runtime';
export declare type LinkingOptions = {
    rewire?: boolean;
    /**
     * Whether to create link to @teambit/bit in the root node modules
     */
    linkTeambitBit?: boolean;
    /**
     * Whether to create links in the root dir node modules to all core aspects
     */
    linkCoreAspects?: boolean;
    linkNestedDepsInNM?: boolean;
    /**
     * link to another project, so that project could use components from this workspace.
     * similar to npm/yarn link
     */
    linkToDir?: string;
    /**
     * whether link should import objects before linking
     */
    fetchObject?: boolean;
    /**
     * make sure to provide the consumer
     */
    legacyLink?: boolean;
    /**
     * consumer is required for the legacyLink
     */
    consumer?: Consumer;
};
export declare type LinkDetail = {
    from: string;
    to: string;
};
export declare type CoreAspectLinkResult = {
    aspectId: string;
    linkDetail: LinkDetail;
};
export declare type DepsLinkedToEnvResult = {
    componentId: string;
    linksDetail: LinkDetail[];
};
export declare type NestedNMDepsLinksResult = {
    componentId: string;
    linksDetail: LinkDetail[];
};
export declare type LinkToDirResult = {
    componentId: string;
    linksDetail: LinkDetail;
};
export declare type LinkResults = {
    legacyLinkResults?: LegacyLinksResult[];
    legacyLinkCodemodResults?: CodemodResult[];
    teambitBitLink?: CoreAspectLinkResult;
    coreAspectsLinks?: CoreAspectLinkResult[];
    harmonyLink?: LinkDetail;
    teambitLegacyLink?: LinkDetail;
    resolvedFromEnvLinks?: DepsLinkedToEnvResult[];
    nestedDepsInNmLinks?: NestedNMDepsLinksResult[];
    linkToDirResults?: LinkToDirResult[];
};
export declare class DependencyLinker {
    private dependencyResolver;
    private aspectLoader;
    private componentAspect;
    private envs;
    private logger;
    private rootDir?;
    private linkingOptions?;
    constructor(dependencyResolver: DependencyResolverMain, aspectLoader: AspectLoaderMain, componentAspect: ComponentMain, envs: EnvsMain, logger: Logger, rootDir?: string | undefined, linkingOptions?: LinkingOptions | undefined);
    link(rootDir: string | undefined, rootPolicy: WorkspacePolicy, componentDirectoryMap: ComponentMap<string>, options?: LinkingOptions): Promise<LinkResults>;
    private linkToDir;
    /**
     * add symlink from the node_modules in the component's root-dir to the workspace node-modules
     * of the component. e.g.
     * ws-root/node_modules/comp1/node_modules -> ws-root/components/comp1/node_modules
     */
    private addSymlinkFromComponentDirNMToWorkspaceDirNM;
    private linkDepsResolvedFromEnv;
    private linkBitAspectIfNotExist;
    linkBit(dir: string): Promise<LinkDetail | undefined>;
    linkCoreAspects(dir: string): Promise<Array<CoreAspectLinkResult | undefined>>;
    private linkNonExistingCoreAspects;
    private isBitRepoWorkspace;
    private linkCoreAspect;
    /**
     * returns true if it's safe to symlink it later.
     */
    private removeSymlinkTarget;
    private linkNonAspectCorePackages;
    private linkHarmony;
    private linkTeambitLegacy;
}
