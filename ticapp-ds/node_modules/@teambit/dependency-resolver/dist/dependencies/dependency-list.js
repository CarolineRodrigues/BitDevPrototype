"use strict";

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DependencyList = void 0;

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("./constants");

  _constants = function () {
    return data;
  };

  return data;
}

class DependencyList {
  constructor(_dependencies) {
    this._dependencies = _dependencies;
    this._dependencies = uniqDeps(_dependencies);
  } // constructor(private _dependencies: Dependency[]){}


  get dependencies() {
    return this._dependencies;
  }
  /**
   * @param componentIdStr complete string include the scope and the version
   */


  findDependency(componentIdStr, opts = {}) {
    const ignoreVersion = opts.ignoreVersion;

    if (!ignoreVersion) {
      return this.dependencies.find(dep => dep.id === componentIdStr);
    }

    const componentIdStrWithoutVersion = removeVersion(componentIdStr);
    return this.dependencies.find(dep => removeVersion(dep.id) === componentIdStrWithoutVersion);
  }

  forEach(predicate) {
    this.dependencies.forEach(predicate);
  }

  map(predicate) {
    return this.dependencies.map(predicate);
  }

  filter(predicate) {
    const filtered = this.dependencies.filter(predicate);
    return DependencyList.fromArray(filtered);
  }

  toTypeArray(typeName) {
    const list = this.dependencies.filter(dep => dep.type === typeName);
    return list;
  }

  byTypeName(typeName) {
    const filtered = this.dependencies.filter(dep => dep.type === typeName);
    return DependencyList.fromArray(filtered);
  }

  byLifecycle(lifecycle) {
    const filtered = this.dependencies.filter(dep => dep.lifecycle === lifecycle);
    return DependencyList.fromArray(filtered);
  }

  serialize() {
    const serialized = this.dependencies.map(dep => {
      return dep.serialize();
    });
    return serialized;
  }

  toDependenciesManifest() {
    const manifest = {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };
    this.forEach(dep => {
      const keyName = _constants().KEY_NAME_BY_LIFECYCLE_TYPE[dep.lifecycle];

      const entry = dep.toManifest();

      if (entry) {
        manifest[keyName][entry.packageName] = entry.version;
      }
    });
    return manifest;
  }

  static merge(lists) {
    const res = [];
    const deps = lists.reduce((acc, curr) => {
      acc = acc.concat(curr.dependencies);
      return acc;
    }, res);
    return new DependencyList(deps);
  }

  static fromArray(dependencies) {
    return new DependencyList(dependencies);
  }

}

exports.DependencyList = DependencyList;

function uniqDeps(dependencies) {
  const uniq = (0, _lodash().uniqBy)(dependencies, (0, _lodash().property)('id'));
  return uniq;
}

function removeVersion(id) {
  return id.split('@')[0];
}

//# sourceMappingURL=dependency-list.js.map