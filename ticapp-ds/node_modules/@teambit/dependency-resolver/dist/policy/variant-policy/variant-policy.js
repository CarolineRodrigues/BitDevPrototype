"use strict";

require("core-js/modules/es.array.iterator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VariantPolicy = void 0;

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = require("../../dependencies");

  _dependencies = function () {
    return data;
  };

  return data;
}

class VariantPolicy {
  constructor(_policiesEntries) {
    this._policiesEntries = _policiesEntries;
    this._policiesEntries = uniqEntries(_policiesEntries);
  }

  get entries() {
    return this._policiesEntries;
  }

  get length() {
    return this.entries.length;
  }

  find(depId, lifecycleType) {
    const matchedEntry = this.entries.find(entry => {
      const idEqual = entry.dependencyId === depId;
      const lifecycleEqual = lifecycleType ? entry.lifecycleType === lifecycleType : true;
      return idEqual && lifecycleEqual;
    });
    return matchedEntry;
  }

  filter(predicate) {
    const filtered = this.entries.filter(predicate);
    return new VariantPolicy(filtered);
  }
  /**
   * Filter only deps which should be resolved from the env
   */


  getResolvedFromEnv() {
    return this.filter(dep => {
      return !!dep.value.resolveFromEnv;
    });
  }

  getDepVersion(depId, lifecycleType) {
    const entry = this.find(depId, lifecycleType);

    if (!entry) {
      return undefined;
    }

    return entry.value.version;
  }

  serialize() {
    return this.entries;
  }

  toConfigObject() {
    const res = {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };

    this._policiesEntries.reduce((acc, entry) => {
      const keyName = _dependencies().KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];

      const value = entry.value.resolveFromEnv ? entry.value : entry.value.version;
      acc[keyName][entry.dependencyId] = value;
      return acc;
    }, res);

    return res;
  }

  toLegacyDepsOverrides() {
    const res = {
      dependencies: {},
      devDependencies: {},
      peerDependencies: {}
    };

    this._policiesEntries.reduce((acc, entry) => {
      const keyName = _dependencies().KEY_NAME_BY_LIFECYCLE_TYPE[entry.lifecycleType];

      acc[keyName][entry.dependencyId] = entry.value.version;
      return acc;
    }, res);

    return res;
  }

  static mergePolices(policies) {
    let allEntries = [];
    allEntries = policies.reduce((acc, curr) => {
      return acc.concat(curr.entries);
    }, allEntries); // We reverse it to make sure the latest policy will be stronger in case of conflict

    allEntries = allEntries.reverse();
    return new VariantPolicy(allEntries);
  }

}

exports.VariantPolicy = VariantPolicy;

function uniqEntries(entries) {
  const uniq = (0, _lodash().uniqWith)(entries, (entry1, entry2) => {
    return entry1.dependencyId === entry2.dependencyId && entry1.lifecycleType === entry2.lifecycleType;
  });
  return uniq;
}

//# sourceMappingURL=variant-policy.js.map