"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatusCmd = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component"));

  _component = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@teambit/legacy/dist/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _chalkBox() {
  const data = require("@teambit/legacy/dist/cli/chalk-box");

  _chalkBox = function () {
    return data;
  };

  return data;
}

function _componentIssuesTemplate() {
  const data = require("@teambit/legacy/dist/cli/templates/component-issues-template");

  _componentIssuesTemplate = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("@teambit/legacy/dist/scope/models");

  _models = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

const TROUBLESHOOTING_MESSAGE = `${_chalk().default.yellow(`learn more at https://${_constants().BASE_DOCS_DOMAIN}/components/adding-components`)}`;
const individualFilesDesc = `these components were added as individual files and not as directories, which are invalid in Harmony
please make sure each component has its own directory and re-add it. alternatively, use "bit move --component" to help with the move.`;
const trackDirDesc = `these components were added by an older version of Bit and therefore have "trackDir" record in the .bitmap file
please run "bit migrate --harmony" to convert these records to "rootDir".`;

class StatusCmd {
  constructor(status) {
    this.status = status;
    (0, _defineProperty2().default)(this, "name", 'status');
    (0, _defineProperty2().default)(this, "shortDescription", 'show the working area component(s) status');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "description", `show the working area component(s) status.\n  https://${_constants().BASE_DOCS_DOMAIN}/workspace/workspace-status`);
    (0, _defineProperty2().default)(this, "alias", 's');
    (0, _defineProperty2().default)(this, "options", [['j', 'json', 'return a json version of the component'], ['', 'strict', 'in case issues found, exit with code 1']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }

  async json() {
    const {
      newComponents,
      modifiedComponent,
      stagedComponents,
      componentsWithIssues,
      importPendingComponents,
      autoTagPendingComponents,
      invalidComponents,
      outdatedComponents,
      mergePendingComponents,
      componentsDuringMergeState,
      componentsWithIndividualFiles,
      componentsWithTrackDirs,
      softTaggedComponents,
      snappedComponents
    } = await this.status.status();
    return {
      newComponents,
      modifiedComponent: modifiedComponent.map(c => c.id.toString()),
      stagedComponents: stagedComponents.map(c => c.id()),
      componentsWithIssues: componentsWithIssues.map(c => {
        var _c$issues;

        return {
          id: c.id.toString(),
          issues: (_c$issues = c.issues) === null || _c$issues === void 0 ? void 0 : _c$issues.toObject()
        };
      }),
      importPendingComponents: importPendingComponents.map(id => id.toString()),
      autoTagPendingComponents: autoTagPendingComponents.map(s => s.toString()),
      invalidComponents,
      outdatedComponents: outdatedComponents.map(c => c.id.toString()),
      mergePendingComponents: mergePendingComponents.map(c => c.id.toString()),
      componentsDuringMergeState: componentsDuringMergeState.map(id => id.toString()),
      componentsWithIndividualFiles: componentsWithIndividualFiles.map(c => c.id.toString()),
      componentsWithTrackDirs: componentsWithTrackDirs.map(c => c.id.toString()),
      softTaggedComponents: softTaggedComponents.map(s => s.toString()),
      snappedComponents: snappedComponents.map(s => s.toString())
    };
  }

  async report(_args, {
    strict
  }) {
    const {
      newComponents,
      modifiedComponent,
      stagedComponents,
      componentsWithIssues,
      importPendingComponents,
      autoTagPendingComponents,
      invalidComponents,
      outdatedComponents,
      mergePendingComponents,
      componentsDuringMergeState,
      componentsWithIndividualFiles,
      componentsWithTrackDirs,
      softTaggedComponents,
      snappedComponents,
      laneName
    } = await this.status.status(); // If there is problem with at least one component we want to show a link to the
    // troubleshooting doc

    let showTroubleshootingLink = false;

    function format(component, showVersions = false, message) {
      const getBitId = () => {
        if (component instanceof _legacyBitId().BitId) return component;
        if (component instanceof _component().default) return component.id;
        if (component instanceof _models().ModelComponent) return component.toBitId();
        throw new Error(`type of component ${component} is not supported`);
      };

      const bitId = getBitId();
      const issues = componentsWithIssues.find(compWithIssue => compWithIssue.id.isEqual(bitId));
      const softTagged = softTaggedComponents.find(softTaggedId => softTaggedId.isEqual(bitId));
      const messageStatusText = message || 'ok';
      const messageStatusTextWithSoftTag = softTagged ? `${messageStatusText} (soft-tagged)` : messageStatusText;
      const color = message ? 'yellow' : 'green';

      const messageStatus = _chalk().default[color](messageStatusTextWithSoftTag);

      if (component instanceof _legacyBitId().BitId) {
        return `${(0, _chalkBox().formatBitString)(component.toStringWithoutVersion())} ... ${messageStatus}`;
      }

      let bitFormatted = `${(0, _chalkBox().formatNewBit)(component)}`;

      if (showVersions) {
        if (!(component instanceof _models().ModelComponent)) {
          throw new Error(`expect "${component}" to be instance of ModelComponent`);
        }

        const localVersions = component.getLocalTagsOrHashes();
        bitFormatted += `. versions: ${localVersions.join(', ')}`;
      }

      bitFormatted += ' ... ';
      if (!issues) return `${bitFormatted}${messageStatus}`;
      showTroubleshootingLink = true;
      return `${bitFormatted} ${_chalk().default.red(_constants().statusFailureMsg)}${(0, _componentIssuesTemplate().formatIssues)(issues)}`;
    }

    const importPendingWarning = importPendingComponents.length ? _chalk().default.yellow(`${_constants().IMPORT_PENDING_MSG}.\n`) : '';

    const splitByMissing = _ramda().default.groupBy(component => {
      return component.includes(_constants().statusFailureMsg) ? 'missing' : 'nonMissing';
    });

    const {
      missing,
      nonMissing
    } = splitByMissing(newComponents.map(c => format(c)));

    const outdatedTitle = _chalk().default.underline.white('pending updates');

    const outdatedDesc = '(use "bit checkout [version] [component_id]" to merge changes)\n(use "bit diff [component_id] [new_version]" to compare changes)\n(use "bit log [component_id]" to list all available versions)\n';
    const outdatedComps = outdatedComponents.map(component => {
      return `    > ${_chalk().default.cyan(component.id.toStringWithoutVersion())} current: ${component.id.version} latest: ${// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      component.latestVersion}\n`;
    }).join('');
    const outdatedStr = outdatedComponents.length ? [outdatedTitle, outdatedDesc, outdatedComps].join('\n') : '';

    const pendingMergeTitle = _chalk().default.underline.white('pending merge');

    const pendingMergeDesc = `(use "bit untag" to add local changes on top of the remote and discard local tags.
alternatively, to keep local tags/snaps history, use "bit merge <remote-name>/<lane-name> [component-id]")\n`;
    const pendingMergeComps = mergePendingComponents.map(component => {
      return `    > ${_chalk().default.cyan(component.id.toString())} local and remote have diverged and have ${component.diverge.snapsOnLocalOnly.length} and ${component.diverge.snapsOnRemoteOnly.length} different snaps each, respectively\n`;
    }).join('');
    const pendingMergeStr = pendingMergeComps.length ? [pendingMergeTitle, pendingMergeDesc, pendingMergeComps].join('\n') : '';

    const compWithConflictsTitle = _chalk().default.underline.white('components during merge state');

    const compWithConflictsDesc = `(use "bit merge [component-id] --resolve" to mark them as resolved and snap the changes
or use "bit merge [component-id] --abort" to cancel the merge operation)\n`;
    const compWithConflictsComps = componentsDuringMergeState.map(id => {
      return `    > ${_chalk().default.cyan(id.toString())}`;
    }).join('');
    const compWithConflictsStr = compWithConflictsComps.length ? [compWithConflictsTitle, compWithConflictsDesc, compWithConflictsComps].join('\n') : '';
    const newComponentDescription = '\n(use "bit tag --all [version]" to lock a version with all your changes)\n';
    const newComponentsTitle = newComponents.length ? _chalk().default.underline.white('new components') + newComponentDescription : '';
    const newComponentsOutput = [newComponentsTitle, ...(nonMissing || []), ...(missing || [])].join('\n');
    const modifiedDesc = '(use "bit diff" to compare changes)\n';
    const modifiedComponentOutput = (0, _utils().immutableUnshift)(modifiedComponent.map(c => format(c)), modifiedComponent.length ? _chalk().default.underline.white('modified components') + newComponentDescription + modifiedDesc : '').join('\n');
    const autoTagPendingOutput = (0, _utils().immutableUnshift)(autoTagPendingComponents.map(c => format(c)), autoTagPendingComponents.length ? _chalk().default.underline.white('components pending to be tagged automatically (when their dependencies are tagged)') : '').join('\n');
    const invalidDesc = '\nthese components were failed to load.\n';
    const invalidComponentOutput = (0, _utils().immutableUnshift)(invalidComponents.map(c => format(c.id, true, (0, _componentIssuesTemplate().getInvalidComponentLabel)(c.error))).sort(), invalidComponents.length ? _chalk().default.underline.white(_constants().statusInvalidComponentsMsg) + invalidDesc : '').join('\n');
    const individualFilesOutput = (0, _utils().immutableUnshift)(componentsWithIndividualFiles.map(c => format(c.id, false, 'individual files')).sort(), componentsWithIndividualFiles.length ? `${_chalk().default.underline.white('components with individual files')}\n${individualFilesDesc}\n` : '').join('\n');
    const trackDirOutput = (0, _utils().immutableUnshift)(componentsWithTrackDirs.map(c => format(c.id, false, 'trackDir record')).sort(), componentsWithTrackDirs.length ? `${_chalk().default.underline.white('components with trackDir record')}\n${trackDirDesc}\n` : '').join('\n');
    const stagedDesc = '\n(use "bit export to push these components to a remote scope")\n';
    const stagedComponentsOutput = (0, _utils().immutableUnshift)( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    stagedComponents.map(c => format(c, true)), stagedComponents.length ? _chalk().default.underline.white('staged components') + stagedDesc : '').join('\n');
    const snappedDesc = '\n(use "bit tag --all [version]" or "bit tag --snapped [version]" to lock a version)\n';
    const snappedComponentsOutput = (0, _utils().immutableUnshift)( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    snappedComponents.map(c => format(c, true)), snappedComponents.length ? _chalk().default.underline.white('snapped components') + snappedDesc : '').join('\n');
    const laneStr = laneName ? `\non ${_chalk().default.bold(laneName)} lane` : '';
    const troubleshootingStr = showTroubleshootingLink ? `\n${TROUBLESHOOTING_MESSAGE}` : '';
    const statusMsg = importPendingWarning + [outdatedStr, pendingMergeStr, compWithConflictsStr, newComponentsOutput, modifiedComponentOutput, snappedComponentsOutput, stagedComponentsOutput, autoTagPendingOutput, invalidComponentOutput, individualFilesOutput, trackDirOutput].filter(x => x).join(_chalk().default.underline('\n                         \n') + _chalk().default.white('\n')) + troubleshootingStr;
    const results = (statusMsg || _chalk().default.yellow(_constants().statusWorkspaceIsCleanMsg)) + laneStr;
    const exitCode = componentsWithIssues.length && strict ? 1 : 0;
    return {
      data: results,
      code: exitCode
    };
  }

}

exports.StatusCmd = StatusCmd;

//# sourceMappingURL=status-cmd.js.map