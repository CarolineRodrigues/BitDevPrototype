"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatusMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));

  _workspace = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("@teambit/legacy/dist/cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _issues() {
  const data = _interopRequireDefault(require("@teambit/issues"));

  _issues = function () {
    return data;
  };

  return data;
}

function _statusCmd() {
  const data = require("./status-cmd");

  _statusCmd = function () {
    return data;
  };

  return data;
}

function _status() {
  const data = require("./status.aspect");

  _status = function () {
    return data;
  };

  return data;
}

class StatusMain {
  constructor(workspace, issues) {
    this.workspace = workspace;
    this.issues = issues;
  }

  async status() {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();

    _loader().default.start(_loaderMessages().BEFORE_STATUS);

    const consumer = this.workspace.consumer;
    const laneObj = await consumer.getCurrentLaneObject();
    const componentsList = new (_componentsList().default)(consumer);
    const newComponents = await componentsList.listNewComponents(true);
    const modifiedComponent = await componentsList.listModifiedComponents(true);
    const stagedComponents = await componentsList.listExportPendingComponents(laneObj);
    const autoTagPendingComponents = await componentsList.listAutoTagPendingComponents();
    const autoTagPendingComponentsIds = autoTagPendingComponents.map(component => component.id);
    const allInvalidComponents = await componentsList.listInvalidComponents();
    const importPendingComponents = allInvalidComponents // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    .filter(c => c.error instanceof _componentsPendingImport().default) // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    .map(i => i.id); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const invalidComponents = allInvalidComponents.filter(c => !(c.error instanceof _componentsPendingImport().default));
    const outdatedComponents = await componentsList.listOutdatedComponents();
    const mergePendingComponents = await componentsList.listMergePendingComponents();
    const newAndModified = newComponents.concat(modifiedComponent);
    const issuesToIgnore = this.issues.getIssuesToIgnore();
    const componentsWithIssues = newAndModified.filter(component => {
      issuesToIgnore.forEach(issueToIgnore => component.issues.delete(_componentIssues().IssuesClasses[issueToIgnore]));

      if (consumer.isLegacy && component.issues) {
        component.issues.delete(_componentIssues().IssuesClasses.RelativeComponentsAuthored);
      }

      return component.issues && !component.issues.isEmpty();
    });
    const componentsDuringMergeState = componentsList.listDuringMergeStateComponents();
    const softTaggedComponents = componentsList.listSoftTaggedComponents();
    const snappedComponents = (await componentsList.listSnappedComponentsOnMain()).map(c => c.toBitId());
    const currentLane = consumer.getCurrentLaneId();
    const laneName = currentLane.isDefault() ? null : currentLane.name;

    _analytics().Analytics.setExtraData('new_components', newComponents.length);

    _analytics().Analytics.setExtraData('staged_components', stagedComponents.length);

    _analytics().Analytics.setExtraData('num_components_with_missing_dependencies', componentsWithIssues.length);

    _analytics().Analytics.setExtraData('autoTagPendingComponents', autoTagPendingComponents.length);

    _analytics().Analytics.setExtraData('deleted', invalidComponents.length);

    await consumer.onDestroy();
    return {
      newComponents: _componentsList().default.sortComponentsByName(newComponents),
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      modifiedComponent: _componentsList().default.sortComponentsByName(modifiedComponent),
      stagedComponents: _componentsList().default.sortComponentsByName(stagedComponents),
      componentsWithIssues,
      // no need to sort, we don't print it as is
      importPendingComponents,
      // no need to sort, we use only its length
      autoTagPendingComponents: _componentsList().default.sortComponentsByName(autoTagPendingComponentsIds),
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      invalidComponents,
      outdatedComponents,
      mergePendingComponents,
      componentsDuringMergeState,
      componentsWithIndividualFiles: await componentsList.listComponentsWithIndividualFiles(),
      componentsWithTrackDirs: await componentsList.listComponentsWithTrackDir(),
      softTaggedComponents,
      snappedComponents,
      laneName
    };
  }

  static async provider([cli, workspace, issues]) {
    const statusMain = new StatusMain(workspace, issues);
    cli.register(new (_statusCmd().StatusCmd)(statusMain));
    return statusMain;
  }

}

exports.StatusMain = StatusMain;
(0, _defineProperty2().default)(StatusMain, "slots", []);
(0, _defineProperty2().default)(StatusMain, "dependencies", [_cli().CLIAspect, _workspace().default, _issues().default]);
(0, _defineProperty2().default)(StatusMain, "runtime", _cli().MainRuntime);

_status().StatusAspect.addRuntime(StatusMain);

//# sourceMappingURL=status.main.runtime.js.map