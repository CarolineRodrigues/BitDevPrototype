"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeScriptExtractor = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _typescript() {
  const data = _interopRequireDefault(require("typescript"));

  _typescript = function () {
    return data;
  };

  return data;
}

function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");

  _semanticsEntities = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _schemaExtractorContext() {
  const data = require("./schema-extractor-context");

  _schemaExtractorContext = function () {
    return data;
  };

  return data;
}

function _exportList() {
  const data = require("./export-list");

  _exportList = function () {
    return data;
  };

  return data;
}

class TypeScriptExtractor {
  constructor(tsconfig, schemaTransformerSlot, tsMain, rootPath) {
    this.tsconfig = tsconfig;
    this.schemaTransformerSlot = schemaTransformerSlot;
    this.tsMain = tsMain;
    this.rootPath = rootPath;
    (0, _defineProperty2().default)(this, "tsserver", undefined);
  }

  parseSourceFile(file) {
    return _typescript().default.createSourceFile(file.path, file.contents.toString('utf8'), _typescript().default.ScriptTarget.Latest, true, this.tsconfig.compilerOptions);
  }
  /**
   * extract a component schema.
   */


  async extract(component) {
    const tsserver = await this.getTsServer();
    const mainFile = component.mainFile;
    const mainAst = this.parseSourceFile(mainFile);
    const context = this.createContext(tsserver, component);
    const exportNames = await this.computeExportedIdentifiers(mainAst, context);
    context.setExports(new (_exportList().ExportList)(exportNames));
    await this.computeSchema(mainAst, context); // TODO: create the schema

    return _semanticsEntities().SemanticSchema.from({});
  }

  async computeExportedIdentifiers(node, context) {
    const transformer = this.getTransformer(node, context.component);
    if (!transformer || !transformer.getIdentifiers) throw new (_exceptions().TransformerNotFound)(node, context.component);
    return transformer.getIdentifiers(node, context);
  }

  createContext(tsserver, component) {
    return new (_schemaExtractorContext().SchemaExtractorContext)(tsserver, component, this);
  }

  async getTsServer() {
    if (!this.tsserver) {
      const tsserver = this.tsMain.getTsserverClient();

      if (tsserver) {
        this.tsserver = tsserver;
        return tsserver;
      }

      this.tsserver = await this.tsMain.initTsserverClient(this.rootPath);
      return this.tsserver;
    }

    return this.tsserver;
  }

  async computeSchema(node, context) {
    const transformer = this.getTransformer(node, context.component);
    if (!transformer) return undefined;
    return transformer.transform(node, context);
  }
  /**
   * select the correct transformer for a node.
   */


  getTransformer(node, component) {
    const transformers = (0, _lodash().flatten)(this.schemaTransformerSlot.values());
    const transformer = transformers.find(singleTransformer => singleTransformer.predicate(node));
    if (!transformer) throw new (_exceptions().TransformerNotFound)(node, component);
    return transformer;
  }

}

exports.TypeScriptExtractor = TypeScriptExtractor;

//# sourceMappingURL=typescript.extractor.js.map