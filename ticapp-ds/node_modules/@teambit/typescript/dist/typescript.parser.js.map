{"version":3,"sources":["typescript.parser.ts"],"names":["TypeScriptParser","getExports","sourceFile","staticProperties","parseStaticProperties","exports","statements","filter","statement","modifiers","find","modifier","kind","ts","SyntaxKind","ExportKeyword","exportModels","map","child","declarationList","declarations","name","text","Export","undefined","get","withoutEmpty","exportModel","parseModule","modulePath","ast","createSourceFile","ScriptTarget","Latest","moduleExports","Module","exportStaticProperties","Map","forEach","isExpressionStatement","isBinaryExpression","expression","operatorToken","EqualsToken","isPropertyAccessExpression","left","isIdentifier","targetName","propertyName","has","set","existingProperties","isStringLiteral","right","isNumericLiteral","UndefinedKeyword","NullKeyword","TrueKeyword","FalseKeyword","err","logger","error","constructor"],"mappings":"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","sourcesContent":["import { Parser } from '@teambit/schema';\nimport { Export, Module, StaticProperties } from '@teambit/semantics.entities.semantic-schema';\nimport { Logger } from '@teambit/logger';\nimport { readFileSync } from 'fs-extra';\nimport ts, {\n  isClassDeclaration,\n  isFunctionDeclaration,\n  isVariableStatement,\n  SourceFile,\n  VariableStatement,\n} from 'typescript';\n\nexport class TypeScriptParser implements Parser {\n  public extension = /^.*\\.(js|jsx|ts|tsx)$/;\n\n  getExports(sourceFile: SourceFile): Export[] {\n    const staticProperties = this.parseStaticProperties(sourceFile);\n\n    const exports = sourceFile.statements.filter((statement) => {\n      if (!statement.modifiers) return false;\n      return statement.modifiers.find((modifier) => {\n        return modifier.kind === ts.SyntaxKind.ExportKeyword;\n      });\n    });\n\n    const exportModels = exports.map((statement) => {\n      // todo refactor to a registry of variable statements.\n      if (isVariableStatement(statement)) {\n        const child = (statement as VariableStatement).declarationList.declarations[0];\n        const name = (child as any).name.text;\n        return new Export(name, undefined, staticProperties.get(name));\n      }\n\n      if (isFunctionDeclaration(statement)) {\n        if (!statement.name) return undefined;\n        const name = statement.name.text;\n        return new Export(name, undefined, staticProperties.get(name));\n      }\n\n      if (isClassDeclaration(statement)) {\n        if (!statement.name) return undefined;\n        const name = statement.name.text;\n        return new Export(name, undefined, staticProperties.get(name));\n      }\n\n      return undefined;\n    });\n    const withoutEmpty = exportModels.filter((exportModel) => exportModel !== undefined);\n    // @ts-ignore\n    return withoutEmpty;\n  }\n\n  parseModule(modulePath: string) {\n    const ast = ts.createSourceFile(modulePath, readFileSync(modulePath, 'utf8'), ts.ScriptTarget.Latest);\n\n    const moduleExports = this.getExports(ast);\n\n    return new Module(moduleExports);\n  }\n\n  parseStaticProperties(sourceFile: SourceFile) {\n    // TODO - should we also parse staticProperties inside classes / objects?\n\n    const exportStaticProperties = new Map<string, StaticProperties>();\n\n    sourceFile.statements.forEach((statement) => {\n      try {\n        if (!ts.isExpressionStatement(statement)) return;\n        if (!ts.isBinaryExpression(statement.expression)) return;\n        if (statement.expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken) return;\n        if (!ts.isPropertyAccessExpression(statement.expression.left)) return;\n        if (!ts.isIdentifier(statement.expression.left.expression)) return;\n\n        const targetName = statement.expression.left.expression.text;\n        const propertyName = statement.expression.left.name.text;\n\n        if (!exportStaticProperties.has(targetName)) exportStaticProperties.set(targetName, new Map());\n\n        const existingProperties = exportStaticProperties.get(targetName);\n\n        if (ts.isStringLiteral(statement.expression.right)) {\n          existingProperties?.set(propertyName, statement.expression.right.text);\n        } else if (ts.isNumericLiteral(statement.expression.right)) {\n          existingProperties?.set(propertyName, +statement.expression.right.text);\n        } else if (statement.expression.right.kind === ts.SyntaxKind.UndefinedKeyword) {\n          existingProperties?.set(propertyName, undefined);\n        } else if (statement.expression.right.kind === ts.SyntaxKind.NullKeyword) {\n          existingProperties?.set(propertyName, null);\n        } else if (statement.expression.right.kind === ts.SyntaxKind.TrueKeyword) {\n          existingProperties?.set(propertyName, true);\n        } else if (statement.expression.right.kind === ts.SyntaxKind.FalseKeyword) {\n          existingProperties?.set(propertyName, false);\n        }\n      } catch (err) {\n        this.logger?.error('failed parsing static properties', err);\n      }\n    });\n\n    return exportStaticProperties;\n  }\n\n  constructor(private logger?: Logger | undefined) {}\n}\n"]}