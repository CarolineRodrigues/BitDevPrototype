"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaExtractorContext = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _tsutils() {
  const data = require("tsutils");

  _tsutils = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");

  _semanticsEntities = function () {
    return data;
  };

  return data;
}

class SchemaExtractorContext {
  constructor(tsserver, component, extractor) {
    this.tsserver = tsserver;
    this.component = component;
    this.extractor = extractor;
    (0, _defineProperty2().default)(this, "_exports", undefined);
  }

  computeSchema(node) {
    return this.extractor.computeSchema(node, this);
  }

  getLocation(node, targetSourceFile) {
    const sourceFile = targetSourceFile || node.getSourceFile();
    const position = sourceFile.getLineAndCharacterOfPosition(node.pos);
    const line = position.line + 1;
    const character = position.character + 2; // need to verify why a 2 char difference here.

    return {
      line,
      character
    };
  }

  async getSignature(node) {
    return this.tsserver.getSignatureHelp(this.getPath(node), this.getLocation(node));
  }

  getPosition(sourceFile, line, offset) {
    return sourceFile.getPositionOfLineAndCharacter(line - 1, offset - 2);
  }

  getPath(node) {
    const sourceFile = node.getSourceFile();
    return sourceFile.fileName;
  }

  createRef() {
    return {};
  }

  getQuickInfo(node) {
    return this.tsserver.getQuickInfo(this.getPath(node), this.getLocation(node));
  }

  typeDefinition(node) {
    return this.tsserver.getTypeDefinition(this.getPath(node), this.getLocation(node));
  }

  visitTypeDefinition() {}

  findFileInComponent(filePath) {
    return this.component.filesystem.files.find(file => {
      // TODO: fix this line to support further extensions.
      if (file.path.includes(filePath)) {
        const strings = ['ts', 'tsx', 'js', 'jsx'].map(format => {
          if (filePath.endsWith(format)) return filePath;
          return `${filePath}.${format}`;
        });
        return strings.find(string => string === file.path);
      }

      return false;
    });
  }
  /**
   * return the file if part of the component.
   * otherwise, a reference to the target package and the type name.
   */


  getSourceFile(filePath) {
    const file = this.findFileInComponent(filePath);
    if (!file) return undefined;
    return this.extractor.parseSourceFile(file);
  }

  async definition(node) {
    const def = await this.tsserver.getDefinition(this.getPath(node), this.getLocation(node));
    const firstDef = (0, _lodash().head)(def.body);
    if (!firstDef) return undefined;
    const startPosition = firstDef.start;
    const sourceFile = this.getSourceFile(firstDef.file);
    if (!sourceFile) return undefined; // learn how to return a reference to a different component here.

    const pos = this.getPosition(sourceFile, startPosition.line, startPosition.offset);
    const nodeAtPos = (0, _tsutils().getTokenAtPosition)(sourceFile, pos);
    return nodeAtPos;
  }

  async visitDefinition(node) {
    const definition = await this.definition(node);
    if (!definition) return undefined;
    return this.visit(definition.parent);
  }

  async visit(node) {
    return this.extractor.computeSchema(node, this);
  }

  references() {}

  isExported() {}

  isFromComponent() {}

  async getFileExports(exportDec) {
    var _exportDec$moduleSpec;

    const file = exportDec.getSourceFile().fileName;
    const specifierPathStr = ((_exportDec$moduleSpec = exportDec.moduleSpecifier) === null || _exportDec$moduleSpec === void 0 ? void 0 : _exportDec$moduleSpec.getText()) || '';
    const specifierPath = specifierPathStr.substring(1, specifierPathStr.length - 1);
    const absPath = (0, _path().resolve)(file, '..', specifierPath);
    const sourceFile = this.getSourceFile(absPath);
    if (!sourceFile) return [];
    return this.extractor.computeExportedIdentifiers(sourceFile, this);
  }

  setExports(exports) {
    this._exports = exports;
    return this;
  }

  getExportedIdentifiers(node) {
    return this.extractor.computeExportedIdentifiers(node, this);
  }

  isNative(typeName) {
    return ['string', 'number', 'bool', 'boolean', 'object', 'any', 'void'].includes(typeName);
  }

  async jump(file, start) {
    const sourceFile = this.extractor.parseSourceFile(file);
    const pos = this.getPosition(sourceFile, start.line, start.offset);
    const nodeAtPos = (0, _tsutils().getTokenAtPosition)(sourceFile, pos);
    if (!nodeAtPos) return undefined;
    return this.visit(nodeAtPos);
  }

  async resolveType(node, typeStr, type = true) {
    var _this$_exports, _typeDef$body;

    if (this.isNative(typeStr)) return new (_semanticsEntities().TypeRefSchema)(typeStr);
    if ((_this$_exports = this._exports) !== null && _this$_exports !== void 0 && _this$_exports.includes(typeStr)) return new (_semanticsEntities().TypeRefSchema)(typeStr);
    const typeDef = type ? await this.tsserver.getDefinition(node.getSourceFile().fileName, this.getLocation(node)) : await this.typeDefinition(node);
    const def = await Promise.all((typeDef === null || typeDef === void 0 ? void 0 : (_typeDef$body = typeDef.body) === null || _typeDef$body === void 0 ? void 0 : _typeDef$body.map(async definition => {
      const file = this.findFileInComponent(definition.file); // TODO: find component id is exists, otherwise add the package name.

      if (!file) return new (_semanticsEntities().TypeRefSchema)(typeStr, undefined, '');
      if (file) return new (_semanticsEntities().TypeRefSchema)(typeStr, undefined, undefined, this.jump(file, definition.start));
      return undefined;
    })) || []);
    const headDef = (0, _lodash().head)(def);
    if (headDef) return headDef;
    return new (_semanticsEntities().TypeRefSchema)('any');
  }

}

exports.SchemaExtractorContext = SchemaExtractorContext;

//# sourceMappingURL=schema-extractor-context.js.map