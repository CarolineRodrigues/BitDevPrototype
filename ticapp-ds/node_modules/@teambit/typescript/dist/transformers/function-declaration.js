"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.trim.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionDeclaration = void 0;

function _semanticsEntities() {
  const data = require("@teambit/semantics.entities.semantic-schema");

  _semanticsEntities = function () {
    return data;
  };

  return data;
}

function _typescript() {
  const data = _interopRequireDefault(require("typescript"));

  _typescript = function () {
    return data;
  };

  return data;
}

function _exportIdentifier() {
  const data = require("../export-identifier");

  _exportIdentifier = function () {
    return data;
  };

  return data;
}

class FunctionDeclaration {
  predicate(node) {
    return node.kind === _typescript().default.SyntaxKind.FunctionDeclaration;
  } // need to check for anonymous functions assigned for vars, const and let.


  async getIdentifiers(funcDec) {
    return [new (_exportIdentifier().ExportIdentifier)(this.getName(funcDec), funcDec.getSourceFile().fileName)];
  }

  getName(funcDec) {
    var _funcDec$name;

    return ((_funcDec$name = funcDec.name) === null || _funcDec$name === void 0 ? void 0 : _funcDec$name.getText()) || '';
  }

  async getArgs(funcDec, context) {
    return Promise.all(funcDec.parameters.map(async param => {
      const type = param.type;
      return {
        name: param.name.getText(),
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        type: await context.resolveType(type, (type === null || type === void 0 ? void 0 : type.getText()) || 'any')
      };
    }));
  }

  parseReturnValue(displayString) {
    if (!displayString) return '';
    const array = displayString.split(':');
    return array[array.length - 1].trim();
  }

  async transform(node, context) {
    var _info$body;

    const funcDec = node;
    const name = this.getName(funcDec); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    const info = await context.getQuickInfo(funcDec.name);
    const displaySig = info === null || info === void 0 ? void 0 : (_info$body = info.body) === null || _info$body === void 0 ? void 0 : _info$body.displayString;
    const returnTypeStr = this.parseReturnValue(displaySig); // eslint-disable-next-line @typescript-eslint/no-unused-vars

    const args = await this.getArgs(funcDec, context); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    const returnType = await context.resolveType(funcDec.name, returnTypeStr);
    return new (_semanticsEntities().FunctionSchema)(name || '', [], returnType);
  }

}

exports.FunctionDeclaration = FunctionDeclaration;

//# sourceMappingURL=function-declaration.js.map