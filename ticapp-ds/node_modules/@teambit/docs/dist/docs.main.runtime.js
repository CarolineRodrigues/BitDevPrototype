"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocsMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _compiler() {
  const data = require("@teambit/compiler");

  _compiler = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireWildcard(require("@teambit/component"));

  _component = function () {
    return data;
  };

  return data;
}

function _pkg() {
  const data = require("@teambit/pkg");

  _pkg = function () {
    return data;
  };

  return data;
}

function _graphql() {
  const data = require("@teambit/graphql");

  _graphql = function () {
    return data;
  };

  return data;
}

function _preview() {
  const data = require("@teambit/preview");

  _preview = function () {
    return data;
  };

  return data;
}

function _devFiles() {
  const data = _interopRequireDefault(require("@teambit/dev-files"));

  _devFiles = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = require("@teambit/workspace");

  _workspace = function () {
    return data;
  };

  return data;
}

function _docsEntities() {
  const data = require("@teambit/docs.entities.doc");

  _docsEntities = function () {
    return data;
  };

  return data;
}

function _docs() {
  const data = require("./docs.aspect");

  _docs = function () {
    return data;
  };

  return data;
}

function _docs2() {
  const data = require("./docs.preview-definition");

  _docs2 = function () {
    return data;
  };

  return data;
}

function _docs3() {
  const data = require("./docs.graphql");

  _docs3 = function () {
    return data;
  };

  return data;
}

function _defaultDocReader() {
  const data = require("./default-doc-reader");

  _defaultDocReader = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * the component documentation extension.
 */
class DocsMain {
  constructor(patterns,
  /**
   * envs extension.
   */
  preview, pkg, compiler, workspace, logger, devFiles, docPropSlot, docReaderSlot) {
    this.patterns = patterns;
    this.preview = preview;
    this.pkg = pkg;
    this.compiler = compiler;
    this.workspace = workspace;
    this.logger = logger;
    this.devFiles = devFiles;
    this.docPropSlot = docPropSlot;
    this.docReaderSlot = docReaderSlot;
  }
  /**
   * returns an array of doc file paths for a set of components.
   */


  getDocsMap(components) {
    return _component().ComponentMap.as(components, component => {
      return this.getDocsFiles(component);
    });
  }

  getDocsFiles(component) {
    const devFiles = this.devFiles.computeDevFiles(component);
    const docFiles = devFiles.get(_docs().DocsAspect.id);
    return component.state.filesystem.files.filter(file => docFiles.includes(file.relative));
  }
  /**
   * compute the description of the component from its source code and docs file.
   */


  async getDescription(component) {
    var _consumerComponent$do;

    const componentDoc = this.getDoc(component);
    const desc = componentDoc === null || componentDoc === void 0 ? void 0 : componentDoc.description;
    if (desc) return desc;
    const consumerComponent = component.state._consumer;
    const fromJsDocs = (_consumerComponent$do = consumerComponent.docs) === null || _consumerComponent$do === void 0 ? void 0 : _consumerComponent$do.find(doc => doc.description);
    return (fromJsDocs === null || fromJsDocs === void 0 ? void 0 : fromJsDocs.description) || '';
  }

  async getTemplate(env) {
    return env.getDocsTemplate();
  }

  getDocReader(extension) {
    return this.docReaderSlot.values().find(docReader => docReader.isFormatSupported(extension));
  }
  /**
   * compute a doc for a component.
   */


  async computeDoc(component) {
    const docFiles = this.getDocsFiles(component);

    if (docFiles.length) {
      // currently taking the the first docs file found with an abstract. (we support only one)
      const docFile = docFiles[0];

      try {
        const docReader = this.getDocReader(docFile.extname);
        if (!docReader) throw new (_exceptions().FileExtensionNotSupported)(docFile.relative, docFile.extname);
        const doc = await docReader.read(docFile.relative, docFile.contents, component);
        return doc;
      } catch (err) {
        this.logger.error('docs.main.runtime.computeDoc caught an error', err);
        return null;
      }
    }

    return null;
  }

  getDoc(component) {
    var _component$state$aspe, _component$state$aspe2;

    const docData = (_component$state$aspe = component.state.aspects.get(_docs().DocsAspect.id)) === null || _component$state$aspe === void 0 ? void 0 : (_component$state$aspe2 = _component$state$aspe.data) === null || _component$state$aspe2 === void 0 ? void 0 : _component$state$aspe2.doc;
    if (!docData) return null;
    return new (_docsEntities().Doc)(docData.filePath, new (_docsEntities().DocPropList)(docData.props));
  }

  getPatterns() {
    return this.patterns;
  }
  /**
   * register a new doc reader. this allows to support further
   * documentation file formats.
   */


  registerDocReader(docReader) {
    this.docReaderSlot.register(docReader);
    return this;
  }

  static async provider([preview, graphql, workspace, pkg, compiler, loggerAspect, devFiles], config, [docPropSlot, docReaderSlot]) {
    const logger = loggerAspect.createLogger(_docs().DocsAspect.id);
    const docs = new DocsMain(config.patterns, preview, pkg, compiler, workspace, logger, devFiles, docPropSlot, docReaderSlot);
    docs.registerDocReader(new (_defaultDocReader().DefaultDocReader)(pkg, compiler, workspace));
    devFiles.registerDevPattern(config.patterns);

    if (workspace) {
      workspace.onComponentLoad(async component => {
        const doc = await docs.computeDoc(component);
        return {
          doc: doc === null || doc === void 0 ? void 0 : doc.toObject()
        };
      });
    }

    graphql.register((0, _docs3().docsSchema)(docs));
    preview.registerDefinition(new (_docs2().DocsPreviewDefinition)(docs));
    return docs;
  }

}

exports.DocsMain = DocsMain;
(0, _defineProperty2().default)(DocsMain, "slots", [_harmony().Slot.withType(), _harmony().Slot.withType()]);
(0, _defineProperty2().default)(DocsMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(DocsMain, "dependencies", [_preview().PreviewAspect, _graphql().GraphqlAspect, _workspace().WorkspaceAspect, _pkg().PkgAspect, _compiler().CompilerAspect, _logger().LoggerAspect, _devFiles().default, _component().default]);
(0, _defineProperty2().default)(DocsMain, "defaultConfig", {
  patterns: ['**/*.docs.*']
});

_docs().DocsAspect.addRuntime(DocsMain);

//# sourceMappingURL=docs.main.runtime.js.map