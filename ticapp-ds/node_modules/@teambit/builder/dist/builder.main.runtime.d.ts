import { ArtifactVinyl } from '@teambit/legacy/dist/consumer/component/sources/artifact';
import { AspectLoaderMain } from '@teambit/aspect-loader';
import { CLIMain } from '@teambit/cli';
import { Component } from '@teambit/component';
import { EnvsMain } from '@teambit/envs';
import { GraphqlMain } from '@teambit/graphql';
import { SlotRegistry } from '@teambit/harmony';
import { LoggerMain } from '@teambit/logger';
import { ScopeMain, OnTagResults } from '@teambit/scope';
import { Workspace } from '@teambit/workspace';
import { IsolateComponentsOptions, IsolatorMain } from '@teambit/isolator';
import { OnTagOpts } from '@teambit/legacy/dist/scope/scope';
import { ArtifactObject } from '@teambit/legacy/dist/consumer/component/sources/artifact-files';
import { GeneratorMain } from '@teambit/generator';
import { BuilderService, BuilderServiceOptions } from './builder.service';
import { BuildTask } from './build-task';
import { TaskResults } from './build-pipe';
import { TaskResultsList } from './task-results-list';
import { AspectData, PipelineReport } from './build-pipeline-result-list';
import { Serializable } from './types';
export declare type TaskSlot = SlotRegistry<BuildTask[]>;
export declare type BuilderData = {
    pipeline: PipelineReport[];
    artifacts: ArtifactObject[] | undefined;
    aspectsData: AspectData[];
};
export declare class BuilderMain {
    private envs;
    private workspace;
    private buildService;
    private tagService;
    private snapService;
    private scope;
    private isolator;
    private aspectLoader;
    private buildTaskSlot;
    private tagTaskSlot;
    private snapTaskSlot;
    constructor(envs: EnvsMain, workspace: Workspace, buildService: BuilderService, tagService: BuilderService, snapService: BuilderService, scope: ScopeMain, isolator: IsolatorMain, aspectLoader: AspectLoaderMain, buildTaskSlot: TaskSlot, tagTaskSlot: TaskSlot, snapTaskSlot: TaskSlot);
    private storeArtifacts;
    private pipelineResultsToBuilderData;
    tagListener(components: Component[], options?: OnTagOpts, isolateOptions?: IsolateComponentsOptions): Promise<OnTagResults>;
    private validateBuilderDataMap;
    getArtifactsVinylByExtension(component: Component, aspectName: string): Promise<ArtifactVinyl[]>;
    getArtifactsVinylByExtensionAndName(component: Component, aspectName: string, name: string): Promise<ArtifactVinyl[]>;
    getArtifactsVinylByExtensionAndTaskName(component: Component, aspectName: string, taskName: string): Promise<ArtifactVinyl[]>;
    getArtifactsByName(component: Component, name: string): ArtifactObject[] | undefined;
    getArtifactsByExtension(component: Component, aspectName: string): ArtifactObject[] | undefined;
    getArtifactsByExtensionAndName(component: Component, aspectName: string, name: string): ArtifactObject[] | undefined;
    getArtifactsByExtensionAndTaskName(component: Component, aspectName: string, taskName: string): ArtifactObject[] | undefined;
    getDataByAspect(component: Component, aspectName: string): Serializable | undefined;
    getArtifacts(component: Component): ArtifactObject[] | undefined;
    getBuilderData(component: Component): BuilderData | undefined;
    /**
     * build given components for release.
     * for each one of the envs it runs a series of tasks.
     * in case of an error in a task, it stops the execution of that env and continue to the next
     * env. at the end, the results contain the data and errors per env.
     */
    build(components: Component[], isolateOptions?: IsolateComponentsOptions, builderOptions?: BuilderServiceOptions): Promise<TaskResultsList>;
    runTagTasks(components: Component[], isolateOptions?: IsolateComponentsOptions, previousTasksResults?: TaskResults[]): Promise<TaskResultsList>;
    runSnapTasks(components: Component[], isolateOptions?: IsolateComponentsOptions, previousTasksResults?: TaskResults[]): Promise<TaskResultsList>;
    listTasks(component: Component): {
        id: import("@teambit/component").ComponentID;
        envId: string;
        buildTasks: string[];
        tagTasks: string[];
        snapTasks: string[];
    };
    /**
     * register a build task to apply on all component build pipelines.
     * build happens on `bit build` and as part of `bit tag --persist`.
     */
    registerBuildTasks(tasks: BuildTask[]): this;
    /**
     * @deprecated use registerTagTasks or registerSnapTasks
     */
    registerDeployTasks(tasks: BuildTask[]): this;
    /**
     * tag tasks that don't get executed on `bit build`, only on `bit tag'.
     * this pipeline is running once the build-pipeline has completed.
     */
    registerTagTasks(tasks: BuildTask[]): this;
    /**
     * tag tasks that don't get executed on `bit build`, only on `bit snap'.
     * this pipeline is running once the build-pipeline has completed.
     */
    registerSnapTasks(tasks: BuildTask[]): this;
    static slots: ((registerFn: () => string) => SlotRegistry<BuildTask>)[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static dependencies: import("@teambit/harmony").Aspect[];
    static provider([cli, envs, workspace, scope, isolator, loggerExt, aspectLoader, graphql, generator]: [
        CLIMain,
        EnvsMain,
        Workspace,
        ScopeMain,
        IsolatorMain,
        LoggerMain,
        AspectLoaderMain,
        GraphqlMain,
        GeneratorMain
    ], config: any, [buildTaskSlot, tagTaskSlot, snapTaskSlot]: [TaskSlot, TaskSlot, TaskSlot]): Promise<BuilderMain>;
}
