{"version":3,"sources":["build-pipeline-order.ts"],"names":["calculatePipelineOrder","taskSlot","envs","pipeNameOnEnv","tasks","skipTests","graphs","locations","forEach","location","push","graph","Graph","pipelineEnvs","envDefinition","pipeline","getPipelineForEnv","env","flattenedPipeline","map","pipelineEnv","flat","task","addDependenciesToGraph","dataPerLocation","pipelineEnvsPerLocation","filter","tasksQueue","TasksQueue","addTasksToGraph","length","includes","name","aspectId","TesterAspect","id","data","find","d","sorted","toposort","taskNode","BuildTaskHelper","deserializeId","attr","taskIndex","findIndex","pipelineTask","splice","dependencies","taskId","serializeId","dependency","deserializeIdAllowEmptyName","dependencyTasks","Error","dependencyTask","getLocation","graphLocation","g","dependencyId","setNode","setEdge","taskLocation","dependencyLocation","isDependencyAhead","isDependencyEqual","buildTasks","slotsTasks","values","tasksAtStart","tasksAtEnd","mergedTasks"],"mappings":"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","sourcesContent":["import { Graph } from 'cleargraph';\nimport TesterAspect from '@teambit/tester';\nimport { EnvDefinition, Environment } from '@teambit/envs';\nimport { BuildTask, BuildTaskHelper } from './build-task';\nimport type { TaskSlot } from './builder.main.runtime';\nimport { TasksQueue } from './tasks-queue';\n\ntype TaskDependenciesGraph = Graph<string, string>;\ntype Location = 'start' | 'middle' | 'end';\ntype TasksLocationGraph = { location: Location; graph: TaskDependenciesGraph };\ntype PipelineEnv = { env: EnvDefinition; pipeline: BuildTask[] };\ntype DataPerLocation = { location: Location; graph: TaskDependenciesGraph; pipelineEnvs: PipelineEnv[] };\n\n/**\n * there are two ways how to add tasks to build pipeline.\n * 1. `getBuildPipe()` method of the env.\n * 2. registering to the `builder.registerBuildTask()`.\n *\n * in the option #1, it's possible to determine the order. e.g. `getBuildPipe() { return [taskA, taskB, taskC]; }`\n * in the option #2, the register happens once the extension is loaded, so there is no way to put\n * one task before/after another task.\n *\n * To be able to determine the order, you can do the following\n * 1. \"task.location\", it has two options \"start\" and \"end\". the rest are \"middle\".\n * 2. \"task.dependencies\", the dependencies must be completed for all envs before this task starts.\n * the dependencies are applicable inside a location and not across locations. see getLocation()\n * or/and continue reading for more info about this.\n *\n * to determine the final order of the tasks, the following is done:\n * 1. split all tasks to three groups: start, middle and end.\n * 2. for each group define a dependencies graph for the tasks with \"dependencies\" prop and the pipeline.\n * 3. start with the first group \"start\", toposort the dependencies graph and push the found tasks\n * to a queue. once completed, iterate the pipeline and add all tasks to the queue.\n * 4. do the same for the \"middle\" and \"end\" groups.\n *\n * the reason for splitting the tasks to the three groups and not using the \"dependencies\" field\n * alone to determine the order is that the \"start\" and \"end\" groups are mostly core and \"middle\"\n * is mostly the user entering tasks to the pipeline and we as the core don't know about the users\n * tasks. For example, a core task \"PublishComponent\" must happen after the compiler, however, a\n * user might have an env without a compiler. if we determine the order only by the dependencies\n * field, the \"PublishComponent\" would have a dependency \"compiler\" and because in this case there\n * is no compiler task, it would throw an error about missing dependencies.\n */\nexport function calculatePipelineOrder(\n  taskSlot: TaskSlot,\n  envs: EnvDefinition[],\n  pipeNameOnEnv = 'getBuildPipe',\n  tasks: string[] = [],\n  skipTests = false\n): TasksQueue {\n  const graphs: TasksLocationGraph[] = [];\n  const locations: Location[] = ['start', 'middle', 'end']; // the order is important here!\n  locations.forEach((location) => {\n    graphs.push({ location, graph: new Graph<string, string>() });\n  });\n  const pipelineEnvs: PipelineEnv[] = [];\n  envs.forEach((envDefinition) => {\n    const pipeline = getPipelineForEnv(taskSlot, envDefinition.env, pipeNameOnEnv);\n    pipelineEnvs.push({ env: envDefinition, pipeline });\n  });\n\n  const flattenedPipeline: BuildTask[] = pipelineEnvs.map((pipelineEnv) => pipelineEnv.pipeline).flat();\n  flattenedPipeline.forEach((task) => addDependenciesToGraph(graphs, flattenedPipeline, task));\n\n  const dataPerLocation: DataPerLocation[] = graphs.map(({ location, graph }) => {\n    const pipelineEnvsPerLocation: PipelineEnv[] = pipelineEnvs.map(({ env, pipeline }) => {\n      return { env, pipeline: pipeline.filter((task) => (task.location || 'middle') === location) };\n    });\n    return { location, graph, pipelineEnvs: pipelineEnvsPerLocation };\n  });\n\n  const tasksQueue = new TasksQueue();\n  locations.forEach((location) => addTasksToGraph(tasksQueue, dataPerLocation, location));\n  if (tasks.length) {\n    return new TasksQueue(\n      ...tasksQueue.filter(({ task }) => tasks.includes(task.name) || tasks.includes(task.aspectId))\n    );\n  }\n  if (skipTests) {\n    return new TasksQueue(...tasksQueue.filter(({ task }) => task.aspectId !== TesterAspect.id));\n  }\n  return tasksQueue;\n}\n\nfunction addTasksToGraph(tasksQueue: TasksQueue, dataPerLocation: DataPerLocation[], location: Location) {\n  const data = dataPerLocation.find((d) => d.location === location);\n  if (!data) return;\n  const sorted = data.graph.toposort();\n  sorted.forEach((taskNode) => {\n    const { aspectId, name } = BuildTaskHelper.deserializeId(taskNode.attr);\n    data.pipelineEnvs.forEach(({ env, pipeline }) => {\n      const taskIndex = pipeline.findIndex(\n        (pipelineTask) => pipelineTask.aspectId === aspectId && pipelineTask.name === name\n      );\n      if (taskIndex < 0) return;\n      const task = pipeline[taskIndex];\n      tasksQueue.push({ env, task });\n      pipeline.splice(taskIndex, 1); // delete the task from the pipeline\n    });\n  });\n  data.pipelineEnvs.forEach(({ env, pipeline }) => {\n    pipeline.forEach((task) => tasksQueue.push({ env, task }));\n  });\n}\n\nfunction addDependenciesToGraph(graphs: TasksLocationGraph[], pipeline: BuildTask[], task: BuildTask) {\n  if (!task.dependencies || !task.dependencies.length) return;\n  const taskId = BuildTaskHelper.serializeId(task);\n  task.dependencies.forEach((dependency) => {\n    const { aspectId, name } = BuildTaskHelper.deserializeIdAllowEmptyName(dependency);\n    const dependencyTasks = pipeline.filter((pipelineTask) => {\n      if (pipelineTask.aspectId !== aspectId) return false;\n      return name ? name === pipelineTask.name : true;\n    });\n    if (dependencyTasks.length === 0) {\n      throw new Error(\n        `unable to find dependency \"${dependency}\" of \"${BuildTaskHelper.serializeId(task)}\" in the pipeline`\n      );\n    }\n    dependencyTasks.forEach((dependencyTask) => {\n      const location = getLocation(task, dependencyTask);\n      if (!location) {\n        // the dependency is behind and will be in the correct order regardless the graph.\n        return;\n      }\n      const graphLocation = graphs.find((g) => g.location === location);\n      if (!graphLocation) throw new Error(`unable to find graph for location ${location}`);\n      const dependencyId = BuildTaskHelper.serializeId(dependencyTask);\n      const graph = graphLocation.graph;\n      graph.setNode(taskId, taskId);\n      graph.setNode(dependencyId, dependencyId);\n      graph.setEdge(dependencyId, taskId, 'dependency');\n    });\n  });\n}\n\n/**\n * since the task execution is happening per group: \"start\", \"middle\" and \"end\", the dependencies\n * need to be inside the same group.\n * e.g. if a dependency located at \"end\" group and the task located at \"start\", it's impossible to\n * complete the dependency before the task, there it throws an error.\n * it's ok to have the dependency located earlier, e.g. \"start\" and the task at \"end\", and in this\n * case, it will not be part of the graph because there is no need to do any special calculation.\n */\nfunction getLocation(task: BuildTask, dependencyTask: BuildTask): Location | null {\n  const taskLocation = task.location || 'middle';\n  const dependencyLocation = dependencyTask.location || 'middle';\n\n  const isDependencyAhead =\n    (taskLocation === 'start' && dependencyLocation !== 'start') ||\n    (taskLocation === 'middle' && dependencyLocation === 'end');\n\n  const isDependencyEqual = taskLocation === dependencyLocation;\n\n  if (isDependencyAhead) {\n    throw new Error(`a task \"${BuildTaskHelper.serializeId(task)}\" located at ${taskLocation}\nhas a dependency \"${BuildTaskHelper.serializeId(dependencyTask)} located at ${dependencyLocation},\nwhich is invalid. the dependency must be located earlier or in the same location as the task\"`);\n  }\n\n  if (isDependencyEqual) {\n    return taskLocation;\n  }\n\n  // dependency is behind. e.g. task is \"end\" and dependency is \"start\". no need to enter to the\n  // graph as it's going to be executed in the right order regardless the graph.\n  return null;\n}\n\nfunction getPipelineForEnv(taskSlot: TaskSlot, env: Environment, pipeNameOnEnv: string): BuildTask[] {\n  const buildTasks: BuildTask[] = env[pipeNameOnEnv] ? env[pipeNameOnEnv]() : [];\n  const slotsTasks = taskSlot.values().flat();\n  const tasksAtStart: BuildTask[] = [];\n  const tasksAtEnd: BuildTask[] = [];\n  slotsTasks.forEach((task) => {\n    if (task.location === 'start') {\n      tasksAtStart.push(task);\n      return;\n    }\n    if (task.location === 'end') {\n      tasksAtEnd.push(task);\n      return;\n    }\n    tasksAtStart.push(task);\n  });\n\n  // merge with extension registered tasks.\n  const mergedTasks = [...tasksAtStart, ...buildTasks, ...tasksAtEnd];\n\n  return mergedTasks;\n}\n"]}