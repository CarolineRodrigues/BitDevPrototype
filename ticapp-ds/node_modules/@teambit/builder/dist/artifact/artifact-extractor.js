"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.unscopables.flat.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArtifactExtractor = void 0;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _minimatch() {
  const data = _interopRequireDefault(require("minimatch"));

  _minimatch = function () {
    return data;
  };

  return data;
}

function _artifactFiles() {
  const data = require("@teambit/legacy/dist/consumer/component/sources/artifact-files");

  _artifactFiles = function () {
    return data;
  };

  return data;
}

class ArtifactExtractor {
  constructor(scope, builder, patterns, options) {
    this.scope = scope;
    this.builder = builder;
    this.patterns = patterns;
    this.options = options;
  }

  async list() {
    const components = await this.scope.byPattern(this.patterns);
    const artifactObjectsPerId = components.map(component => {
      return {
        id: component.id,
        artifacts: this.builder.getArtifacts(component) || []
      };
    });
    this.filterByOptions(artifactObjectsPerId);
    await this.saveFilesInFileSystemIfAsked(artifactObjectsPerId);
    return this.artifactsObjectsToExtractorResults(artifactObjectsPerId);
  }

  groupResultsByAspect(extractorResult) {
    return extractorResult.map(result => {
      const artifacts = result.artifacts.reduce((acc, current) => {
        var _current$aspectId;

        (acc[_current$aspectId = current.aspectId] || (acc[_current$aspectId] = [])).push(current);
        return acc;
      }, {});
      return {
        id: result.id,
        artifacts
      };
    });
  }

  async saveFilesInFileSystemIfAsked(artifactObjectsPerId) {
    const outDir = this.options.outDir;

    if (!outDir) {
      return;
    } // @todo: optimize this to first import all missing hashes.


    await (0, _pMapSeries().default)(artifactObjectsPerId, async ({
      id,
      artifacts
    }) => {
      const vinyls = await Promise.all(artifacts.map(artifactObject => artifactObject.files.getVinylsAndImportIfMissing(id.scope, this.scope.legacyScope)));
      const flattenedVinyls = vinyls.flat();

      const compPath = _path().default.join(outDir, id.toStringWithoutVersion());

      await Promise.all(flattenedVinyls.map(vinyl => _fsExtra().default.outputFile(_path().default.join(compPath, vinyl.path), vinyl.contents)));
    });
  }

  artifactsObjectsToExtractorResults(artifactObjectsPerId) {
    return artifactObjectsPerId.map(({
      id,
      artifacts
    }) => {
      const results = artifacts.map(artifact => {
        return {
          aspectId: artifact.task.id,
          taskName: artifact.task.name || artifact.generatedBy,
          files: artifact.files.refs.map(ref => ref.relativePath)
        };
      });
      return {
        id,
        artifacts: results
      };
    });
  }

  filterByOptions(artifactObjectsPerId) {
    const {
      aspect,
      task,
      files
    } = this.options;
    artifactObjectsPerId.forEach(item => {
      item.artifacts = item.artifacts.filter(artifact => {
        if (aspect && aspect !== artifact.task.id) return false;
        if (task && task !== artifact.task.name) return false;
        return true;
      });

      if (files) {
        item.artifacts.forEach(artifact => {
          const refs = artifact.files.refs.filter(ref => (0, _minimatch().default)(ref.relativePath, files));
          artifact.files = new (_artifactFiles().ArtifactFiles)([], [], refs);
        }); // remove artifacts with no files

        item.artifacts = item.artifacts.filter(artifact => artifact.files.refs.length);
      }
    });
  }

}

exports.ArtifactExtractor = ArtifactExtractor;

//# sourceMappingURL=artifact-extractor.js.map