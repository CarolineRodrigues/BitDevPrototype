{"version":3,"sources":["build-task.ts"],"names":["TaskIdDelimiter","CAPSULE_ARTIFACTS_DIR","BuildTaskHelper","serializeId","aspectId","name","deserializeId","id","split","length","Error","deserializeIdAllowEmptyName","includes","undefined"],"mappings":";;;;;;;;;AAUA;AACA;AACA;AACO,MAAMA,eAAe,GAAG,GAAxB;AAEP;AACA;AACA;AACA;;;AACO,MAAMC,qBAAqB,GAAG,WAA9B;;;AA8FA,MAAMC,eAAN,CAAsB;AACT,SAAXC,WAAW,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,GAAD,EAAiE;AACjF,WAAOD,QAAQ,GAAGJ,eAAX,GAA6BK,IAApC;AACD;;AACmB,SAAbC,aAAa,CAACC,EAAD,EAAiD;AACnE,UAAMC,KAAK,GAAGD,EAAE,CAACC,KAAH,CAASR,eAAT,CAAd;AACA,QAAIQ,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB,MAAM,IAAIC,KAAJ,CAAW,kBAAiBH,EAAG,WAA/B,CAAN;AACxB,QAAIC,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB,MAAM,IAAIC,KAAJ,CAAW,kBAAiBH,EAAG,kCAA/B,CAAN;AACxB,QAAIC,KAAK,CAACC,MAAN,KAAiB,CAArB,EAAwB,OAAO;AAAEL,MAAAA,QAAQ,EAAEI,KAAK,CAAC,CAAD,CAAjB;AAAsBH,MAAAA,IAAI,EAAEG,KAAK,CAAC,CAAD;AAAjC,KAAP;AACxB,UAAM,IAAIE,KAAJ,CAAW,qBAAoBH,EAAG,sBAAqBP,eAAgB,EAAvE,CAAN;AACD;AACD;AACF;AACA;AACA;;;AACoC,SAA3BW,2BAA2B,CAACJ,EAAD,EAAkD;AAClF,WAAOA,EAAE,CAACK,QAAH,CAAYZ,eAAZ,IAA+BE,eAAe,CAACI,aAAhB,CAA8BC,EAA9B,CAA/B,GAAmE;AAAEH,MAAAA,QAAQ,EAAEG,EAAZ;AAAgBF,MAAAA,IAAI,EAAEQ;AAAtB,KAA1E;AACD;;AAjB0B","sourcesContent":["import type { Component } from '@teambit/component';\nimport { ExecutionContext } from '@teambit/envs';\nimport type { Network } from '@teambit/isolator';\nimport type { ComponentResult } from './types';\nimport type { ArtifactDefinition } from './artifact';\nimport { TaskResultsList } from './task-results-list';\nimport { TaskResults } from './build-pipe';\n\nexport type TaskLocation = 'start' | 'end';\n\n/**\n * delimiter between task.aspectId and task.name\n */\nexport const TaskIdDelimiter = ':';\n\n/**\n * A folder to write artifacts generated during a build task\n * This folder is used in the core envs and excluded by default from the package tar file (the core envs is writing this into the npmignore file)\n */\nexport const CAPSULE_ARTIFACTS_DIR = 'artifacts';\n\nexport interface BuildContext extends ExecutionContext {\n  /**\n   * all components about to be built/tagged.\n   */\n  components: Component[];\n\n  /**\n   * network of capsules ready to be built.\n   */\n  capsuleNetwork: Network;\n\n  /**\n   * data generated by tasks that were running before this task\n   */\n  previousTasksResults: TaskResults[];\n\n  /**\n   * Run the build pipeline in dev mode\n   */\n  dev?: boolean;\n}\n\nexport interface BuildTask {\n  /**\n   * aspect id serialized of the creator of the task.\n   * todo: automate this so then it won't be needed to pass manually.\n   */\n  aspectId: string;\n\n  /**\n   * name of the task. function as an identifier among other tasks of the same aspectId.\n   * spaces and special characters are not allowed. as a convention, use UpperCamelCase style.\n   * (e.g. TypescriptCompiler).\n   */\n  name: string;\n\n  /**\n   * description of what the task does.\n   * if available, the logger will log it show it in the status-line.\n   */\n  description?: string;\n\n  /**\n   * where to put the task, before the env pipeline or after\n   */\n  location?: TaskLocation;\n\n  /**\n   * execute a task in a build context\n   */\n  execute(context: BuildContext): Promise<BuiltTaskResult>;\n\n  /**\n   * run before the build pipeline has started. this is useful when some preparation are needed to\n   * be done on all envs before the build starts.\n   * e.g. typescript compiler needs to write the tsconfig file. doing it during the task, will\n   * cause dependencies from other envs to get this tsconfig written.\n   */\n  preBuild?(context: BuildContext): Promise<void>;\n\n  /**\n   * run after the build pipeline completed for all envs. useful for doing some cleanup on the\n   * capsules before the deployment starts.\n   */\n  postBuild?(context: BuildContext, tasksResults: TaskResultsList): Promise<void>;\n\n  /**\n   * needed if you want the task to be running only after the dependencies were completed\n   * for *all* envs.\n   * normally this is not needed because the build-pipeline runs the tasks in the same order\n   * they're located in the `getBuildPipe()` array and according to the task.location.\n   * the case where this is useful is when a task not only needs to be after another task, but also\n   * after all environments were running that task.\n   * a dependency is task.aspectId. if an aspect has multiple tasks, to be more specific, use\n   * \"aspectId:name\", e.g. \"teambit.compilation/compiler:TypescriptCompiler\".\n   */\n  dependencies?: string[];\n}\n\n// TODO: rename to BuildTaskResults\nexport interface BuiltTaskResult {\n  /**\n   * build results for each of the components in the build context.\n   */\n  componentsResults: ComponentResult[];\n\n  /**\n   * array of artifact definitions to generate after a successful build.\n   */\n  artifacts?: ArtifactDefinition[];\n}\n\nexport class BuildTaskHelper {\n  static serializeId({ aspectId, name }: { aspectId: string; name: string }): string {\n    return aspectId + TaskIdDelimiter + name;\n  }\n  static deserializeId(id: string): { aspectId: string; name: string } {\n    const split = id.split(TaskIdDelimiter);\n    if (split.length === 0) throw new Error(`deserializeId, ${id} is empty`);\n    if (split.length === 1) throw new Error(`deserializeId, ${id} has only aspect-id without name`);\n    if (split.length === 2) return { aspectId: split[0], name: split[1] };\n    throw new Error(`deserializeId, id ${id} has more than one ${TaskIdDelimiter}`);\n  }\n  /**\n   * don't throw an error when the id includes only the aspect-id without the task name.\n   * useful for task dependencies, when it's allowed to specify the aspect-id only.\n   */\n  static deserializeIdAllowEmptyName(id: string): { aspectId: string; name?: string } {\n    return id.includes(TaskIdDelimiter) ? BuildTaskHelper.deserializeId(id) : { aspectId: id, name: undefined };\n  }\n}\n"]}