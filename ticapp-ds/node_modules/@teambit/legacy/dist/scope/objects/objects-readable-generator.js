"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectsReadableGenerator = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");

  _traverseVersions = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

class ObjectsReadableGenerator {
  constructor(repo) {
    this.repo = repo;
    (0, _defineProperty2().default)(this, "readable", void 0);
    (0, _defineProperty2().default)(this, "pushed", []);
    this.readable = new (_stream().Readable)({
      objectMode: true,

      read() {}

    });
  }

  async pushObjectsToReadable(componentsWithOptions) {
    try {
      await this.pushScopeMeta();
      await (0, _pMapSeries().default)(componentsWithOptions, async componentWithOptions => this.pushComponentObjects(componentWithOptions));
      this.readable.push(null);
    } catch (err) {
      this.readable.destroy(err);
    }
  }

  async pushLanes(lanesToFetch) {
    try {
      await Promise.all(lanesToFetch.map(async laneToFetch => {
        const laneBuffer = await laneToFetch.compress();
        this.push({
          ref: laneToFetch.hash(),
          buffer: laneBuffer
        });
      }));
      this.readable.push(null);
    } catch (err) {
      this.readable.destroy(err);
    }
  }

  async pushObjects(refs, scope) {
    try {
      await (0, _pMapSeries().default)(refs, async ref => {
        const objectItem = await scope.getObjectItem(ref);
        this.push(objectItem);
      });
      this.readable.push(null);
    } catch (err) {
      this.readable.destroy(err);
    }
  }

  async pushScopeMeta() {
    const scopeMeta = await this.repo.getScopeMetaObject();
    this.push(scopeMeta);
  }

  push(obj) {
    const hashStr = obj.ref.toString();

    if (this.pushed.includes(hashStr)) {
      return;
    }

    _logger().default.trace('ObjectsReadableGenerator.push', hashStr);

    this.readable.push(obj);
    this.pushed.push(hashStr);
  }

  pushManyObjects(objects) {
    objects.map(obj => this.push(obj));
  }

  async pushComponentObjects(componentWithOptions) {
    const {
      component,
      collectParents,
      collectArtifacts,
      collectParentsUntil
    } = componentWithOptions;
    const version = await component.loadVersion(componentWithOptions.version, this.repo, false);
    if (!version) throw new (_showDoctorError().default)(`failed loading version ${componentWithOptions.version} of ${component.id()}`);

    if (collectParentsUntil && version.hash().isEqual(collectParentsUntil)) {
      return;
    }

    const collectVersionObjects = async ver => {
      const versionRefs = ver.refsWithOptions(collectParents, collectArtifacts);
      const versionObjects = await ver.collectManyObjects(this.repo, versionRefs);
      const versionData = {
        ref: ver.hash(),
        buffer: await ver.asRaw(this.repo),
        type: ver.getType()
      };
      return [...versionObjects, versionData];
    };

    try {
      const componentData = {
        ref: component.hash(),
        buffer: await component.asRaw(this.repo),
        type: component.getType()
      };

      if (collectParents) {
        const parentsObjects = [];
        const allParentsHashes = await (0, _traverseVersions().getAllVersionHashes)(component, this.repo, true, version.hash(), collectParentsUntil);
        const missingParentsHashes = allParentsHashes.filter(h => !h.isEqual(version.hash()));
        await Promise.all(missingParentsHashes.map(async parentHash => {
          const parentVersion = await parentHash.load(this.repo);
          const parentsObj = await collectVersionObjects(parentVersion);
          parentsObjects.push(...parentsObj);
        }));
        this.pushManyObjects(parentsObjects);
      }

      const versionObjects = await collectVersionObjects(version);
      this.pushManyObjects(versionObjects);
      this.push(componentData);
    } catch (err) {
      _logger().default.error(`component-version.toObjects ${componentWithOptions.component.id()} got an error`, err); // @ts-ignore


      const originalVersionHash = component.getRef(componentWithOptions.version).toString();
      const currentVersionHash = version.hash().toString();

      if (originalVersionHash !== currentVersionHash) {
        throw new (_exceptions().HashMismatch)(component.id(), componentWithOptions.version, originalVersionHash, currentVersionHash);
      }

      throw err;
    }
  }

}

exports.ObjectsReadableGenerator = ObjectsReadableGenerator;