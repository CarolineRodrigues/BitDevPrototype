import { BitId, BitIds } from '../bit-id';
import { BitIdStr } from '../bit-id/bit-id';
import Component from '../consumer/component/consumer-component';
import Dists from '../consumer/component/sources/dists';
import { ExtensionDataEntry } from '../consumer/config';
import Consumer from '../consumer/consumer';
import SpecsResults from '../consumer/specs-results';
import { SpecsResultsWithComponentId } from '../consumer/specs-results/specs-results';
import LaneId from '../lane-id/lane-id';
import { MigrationResult } from '../migration/migration-helper';
import { PathOsBasedAbsolute } from '../utils/path';
import ScopeComponentsImporter from './component-ops/scope-components-importer';
import ComponentVersion from './component-version';
import DependencyGraph from './graph/scope-graph';
import Lanes from './lanes/lanes';
import { ModelComponent, Symlink, Version } from './models';
import Lane from './models/lane';
import { ComponentLog } from './models/model-component';
import { BitObject, BitRawObject, Ref, Repository } from './objects';
import RemovedObjects from './removed-components';
import { Tmp } from './repositories';
import SourcesRepository from './repositories/sources';
import { ScopeJson } from './scope-json';
import VersionDependencies from './version-dependencies';
import { ObjectItem, ObjectList } from './objects/object-list';
declare type HasIdOpts = {
    includeSymlink?: boolean;
    includeOrphaned?: boolean;
    includeVersion?: boolean;
};
export declare type ScopeDescriptor = {
    name: string;
};
export declare type ScopeProps = {
    path: string;
    scopeJson: ScopeJson;
    created?: boolean;
    tmp?: Tmp;
    sources?: SourcesRepository;
    objects: Repository;
    isBare?: boolean;
};
export declare type IsolateOptions = {
    directory: string | null | undefined;
    write_bit_dependencies: boolean | null | undefined;
    links: boolean | null | undefined;
    install_packages: boolean | null | undefined;
    installPeerDependencies: boolean | null | undefined;
    no_package_json: boolean | null | undefined;
    override: boolean | null | undefined;
};
export declare type ComponentsAndVersions = {
    component: ModelComponent;
    version: Version;
    versionStr: string;
};
export declare type LegacyOnTagResult = {
    id: BitId;
    builderData: ExtensionDataEntry;
};
export declare type OnTagOpts = {
    disableTagAndSnapPipelines?: boolean;
    throwOnError?: boolean;
    forceDeploy?: boolean;
    skipTests?: boolean;
    isSnap?: boolean;
};
export declare type OnTagFunc = (components: Component[], options?: OnTagOpts) => Promise<LegacyOnTagResult[]>;
export default class Scope {
    created: boolean;
    scopeJson: ScopeJson;
    tmp: Tmp;
    path: string;
    isBare: boolean;
    scopeImporter: ScopeComponentsImporter;
    sources: SourcesRepository;
    objects: Repository;
    _dependencyGraph: DependencyGraph;
    lanes: Lanes;
    constructor(scopeProps: ScopeProps);
    onTag: OnTagFunc[];
    static onPostExport: (ids: BitId[], lanes: Lane[]) => Promise<void>;
    /**
     * import components to the `Scope.
     */
    import(ids: BitIds, cache?: boolean, reFetchUnBuiltVersion?: boolean): Promise<VersionDependencies[]>;
    getDependencyGraph(): Promise<DependencyGraph>;
    get groupName(): string | null | undefined;
    get name(): string;
    get isLegacy(): boolean;
    getPath(): string;
    getComponentsPath(): string;
    /**
     * Get the relative components path inside the scope
     * (components such as compilers / testers / extensions)
     * currently components
     */
    static getComponentsRelativePath(): string;
    /**
     * Get a relative (to scope) path to a specific component such as compiler / tester / extension
     * Support getting the latest installed version
     * @param {BitId} id
     */
    static getComponentRelativePath(id: BitId, scopePath?: string): string;
    getBitPathInComponentsDir(id: BitId): string;
    /**
     * Running migration process for scope to update the stores (bit objects) to the current version
     *
     * @param {any} verbose - print debug logs
     * @returns {Object} - wether the process run and wether it successeded
     * @memberof Consumer
     */
    migrate(verbose: boolean): Promise<MigrationResult>;
    describe(): ScopeDescriptor;
    toConsumerComponents(components: ModelComponent[]): Promise<Component[]>;
    hasId(id: BitId, opts: HasIdOpts): Promise<boolean>;
    list(): Promise<ModelComponent[]>;
    listIncludesSymlinks(): Promise<Array<ModelComponent | Symlink>>;
    listIncludeRemoteHead(laneId: LaneId): Promise<ModelComponent[]>;
    listLocal(): Promise<ModelComponent[]>;
    listLanes(): Promise<Lane[]>;
    loadLane(id: LaneId): Promise<Lane | null>;
    latestVersions(componentIds: BitId[], throwOnFailure?: boolean): Promise<BitIds>;
    /**
     * Build multiple components sequentially, not in parallel.
     *
     * Two reasons why not running them in parallel:
     * 1) when several components have the same environment, it'll try to install them multiple times.
     * 2) npm throws errors when running 'npm install' from several directories
     *
     * Also, make sure to first build and write dists files of all components, and only then, write
     * the links inside the dists. otherwise, you it could fail when writing links of one component
     * needs another component dists files. (see 'importing all components and then deleting the dist
     * directory' test case)
     */
    buildMultiple(components: Component[], consumer: Consumer, noCache: boolean, verbose: boolean, dontPrintEnvMsg?: boolean | undefined): Promise<{
        component: string;
        buildResults: string[] | null | undefined;
    }[]>;
    /**
     * when custom-module-resolution is used, the test process needs to set the custom module
     * directory to the dist directory
     */
    injectNodePathIfNeeded(consumer: Consumer, components: Component[]): void;
    /**
     * Test multiple components sequentially, not in parallel.
     *
     * See the reason not to run them in parallel at @buildMultiple()
     */
    testMultiple({ components, consumer, verbose, dontPrintEnvMsg, rejectOnFailure, }: {
        components: Component[];
        consumer: Consumer;
        verbose: boolean;
        dontPrintEnvMsg?: boolean;
        rejectOnFailure?: boolean;
    }): Promise<SpecsResultsWithComponentId>;
    getObject(hash: string): Promise<BitObject>;
    getRawObject(hash: string): Promise<BitRawObject>;
    getObjectItems(refs: Ref[]): Promise<ObjectItem[]>;
    getObjectItem(ref: Ref): Promise<ObjectItem>;
    getModelComponentIfExist(id: BitId): Promise<ModelComponent | undefined>;
    getCurrentLaneObject(): Promise<Lane | null>;
    /**
     * Remove components from scope
     * @force Boolean - remove component from scope even if other components use it
     */
    removeMany(bitIds: BitIds, force: boolean, consumer?: Consumer): Promise<RemovedObjects>;
    /**
     * for each one of the given components, find its dependents
     */
    getDependentsBitIds(bitIds: BitIds, returnResultsWithVersion?: boolean): Promise<{
        [key: string]: BitId[];
    }>;
    /**
     * split bit array to found and missing components (incase user misspelled id)
     */
    filterFoundAndMissingComponents(bitIds: BitIds): Promise<{
        missingComponents: BitIds;
        foundComponents: BitIds;
    }>;
    /**
     * load components from the model and return them as ComponentVersion array.
     * if a component is not available locally, it'll just ignore it without throwing any error.
     */
    loadLocalComponents(ids: BitIds): Promise<ComponentVersion[]>;
    loadComponentLogs(id: BitId, shortHash?: boolean, startFrom?: string): Promise<ComponentLog[]>;
    loadAllVersions(id: BitId): Promise<Component[]>;
    /**
     * get ModelComponent instance per bit-id.
     * it throws an error if the component wasn't found.
     * @see getModelComponentIfExist to not throw an error
     * @see getModelComponentIgnoreScope to ignore the scope name
     */
    getModelComponent(id: BitId): Promise<ModelComponent>;
    /**
     * the id can be either with or without a scope-name.
     * in case the component is saved in the model only with the scope (imported), it loads all
     * components and search for it.
     * it throws an error if the component wasn't found.
     */
    getModelComponentIgnoreScope(id: BitId): Promise<ModelComponent>;
    /**
     * throws if component was not found
     */
    getConsumerComponent(id: BitId): Promise<Component>;
    getManyConsumerComponents(ids: BitId[]): Promise<Component[]>;
    /**
     * return undefined if component was not found
     */
    getConsumerComponentIfExist(id: BitId): Promise<Component | undefined>;
    getVersionInstance(id: BitId): Promise<Version>;
    getComponentsAndVersions(ids: BitIds, defaultToLatestVersion?: boolean): Promise<ComponentsAndVersions[]>;
    isComponentInScope(id: BitId): Promise<boolean>;
    getComponentsAndAllLocalUnexportedVersions(ids: BitIds): Promise<ComponentsAndVersions[]>;
    /**
     * Creates a symlink object with the local-scope which links to the real-object of the remote-scope
     * This way, local components that have dependencies to the exported component won't break.
     */
    createSymlink(id: BitId, remote: string): Repository;
    ensureDir(): Promise<this>;
    /**
     * find the components in componentsPool which one of their dependencies include in potentialDependencies
     */
    findDirectDependentComponents(componentsPool: BitIds, potentialDependencies: BitIds): Promise<BitIds>;
    runComponentSpecs({ bitId, consumer, save, verbose, isolated, directory, keep, }: {
        bitId: BitId;
        consumer?: Consumer;
        save?: boolean;
        verbose?: boolean;
        isolated?: boolean;
        directory?: string;
        keep?: boolean;
    }): Promise<SpecsResults | undefined>;
    build({ bitId, save, consumer, verbose, directory, keep, noCache, }: {
        bitId: BitId;
        save?: boolean;
        consumer?: Consumer;
        verbose?: boolean;
        directory?: string;
        keep?: boolean;
        noCache?: boolean;
    }): Promise<Dists | undefined>;
    loadModelComponentByIdStr(id: string): Promise<ModelComponent>;
    getParsedId(id: BitIdStr): Promise<BitId>;
    writeObjectsToPendingDir(objectList: ObjectList, clientId: string): Promise<void>;
    readObjectsFromPendingDir(clientId: string): Promise<ObjectList>;
    removePendingDir(clientId: string): Promise<void>;
    static ensure(path: PathOsBasedAbsolute, name?: string | null, groupName?: string | null): Promise<Scope>;
    static ensureScopeJson(path: PathOsBasedAbsolute, name?: string | null | undefined, groupName?: string | null | undefined): ScopeJson;
    static scopeCache: {
        [path: string]: Scope;
    };
    static reset(path: PathOsBasedAbsolute, resetHard: boolean): Promise<void>;
    static load(absPath: string, useCache?: boolean): Promise<Scope>;
}
export {};
