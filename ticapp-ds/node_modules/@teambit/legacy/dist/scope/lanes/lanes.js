"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = _interopRequireWildcard(require("../../lane-id/lane-id"));

  _laneId = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _componentsIndex() {
  const data = require("../objects/components-index");

  _componentsIndex = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Lanes {
  constructor(objects, scopeJson) {
    (0, _defineProperty2().default)(this, "objects", void 0);
    (0, _defineProperty2().default)(this, "scopeJson", void 0);
    this.objects = objects;
    this.scopeJson = scopeJson;
  }

  async listLanes() {
    return await this.objects.listObjectsFromIndex(_componentsIndex().IndexType.lanes);
  }
  /** dont use it outside of Lanes. Use scope.loadLane instead */


  async loadLane(id) {
    if (id.isDefault()) return null; // main lane is not saved

    const filter = lane => lane.toLaneId().isEqual(id);

    const hash = this.objects.getHashFromIndex(_componentsIndex().IndexType.lanes, filter);
    if (!hash) return null;
    return await this.objects.load(new (_objects().Ref)(hash));
  }

  async saveLane(laneObject) {
    await this.objects.writeObjectsToTheFS([laneObject]);
  }

  getCurrentLaneName() {
    const laneName = this.scopeJson.lanes.current; // backward compatibility, in the past, the default lane was master

    if (laneName === 'master') return _constants().DEFAULT_LANE;
    return laneName;
  }

  isOnDefaultLane() {
    const currentLane = this.getCurrentLaneName();
    return currentLane === _constants().DEFAULT_LANE;
  }

  getCurrentLaneId() {
    return _laneId().LocalLaneId.from(this.getCurrentLaneName() || _constants().DEFAULT_LANE);
  }

  async getCurrentLaneObject() {
    return this.loadLane(this.getCurrentLaneId());
  }

  setCurrentLane(laneName) {
    this.scopeJson.setCurrentLane(laneName);
  }

  getLocalTrackedLaneByRemoteName(remoteLane, remoteScope) {
    const trackedLane = this.scopeJson.lanes.tracking.find(t => t.remoteLane === remoteLane && t.remoteScope === remoteScope);
    return trackedLane ? trackedLane.localLane : null;
  }

  getRemoteTrackedDataByLocalLane(localLane) {
    return this.scopeJson.lanes.tracking.find(t => t.localLane === localLane);
  }

  trackLane(trackLaneData) {
    this.scopeJson.trackLane(trackLaneData);
  }

  async removeLanes(scope, lanes, force) {
    const existingLanes = await this.listLanes();
    const lanesToRemove = lanes.map(laneName => {
      if (laneName === _constants().DEFAULT_LANE) throw new (_generalError().default)(`unable to remove the default lane "${_constants().DEFAULT_LANE}"`);
      if (laneName === this.getCurrentLaneName()) throw new (_generalError().default)(`unable to remove the currently used lane "${laneName}"`);
      const existingLane = existingLanes.find(l => l.name === laneName);
      if (!existingLane) throw new (_generalError().default)(`lane ${laneName} was not found in scope`);
      return existingLane;
    });

    if (!force) {
      await Promise.all(lanesToRemove.map(async laneObj => {
        const isFullyMerged = await laneObj.isFullyMerged(scope);

        if (!isFullyMerged) {
          // @todo: this error comes pretty ugly to the client when removing from a lane from remote using ssh
          throw new (_generalError().default)(`unable to remove ${laneObj.name} lane, it is not fully merged. to disregard this error, please use --force flag`);
        }
      }));
    }

    await this.objects.deleteObjectsFromFS(lanesToRemove.map(l => l.hash()));
    return lanes;
  }

  async getLanesData(scope, name, mergeData) {
    const getLaneDataOfLane = async laneObject => {
      const laneName = laneObject.name;
      const trackingData = this.getRemoteTrackedDataByLocalLane(laneName);
      return {
        name: laneName,
        remote: trackingData ? `${trackingData.remoteScope}${_constants().LANE_REMOTE_DELIMITER}${trackingData.remoteLane}` : null,
        components: laneObject.components.map(c => ({
          id: c.id,
          head: c.head.toString()
        })),
        isMerged: mergeData ? await laneObject.isFullyMerged(scope) : null
      };
    };

    if (name) {
      const laneObject = await this.loadLane(_laneId().default.from(name));
      if (!laneObject) throw new (_generalError().default)(`lane "${name}" was not found`);
      return [await getLaneDataOfLane(laneObject)];
    }

    const lanesObjects = await this.listLanes();
    const lanes = await Promise.all(lanesObjects.map(laneObject => getLaneDataOfLane(laneObject)));
    return lanes;
  }

}

exports.default = Lanes;