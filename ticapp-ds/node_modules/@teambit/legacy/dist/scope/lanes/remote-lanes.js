"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _asyncMutex() {
  const data = require("async-mutex");

  _asyncMutex = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

/**
 * each lane holds components and hashes, which are the heads of the remote
 */
class RemoteLanes {
  constructor(scopePath) {
    (0, _defineProperty2().default)(this, "basePath", void 0);
    (0, _defineProperty2().default)(this, "remotes", void 0);
    (0, _defineProperty2().default)(this, "writeMutex", new (_asyncMutex().Mutex)());
    this.basePath = _path().default.join(scopePath, _constants().REMOTE_REFS_DIR);
    this.remotes = {};
  }

  async addEntry(remoteLaneId, componentId, head) {
    if (!remoteLaneId) throw new TypeError('addEntry expects to get remoteLaneId');
    if (!head) return; // do nothing

    const remoteLane = await this.getRemoteLane(remoteLaneId);
    this.pushToRemoteLane(remoteLane, componentId, head);
  }

  pushToRemoteLane(remoteLane, componentId, head) {
    const existingComponent = remoteLane.find(n => n.id.isEqualWithoutVersion(componentId));

    if (existingComponent) {
      existingComponent.head = head;
    } else {
      remoteLane.push({
        id: componentId,
        head
      });
    }
  }

  async addEntriesFromModelComponents(remoteLaneId, components) {
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    components.forEach(component => {
      if (!component.remoteHead) return;
      this.pushToRemoteLane(remoteLane, component.toBitId(), component.remoteHead);
    });
  }

  async getRef(remoteLaneId, bitId) {
    if (!remoteLaneId) throw new TypeError('getEntry expects to get remoteLaneId');

    if (!this.remotes[remoteLaneId.scope] || !this.remotes[remoteLaneId.scope][remoteLaneId.name]) {
      await this.loadRemoteLane(remoteLaneId);
    }

    const remoteLane = this.remotes[remoteLaneId.scope][remoteLaneId.name];
    const existingComponent = remoteLane.find(n => n.id.isEqualWithoutVersion(bitId));
    if (!existingComponent) return null;
    return existingComponent.head;
  }

  async getRemoteLane(remoteLaneId) {
    if (!this.remotes[remoteLaneId.scope] || !this.remotes[remoteLaneId.scope][remoteLaneId.name]) {
      await this.loadRemoteLane(remoteLaneId);
    }

    return this.remotes[remoteLaneId.scope][remoteLaneId.name];
  }

  async getRemoteBitIds(remoteLaneId) {
    const remoteLane = await this.getRemoteLane(remoteLaneId);
    return remoteLane.map(item => item.id.changeVersion(item.head.toString()));
  }

  async loadRemoteLane(remoteLaneId) {
    const remoteName = remoteLaneId.scope;
    const laneName = remoteLaneId.name;
    const remoteLanePath = this.composeRemoteLanePath(remoteName, laneName);

    try {
      const remoteFile = await _fsExtra().default.readJson(remoteLanePath);
      if (!this.remotes[remoteName]) this.remotes[remoteName] = {};
      this.remotes[remoteName][laneName] = remoteFile.map(({
        id,
        head
      }) => ({
        id: new (_bitId().BitId)({
          scope: id.scope,
          name: id.name
        }),
        head: new (_objects().Ref)(head)
      }));
    } catch (err) {
      if (err.code === 'ENOENT') {
        if (!this.remotes[remoteName]) this.remotes[remoteName] = {};
        this.remotes[remoteName][laneName] = [];
        return;
      }

      throw err;
    }
  }

  async getAllRemoteLaneIds() {
    const matches = await (0, _utils().glob)(_path().default.join('*', '*'), {
      cwd: this.basePath
    }); // in the future, lane-name might have slashes, so until the first slash is the scope.
    // the rest are the name

    return matches.map(match => match.split(_path().default.sep)).map(([head, ...tail]) => _laneId().RemoteLaneId.from(tail.join('/'), head)).filter(remoteLaneId => !remoteLaneId.isDefault() && remoteLaneId.name !== _constants().PREVIOUS_DEFAULT_LANE);
  }

  async syncWithLaneObject(remoteName, lane) {
    const remoteLaneId = _laneId().RemoteLaneId.from(lane.name, remoteName);

    if (!this.remotes[remoteName] || !this.remotes[remoteName][lane.name]) {
      await this.loadRemoteLane(remoteLaneId);
    }

    await Promise.all(lane.components.map(component => this.addEntry(remoteLaneId, component.id, component.head)));
  }

  composeRemoteLanePath(remoteName, laneName) {
    return _path().default.join(this.basePath, remoteName, laneName);
  }

  async write() {
    await this.writeMutex.runExclusive(() => Promise.all(Object.keys(this.remotes).map(remoteName => this.writeRemoteLanes(remoteName))));
  }

  async writeRemoteLanes(remoteName) {
    return Promise.all(Object.keys(this.remotes[remoteName]).map(laneName => this.writeRemoteLaneFile(remoteName, laneName)));
  }

  async writeRemoteLaneFile(remoteName, laneName) {
    const obj = this.remotes[remoteName][laneName].map(({
      id,
      head
    }) => ({
      id: {
        scope: id.scope,
        name: id.name
      },
      head: head.toString()
    }));
    return _fsExtra().default.outputFile(this.composeRemoteLanePath(remoteName, laneName), JSON.stringify(obj, null, 2));
  }

}

exports.default = RemoteLanes;