"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));

  _isNil2 = function () {
    return data;
  };

  return data;
}

function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));

  _reject2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function pathLib() {
  const data = _interopRequireWildcard(require("path"));

  pathLib = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _dists() {
  const data = _interopRequireDefault(require("../consumer/component/sources/dists"));

  _dists = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _migrationHelper() {
  const data = _interopRequireDefault(require("../migration/migration-helper"));

  _migrationHelper = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _removeModelComponents() {
  const data = _interopRequireDefault(require("./component-ops/remove-model-components"));

  _removeModelComponents = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("./component-ops/scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _scopeGraph() {
  const data = _interopRequireDefault(require("./graph/scope-graph"));

  _scopeGraph = function () {
    return data;
  };

  return data;
}

function _lanes() {
  const data = _interopRequireDefault(require("./lanes/lanes"));

  _lanes = function () {
    return data;
  };

  return data;
}

function _scopeMigrator() {
  const data = _interopRequireDefault(require("./migrations/scope-migrator"));

  _scopeMigrator = function () {
    return data;
  };

  return data;
}

function _scopeMigratorManifest() {
  const data = _interopRequireDefault(require("./migrations/scope-migrator-manifest"));

  _scopeMigratorManifest = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("./models");

  _models = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("./objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _componentsIndex() {
  const data = require("./objects/components-index");

  _componentsIndex = function () {
    return data;
  };

  return data;
}

function _repositories() {
  const data = require("./repositories");

  _repositories = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = _interopRequireDefault(require("./repositories/sources"));

  _sources = function () {
    return data;
  };

  return data;
}

function _scopeJson() {
  const data = require("./scope-json");

  _scopeJson = function () {
    return data;
  };

  return data;
}

function _clientIdInUse() {
  const data = _interopRequireDefault(require("./exceptions/client-id-in-use"));

  _clientIdInUse = function () {
    return data;
  };

  return data;
}

function _unexpectedPackageName() {
  const data = require("../consumer/exceptions/unexpected-package-name");

  _unexpectedPackageName = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const removeNils = (0, _reject2().default)(_isNil2().default);
const pathHasScope = (0, _utils().pathHasAll)([_constants().OBJECTS_DIR, _constants().SCOPE_JSON]);

class Scope {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // cache DependencyGraph instance
  constructor(scopeProps) {
    var _scopeProps$isBare;

    (0, _defineProperty2().default)(this, "created", false);
    (0, _defineProperty2().default)(this, "scopeJson", void 0);
    (0, _defineProperty2().default)(this, "tmp", void 0);
    (0, _defineProperty2().default)(this, "path", void 0);
    (0, _defineProperty2().default)(this, "isBare", false);
    (0, _defineProperty2().default)(this, "scopeImporter", void 0);
    (0, _defineProperty2().default)(this, "sources", void 0);
    (0, _defineProperty2().default)(this, "objects", void 0);
    (0, _defineProperty2().default)(this, "_dependencyGraph", void 0);
    (0, _defineProperty2().default)(this, "lanes", void 0);
    (0, _defineProperty2().default)(this, "onTag", []);
    this.path = scopeProps.path;
    this.scopeJson = scopeProps.scopeJson;
    this.created = scopeProps.created || false;
    this.tmp = scopeProps.tmp || new (_repositories().Tmp)(this);
    this.sources = scopeProps.sources || new (_sources().default)(this);
    this.objects = scopeProps.objects;
    this.lanes = new (_lanes().default)(this.objects, this.scopeJson);
    this.isBare = (_scopeProps$isBare = scopeProps.isBare) !== null && _scopeProps$isBare !== void 0 ? _scopeProps$isBare : false;
    this.scopeImporter = _scopeComponentsImporter().default.getInstance(this);
  }

  // enable extensions to hook after the export process

  /**
   * import components to the `Scope.
   */
  async import(ids, cache = true, reFetchUnBuiltVersion = true) {
    return this.scopeImporter.importMany({
      ids,
      cache,
      throwForDependencyNotFound: false,
      reFetchUnBuiltVersion
    });
  }

  async getDependencyGraph() {
    if (!this._dependencyGraph) {
      this._dependencyGraph = await _scopeGraph().default.loadAllVersions(this);
    }

    return this._dependencyGraph;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get groupName() {
    if (!this.scopeJson.groupName) return null;
    return this.scopeJson.groupName;
  }

  get name() {
    return this.scopeJson.name;
  }

  get isLegacy() {
    const harmonyScopeJsonPath = (0, _scopeJson().getHarmonyPath)(this.path);
    return !_fsExtra().default.existsSync(harmonyScopeJsonPath);
  }

  getPath() {
    return this.path;
  }

  getComponentsPath() {
    return pathLib().join(this.path, Scope.getComponentsRelativePath());
  }
  /**
   * Get the relative components path inside the scope
   * (components such as compilers / testers / extensions)
   * currently components
   */


  static getComponentsRelativePath() {
    return _constants().BITS_DIRNAME;
  }
  /**
   * Get a relative (to scope) path to a specific component such as compiler / tester / extension
   * Support getting the latest installed version
   * @param {BitId} id
   */


  static getComponentRelativePath(id, scopePath) {
    if (!id.scope) {
      throw new Error('could not find id.scope');
    }

    const relativePath = pathLib().join(id.name, id.scope);

    if (!id.getVersion().latest) {
      if (!id.version) {
        // brought closer because flow can't deduce if it's done in the beginning.
        throw new Error('could not find id.version');
      }

      return pathLib().join(relativePath, id.version);
    }

    if (!scopePath) {
      throw new Error(`could not find the latest version of ${id.toString()} without the scope path`);
    }

    const componentFullPath = pathLib().join(scopePath, Scope.getComponentsRelativePath(), relativePath);
    if (!_fsExtra().default.existsSync(componentFullPath)) return '';
    const versions = (0, _utils().readDirSyncIgnoreDsStore)(componentFullPath);

    const latestVersion = _semver().default.maxSatisfying(versions, '*', {
      includePrerelease: true
    }); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


    return pathLib().join(relativePath, latestVersion);
  }

  getBitPathInComponentsDir(id) {
    return pathLib().join(this.getComponentsPath(), id.toFullPath());
  }
  /**
   * Running migration process for scope to update the stores (bit objects) to the current version
   *
   * @param {any} verbose - print debug logs
   * @returns {Object} - wether the process run and wether it successeded
   * @memberof Consumer
   */


  async migrate(verbose) {
    _logger().default.trace('scope.migrate, running migration process for scope');

    if (verbose) console.log('running migration process for scope'); // eslint-disable-line
    // We start to use this process after version 0.10.9, so we assume the scope is in the last production version

    const scopeVersion = this.scopeJson.get('version') || '0.10.9';

    if (_semver().default.gte(scopeVersion, _constants().BIT_VERSION)) {
      const upToDateMsg = 'scope version is up to date';
      if (verbose) console.log(upToDateMsg); // eslint-disable-line

      _logger().default.trace(`scope.migrate, ${upToDateMsg}`);

      return {
        run: false
      };
    }

    _loader().default.start(_loaderMessages().BEFORE_MIGRATION);

    _logger().default.debugAndAddBreadCrumb('scope.migrate', `start scope migration. scope version ${scopeVersion}, bit version ${_constants().BIT_VERSION}`);

    const migrations = (0, _migrationHelper().default)(_constants().BIT_VERSION, scopeVersion, _scopeMigratorManifest().default, verbose);
    const rawObjects = migrations.length ? await this.objects.listRawObjects() : []; // @ts-ignore

    const resultObjects = await (0, _scopeMigrator().default)(migrations, rawObjects, verbose);

    if (!(0, _isEmpty2().default)(resultObjects.newObjects) || !(0, _isEmpty2().default)(resultObjects.refsToRemove)) {
      // Add the new / updated objects
      this.objects.addMany(resultObjects.newObjects); // Remove old objects

      this.objects.removeManyObjects(resultObjects.refsToRemove); // Persists new / remove objects

      const validateBeforePersist = false;
      await this.objects.persist(validateBeforePersist);
    } // Update the scope version


    this.scopeJson.set('version', _constants().BIT_VERSION);

    _logger().default.debugAndAddBreadCrumb('scope.migrate', `updating scope version to version ${_constants().BIT_VERSION}`);

    await this.scopeJson.write(this.getPath());

    _loader().default.stop();

    return {
      run: true,
      success: true
    };
  }

  describe() {
    return {
      name: this.name
    };
  }

  toConsumerComponents(components) {
    return Promise.all(components.filter(comp => !(comp instanceof _models().Symlink)) // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    .map(c => c.toConsumerComponent(c.latestExisting(this.objects).toString(), this.name, this.objects)));
  }

  async hasId(id, opts) {
    const filter = comp => {
      const symlinkCond = opts.includeSymlink ? true : !comp.isSymlink;
      const idMatch = comp.id.scope === id.scope && comp.id.name === id.name;
      return symlinkCond && idMatch;
    };

    const modelComponentList = await this.objects.listObjectsFromIndex(_componentsIndex().IndexType.components, filter);
    if (!modelComponentList || !modelComponentList.length) return false;
    if (!opts.includeVersion || !id.version) return true;
    if (id.getVersion().latest) return true;
    const modelComponent = modelComponentList[0];

    if (opts.includeOrphaned) {
      return modelComponent.hasTagIncludeOrphaned(id.version);
    }

    return modelComponent.hasTag(id.version);
  }

  async list() {
    const filter = comp => !comp.isSymlink; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return this.objects.listObjectsFromIndex(_componentsIndex().IndexType.components, filter);
  }

  async listIncludesSymlinks() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.objects.listObjectsFromIndex(_componentsIndex().IndexType.components);
  }

  async listIncludeRemoteHead(laneId) {
    const components = await this.list();
    const lane = laneId.isDefault() ? null : await this.loadLane(laneId);
    await Promise.all(components.map(component => component.populateLocalAndRemoteHeads(this.objects, lane)));
    return components;
  }

  async listLocal() {
    const listResults = await this.list();
    return listResults.filter(result => !result.scope || result.scope === this.name);
  }

  async listLanes() {
    return this.lanes.listLanes();
  }

  async loadLane(id) {
    const lane = await this.lanes.loadLane(id);
    const remoteTrackedData = this.lanes.getRemoteTrackedDataByLocalLane(id.name);

    if (lane && remoteTrackedData !== null && remoteTrackedData !== void 0 && remoteTrackedData.remoteLane && remoteTrackedData.remoteScope) {
      lane.remoteLaneId = _laneId().RemoteLaneId.from(remoteTrackedData === null || remoteTrackedData === void 0 ? void 0 : remoteTrackedData.remoteLane, remoteTrackedData.remoteScope);
    }

    return lane;
  }

  async latestVersions(componentIds, throwOnFailure = true) {
    componentIds = componentIds.map(componentId => componentId.changeVersion(undefined));
    const components = await this.sources.getMany(componentIds);
    const ids = components.map(component => {
      const getVersion = () => {
        if (component.component) {
          return component.component.latest();
        }

        if (throwOnFailure) throw new (_exceptions().ComponentNotFound)(component.id.toString());
        return _constants().DEFAULT_BIT_VERSION;
      };

      const version = getVersion();
      return component.id.changeVersion(version);
    });
    return _bitId().BitIds.fromArray(ids);
  }
  /**
   * Build multiple components sequentially, not in parallel.
   *
   * Two reasons why not running them in parallel:
   * 1) when several components have the same environment, it'll try to install them multiple times.
   * 2) npm throws errors when running 'npm install' from several directories
   *
   * Also, make sure to first build and write dists files of all components, and only then, write
   * the links inside the dists. otherwise, you it could fail when writing links of one component
   * needs another component dists files. (see 'importing all components and then deleting the dist
   * directory' test case)
   */


  async buildMultiple(components, consumer, noCache, verbose, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  dontPrintEnvMsg = false) {
    _logger().default.debugAndAddBreadCrumb('scope.buildMultiple', 'scope.buildMultiple: sequentially build multiple components'); // Make sure to not start the loader if there are no components to build


    if (components && components.length) {
      _loader().default.start(_loaderMessages().BEFORE_RUNNING_BUILD);

      if (components.length > 1) _loader().default.stopAndPersist({
        text: `${_loaderMessages().BEFORE_RUNNING_BUILD}...`
      });
    }

    _logger().default.debugAndAddBreadCrumb('scope.buildMultiple', 'using the legacy build mechanism');

    const build = async component => {
      if (component.compiler) _loader().default.start(`building component - ${component.id}`);
      await component.build({
        scope: this,
        consumer,
        noCache,
        verbose,
        dontPrintEnvMsg
      });
      const buildResults = await component.dists.writeDists(component, consumer, false);
      if (component.compiler) _loader().default.succeed();
      return {
        component: component.id.toString(),
        buildResults
      };
    };

    const writeLinks = async component => component.dists.writeDistsLinks(component, consumer);

    const buildResults = await (0, _pMapSeries().default)(components, build);
    await (0, _pMapSeries().default)(components, writeLinks);
    return buildResults;
  }
  /**
   * when custom-module-resolution is used, the test process needs to set the custom module
   * directory to the dist directory
   */


  injectNodePathIfNeeded(consumer, components) {
    const nodePathDirDist = _dists().default.getNodePathDir(consumer); // only author components need this injection. for imported the links are built on node_modules


    const isNodePathNeeded = nodePathDirDist && components.some(component => (component.dependencies.isCustomResolvedUsed() || component.devDependencies.isCustomResolvedUsed()) && component.componentMap && component.componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && !component.dists.isEmpty());

    if (isNodePathNeeded) {
      const getCurrentNodePathWithDirDist = () => {
        if (!process.env.NODE_PATH) return nodePathDirDist;
        const separator = process.env.NODE_PATH.endsWith(_constants().NODE_PATH_SEPARATOR) ? '' : _constants().NODE_PATH_SEPARATOR;
        return process.env.NODE_PATH + separator + nodePathDirDist;
      }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      process.env.NODE_PATH = getCurrentNodePathWithDirDist();

      require('module').Module._initPaths(); // eslint-disable-line

    }
  }
  /**
   * Test multiple components sequentially, not in parallel.
   *
   * See the reason not to run them in parallel at @buildMultiple()
   */


  async testMultiple({
    components,
    consumer,
    verbose,
    dontPrintEnvMsg = false,
    rejectOnFailure = false
  }) {
    _logger().default.debugAndAddBreadCrumb('scope.testMultiple', 'scope.testMultiple: sequentially test multiple components'); // Make sure not starting the loader when there is nothing to test


    if (components && components.length) {
      _loader().default.start(_loaderMessages().BEFORE_RUNNING_SPECS);
    }

    this.injectNodePathIfNeeded(consumer, components);

    const test = async component => {
      if (!component.tester) {
        return {
          componentId: component.id,
          missingTester: true,
          pass: true
        };
      }

      const specs = await component.runSpecs({
        scope: this,
        rejectOnFailure,
        consumer,
        verbose,
        dontPrintEnvMsg
      }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const pass = specs ? specs.every(spec => spec.pass) : true;
      const missingDistSpecs = specs && (0, _isEmpty2().default)(specs);
      return {
        componentId: component.id,
        missingDistSpecs,
        specs,
        pass
      };
    };

    return await (0, _pMapSeries().default)(components, test);
  }

  getObject(hash) {
    return new (_objects().Ref)(hash).load(this.objects);
  }

  getRawObject(hash) {
    return this.objects.loadRawObject(new (_objects().Ref)(hash));
  }

  getObjectItems(refs) {
    return Promise.all(refs.map(async ref => ({
      ref,
      buffer: await this.objects.loadRaw(ref)
    })));
  }

  async getObjectItem(ref) {
    return {
      ref,
      buffer: await this.objects.loadRaw(ref)
    };
  }

  async getModelComponentIfExist(id) {
    const modelComponent = await this.sources.get(id);

    if (modelComponent) {
      // @todo: what about other places the model-component is loaded
      const currentLane = await this.getCurrentLaneObject();
      await modelComponent.populateLocalAndRemoteHeads(this.objects, currentLane);
    }

    return modelComponent;
  }

  async getCurrentLaneObject() {
    return this.loadLane(this.lanes.getCurrentLaneId());
  }
  /**
   * Remove components from scope
   * @force Boolean - remove component from scope even if other components use it
   */


  async removeMany(bitIds, force, consumer) {
    _logger().default.debug(`scope.removeMany ${bitIds.toString()} with force flag: ${force.toString()}`);

    _analytics().Analytics.addBreadCrumb('removeMany', `scope.removeMany ${_analytics().Analytics.hashData(bitIds)} with force flag: ${force.toString()}`);

    const removeComponents = new (_removeModelComponents().default)(this, bitIds, force, consumer);
    return removeComponents.remove();
  }
  /**
   * for each one of the given components, find its dependents
   */


  async getDependentsBitIds(bitIds, returnResultsWithVersion = false) {
    const idsGraph = await _scopeGraph().default.buildIdsGraphWithAllVersions(this);
    const dependencyGraph = new (_scopeGraph().default)(idsGraph);
    const dependentsGraph = bitIds.reduce((acc, current) => {
      const dependents = dependencyGraph.getDependentsForAllVersions(current);

      if (dependents.length) {
        const dependentsIds = dependents.map(id => returnResultsWithVersion ? id : id.changeVersion(undefined));
        acc[current.toStringWithoutVersion()] = _bitId().BitIds.uniqFromArray(dependentsIds);
      }

      return acc;
    }, {});
    return dependentsGraph;
  }
  /**
   * split bit array to found and missing components (incase user misspelled id)
   */


  async filterFoundAndMissingComponents(bitIds) {
    const missingComponents = new (_bitId().BitIds)();
    const foundComponents = new (_bitId().BitIds)();
    const resultP = bitIds.map(async id => {
      const component = await this.getModelComponentIfExist(id);
      if (!component) missingComponents.push(id);else foundComponents.push(id);
    });
    await Promise.all(resultP);
    return {
      missingComponents,
      foundComponents
    };
  }
  /**
   * load components from the model and return them as ComponentVersion array.
   * if a component is not available locally, it'll just ignore it without throwing any error.
   */


  async loadLocalComponents(ids) {
    const componentsObjects = await this.sources.getMany(ids);
    const components = componentsObjects.map(componentObject => {
      const component = componentObject.component;
      if (!component) return null;
      const version = componentObject.id.hasVersion() ? componentObject.id.version : component.latest(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return component.toComponentVersion(version);
    });
    return removeNils(components);
  }

  async loadComponentLogs(id, shortHash = false, startFrom) {
    var _componentModel$getRe;

    const componentModel = await this.getModelComponentIfExist(id);
    if (!componentModel) return [];
    const startFromRef = startFrom ? (_componentModel$getRe = componentModel.getRef(startFrom)) !== null && _componentModel$getRe !== void 0 ? _componentModel$getRe : undefined : undefined;
    const logs = await componentModel.collectLogs(this.objects, shortHash, startFromRef);
    return logs;
  }

  loadAllVersions(id) {
    return this.getModelComponentIfExist(id).then(componentModel => {
      if (!componentModel) throw new (_exceptions().ComponentNotFound)(id.toString());
      return componentModel.collectVersions(this.objects);
    });
  }
  /**
   * get ModelComponent instance per bit-id.
   * it throws an error if the component wasn't found.
   * @see getModelComponentIfExist to not throw an error
   * @see getModelComponentIgnoreScope to ignore the scope name
   */


  async getModelComponent(id) {
    const component = await this.getModelComponentIfExist(id);

    if (component) {
      return component;
    }

    throw new (_exceptions().ComponentNotFound)(id.toString());
  }
  /**
   * the id can be either with or without a scope-name.
   * in case the component is saved in the model only with the scope (imported), it loads all
   * components and search for it.
   * it throws an error if the component wasn't found.
   */


  async getModelComponentIgnoreScope(id) {
    const component = await this.getModelComponentIfExist(id);
    if (component) return component;

    if (!id.scope) {
      // search for the complete ID
      const components = await this.list();
      const foundComponent = components.filter(c => c.toBitId().isEqualWithoutScopeAndVersion(id));
      if (foundComponent.length) return (0, _utils().first)(foundComponent);
    }

    throw new (_exceptions().ComponentNotFound)(id.toString());
  }
  /**
   * throws if component was not found
   */


  async getConsumerComponent(id) {
    const modelComponent = await this.getModelComponent(id); // $FlowFixMe version must be set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const componentVersion = modelComponent.toComponentVersion(id.version); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return componentVersion.toConsumer(this.objects);
  }

  async getManyConsumerComponents(ids) {
    return Promise.all(ids.map(id => this.getConsumerComponent(id)));
  }
  /**
   * return undefined if component was not found
   */


  async getConsumerComponentIfExist(id) {
    const modelComponent = await this.getModelComponentIfExist(id);
    if (!modelComponent) return undefined; // $FlowFixMe version must be set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const componentVersion = modelComponent.toComponentVersion(id.version); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return componentVersion.toConsumer(this.objects);
  }

  async getVersionInstance(id) {
    if (!id.hasVersion()) throw new TypeError(`scope.getVersionInstance - id ${id.toString()} is missing the version`);
    const component = await this.getModelComponent(id);
    return component.loadVersion(id.version, this.objects);
  }

  async getComponentsAndVersions(ids, defaultToLatestVersion = false) {
    const componentsObjects = await this.sources.getMany(ids);
    const componentsAndVersionsP = componentsObjects.map(async componentObjects => {
      if (!componentObjects.component) return null;
      const component = componentObjects.component;

      const getVersionStr = () => {
        var _componentObjects$com;

        if (componentObjects.id.hasVersion()) return componentObjects.id.getVersion().toString();
        if (!defaultToLatestVersion) throw new Error(`getComponentsAndVersions expect ${componentObjects.id.toString()} to have a version`);
        return (_componentObjects$com = componentObjects.component) === null || _componentObjects$com === void 0 ? void 0 : _componentObjects$com.latest();
      };

      const versionStr = getVersionStr();
      const version = await component.loadVersion(versionStr, this.objects);
      return {
        component,
        version,
        versionStr
      };
    });
    const componentsAndVersions = await Promise.all(componentsAndVersionsP);
    return removeNils(componentsAndVersions);
  }

  async isComponentInScope(id) {
    const comp = await this.sources.get(id);
    return Boolean(comp);
  }

  async getComponentsAndAllLocalUnexportedVersions(ids) {
    const componentsObjects = await this.sources.getMany(ids);
    const componentsAndVersionsP = componentsObjects.map(async componentObjects => {
      if (!componentObjects.component) return null;
      const component = componentObjects.component;
      const localVersions = component.getLocalVersions();
      return Promise.all(localVersions.map(async versionStr => {
        const version = await component.loadVersion(versionStr, this.objects);
        return {
          component,
          version,
          versionStr
        };
      }));
    });
    const componentsAndVersions = await Promise.all(componentsAndVersionsP);
    return removeNils((0, _flatten2().default)(componentsAndVersions));
  }
  /**
   * Creates a symlink object with the local-scope which links to the real-object of the remote-scope
   * This way, local components that have dependencies to the exported component won't break.
   */


  createSymlink(id, remote) {
    const symlink = new (_models().Symlink)({
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      scope: id.scope,
      name: id.name,
      realScope: remote
    });
    return this.objects.add(symlink);
  }

  ensureDir() {
    _fsExtra().default.ensureDirSync(this.getComponentsPath());

    return this.tmp.ensureDir().then(() => this.scopeJson.write(this.getPath())).then(() => this.objects.ensureDir()).then(() => this);
  }
  /**
   * find the components in componentsPool which one of their dependencies include in potentialDependencies
   */


  async findDirectDependentComponents(componentsPool, potentialDependencies) {
    const componentsVersions = await this.loadLocalComponents(componentsPool);
    const dependentsP = componentsVersions.map(async componentVersion => {
      const component = await componentVersion.getVersion(this.objects);
      const found = component.getAllDependencies().find(dependency => potentialDependencies.searchWithoutVersion(dependency.id));
      return found ? componentVersion : null;
    });
    const dependents = await Promise.all(dependentsP);
    const dependentsWithoutNull = removeNils(dependents);
    return _bitId().BitIds.fromArray(dependentsWithoutNull.map(c => c.id));
  }

  async runComponentSpecs({
    bitId,
    consumer,
    save,
    verbose,
    isolated,
    directory,
    keep
  }) {
    if (!bitId.isLocal(this.name)) {
      throw new (_generalError().default)('cannot run specs on remote component');
    }

    const component = await this.getConsumerComponent(bitId);
    return component.runSpecs({
      scope: this,
      consumer,
      save,
      verbose,
      isolated,
      directory,
      keep
    });
  }

  async build({
    bitId,
    save,
    consumer,
    verbose,
    directory,
    keep,
    noCache
  }) {
    if (!bitId.isLocal(this.name)) {
      throw new (_generalError().default)('cannot run build on remote component');
    }

    const component = await this.getConsumerComponent(bitId);
    return component.build({
      scope: this,
      save,
      consumer,
      verbose,
      directory,
      keep,
      noCache
    });
  }

  async loadModelComponentByIdStr(id) {
    // Remove the version before hashing since hashing with the version number will result a wrong hash
    const idWithoutVersion = _bitId().BitId.getStringWithoutVersion(id);

    const ref = _objects().Ref.from(_objects().BitObject.makeHash(idWithoutVersion)); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return this.objects.load(ref);
  }

  async getParsedId(id) {
    if (id.startsWith('@')) {
      throw new (_unexpectedPackageName().UnexpectedPackageName)(id);
    }

    const component = await this.loadModelComponentByIdStr(id);
    const idHasScope = Boolean(component && component.scope);

    if (!idHasScope) {
      const [idWithoutVersion] = id.toString().split('@');

      if (idWithoutVersion.includes('.')) {
        // we allow . only on scope names, so if it has . it must be with scope name
        return _bitId().BitId.parse(id, true);
      } // if it's not in the scope, it's probably new, we assume it doesn't have scope.


      return _bitId().BitId.parse(id, false);
    }

    const bitId = component.toBitId();

    const version = _bitId().BitId.getVersionOnlyFromString(id);

    return bitId.changeVersion(version || _constants().LATEST);
  }

  async writeObjectsToPendingDir(objectList, clientId) {
    const pendingDir = pathLib().join(this.path, _constants().PENDING_OBJECTS_DIR, clientId);

    if (_fsExtra().default.pathExistsSync(pendingDir)) {
      throw new (_clientIdInUse().default)(clientId);
    }

    await this.objects.writeObjectsToPendingDir(objectList, pendingDir);
  }

  async readObjectsFromPendingDir(clientId) {
    // @todo: implement the wait() mechanism.
    const pendingDir = pathLib().join(this.path, _constants().PENDING_OBJECTS_DIR, clientId);
    return this.objects.readObjectsFromPendingDir(pendingDir);
  }

  async removePendingDir(clientId) {
    const pendingDir = pathLib().join(this.path, _constants().PENDING_OBJECTS_DIR, clientId);
    return _fsExtra().default.remove(pendingDir); // no error is thrown if not exists
  }

  static ensure(path, name, groupName) {
    if (pathHasScope(path)) return this.load(path);
    const scopeJson = Scope.ensureScopeJson(path, name, groupName);

    const repository = _objects().Repository.create({
      scopePath: path,
      scopeJson
    });

    return Promise.resolve(new Scope({
      path,
      created: true,
      scopeJson,
      objects: repository
    }));
  }

  static ensureScopeJson(path, name, groupName) {
    if (!name) name = (0, _utils().currentDirName)();

    if (name === _constants().CURRENT_UPSTREAM) {
      throw new (_generalError().default)(`the name "${_constants().CURRENT_UPSTREAM}" is a reserved word, please use another name`);
    }

    const scopeJson = new (_scopeJson().ScopeJson)({
      name,
      groupName,
      version: _constants().BIT_VERSION
    });
    return scopeJson;
  }

  static async reset(path, resetHard) {
    await _objects().Repository.reset(path);

    if (resetHard) {
      _logger().default.info(`deleting the whole scope at ${path}`);

      await _fsExtra().default.emptyDir(path);
    }

    Scope.scopeCache = {};
  }

  static async load(absPath, useCache = true) {
    let scopePath = (0, _utils().propogateUntil)(absPath);
    let isBare = true;
    if (!scopePath) throw new (_exceptions().ScopeNotFound)(absPath);

    if (_fsExtra().default.existsSync(pathLib().join(scopePath, _constants().BIT_HIDDEN_DIR))) {
      scopePath = pathLib().join(scopePath, _constants().BIT_HIDDEN_DIR);
      isBare = false;
    }

    if (scopePath.endsWith(pathLib().join(_constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR)) || scopePath.endsWith(pathLib().join(_constants().BIT_HIDDEN_DIR))) {
      isBare = false;
    }

    if (useCache && Scope.scopeCache[scopePath]) {
      _logger().default.debug(`scope.load, found scope at ${scopePath} from cache`);

      return Scope.scopeCache[scopePath];
    }

    const scopeJsonPath = (0, _scopeJson().getPath)(scopePath);

    const scopeJsonExist = _fsExtra().default.existsSync(scopeJsonPath);

    let scopeJson;

    if (scopeJsonExist) {
      scopeJson = await _scopeJson().ScopeJson.loadFromFile(scopeJsonPath);
    } else {
      scopeJson = Scope.ensureScopeJson(scopePath);
    }

    const objects = await _objects().Repository.load({
      scopePath,
      scopeJson
    });
    const scope = new Scope({
      path: scopePath,
      scopeJson,
      objects,
      isBare
    });
    Scope.scopeCache[scopePath] = scope;
    return scope;
  }

}

exports.default = Scope;
(0, _defineProperty2().default)(Scope, "onPostExport", void 0);
(0, _defineProperty2().default)(Scope, "scopeCache", {});