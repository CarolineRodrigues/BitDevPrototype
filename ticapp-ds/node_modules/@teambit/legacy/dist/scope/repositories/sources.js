"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));

  _path2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _pMap() {
  const data = _interopRequireDefault(require("p-map"));

  _pMap = function () {
    return data;
  };

  return data;
}

function _componentVersion() {
  const data = require("@teambit/component-version");

  _componentVersion = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _manipulateDir() {
  const data = require("../../consumer/component-ops/manipulate-dir");

  _manipulateDir = function () {
    return data;
  };

  return data;
}

function _artifactFiles() {
  const data = require("../../consumer/component/sources/artifact-files");

  _artifactFiles = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");

  _traverseVersions = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _componentNeedsUpdate() {
  const data = _interopRequireDefault(require("../exceptions/component-needs-update"));

  _componentNeedsUpdate = function () {
    return data;
  };

  return data;
}

function _unmergedComponents() {
  const data = _interopRequireDefault(require("../lanes/unmerged-components"));

  _unmergedComponents = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../models");

  _models = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _exportMissingVersions() {
  const data = require("../exceptions/export-missing-versions");

  _exportMissingVersions = function () {
    return data;
  };

  return data;
}

function _modelComponentsMerger() {
  const data = require("../component-ops/model-components-merger");

  _modelComponentsMerger = function () {
    return data;
  };

  return data;
}

function _concurrency() {
  const data = require("../../utils/concurrency");

  _concurrency = function () {
    return data;
  };

  return data;
}

function _cacheFactory() {
  const data = require("../../cache/cache-factory");

  _cacheFactory = function () {
    return data;
  };

  return data;
}

const MAX_AGE_UN_BUILT_COMPS_CACHE = 60 * 1000;

class SourceRepository {
  /**
   * if a component Version has build-status of "pending" or "failed", it goes to the remote to ask
   * for the component again, in case it was re-built.
   * to avoid too many trips to the remotes with the same components, we cache the results for a
   * small period of time (currently, 1 min).
   */
  constructor(scope) {
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "cacheUnBuiltIds", void 0);
    this.scope = scope;
    this.cacheUnBuiltIds = (0, _cacheFactory().createInMemoryCache)({
      maxAge: MAX_AGE_UN_BUILT_COMPS_CACHE
    });
  }

  objects() {
    return this.scope.objects;
  }

  async getMany(ids, versionShouldBeBuilt = false) {
    if (!ids.length) return [];
    const concurrency = (0, _concurrency().concurrentComponentsLimit)();

    _logger().default.debug(`sources.getMany, Ids: ${ids.join(', ')}`);

    return (0, _pMap().default)(ids, async id => {
      const component = await this.get(id, versionShouldBeBuilt);
      return {
        id,
        component
      };
    }, {
      concurrency
    });
  }
  /**
   * get component (local or external) from the scope.
   * if the id has a version but the Version object doesn't exist, it returns undefined.
   *
   * if versionShouldBeBuilt is true, it also verified that not only the version exists but it also
   * built successfully. otherwise, if the build failed or pending, the server may have a newer
   * version of this Version object, so we return undefined, to signal the importer that it needs
   * to be fetched from the remote again.
   */


  async get(bitId, versionShouldBeBuilt = false) {
    const emptyComponent = _models().ModelComponent.fromBitId(bitId);

    const component = await this._findComponent(emptyComponent);
    if (!component) return undefined;
    if (!bitId.hasVersion()) return component;

    const returnComponent = version => {
      if (versionShouldBeBuilt && !bitId.isLocal(this.scope.name) && !component.hasLocalVersion(bitId.version) && ( // e.g. during tag
      version.buildStatus === _constants().BuildStatus.Pending || version.buildStatus === _constants().BuildStatus.Failed)) {
        const bitIdStr = bitId.toString();
        const fromCache = this.cacheUnBuiltIds.get(bitIdStr);

        if (fromCache) {
          return fromCache;
        }

        this.cacheUnBuiltIds.set(bitIdStr, component);
        return undefined;
      }

      return component;
    }; // @ts-ignore


    const isSnap = (0, _componentVersion().isHash)(bitId.version);
    const msg = `found ${bitId.toStringWithoutVersion()}, however version ${bitId.getVersion().versionNum}`; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (isSnap) {
      // @ts-ignore
      const snap = await this.objects().load(new (_objects().Ref)(bitId.version));

      if (!snap) {
        _logger().default.debugAndAddBreadCrumb('sources.get', `${msg} object was not found on the filesystem`);

        return undefined;
      }

      return returnComponent(snap);
    } // @ts-ignore


    if (!component.hasTagIncludeOrphaned(bitId.version)) {
      _logger().default.debugAndAddBreadCrumb('sources.get', `${msg} is not in the component versions array`);

      return undefined;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    const versionHash = component.versionsIncludeOrphaned[bitId.version];
    const version = await this.objects().load(versionHash);

    if (!version) {
      _logger().default.debugAndAddBreadCrumb('sources.get', `${msg} object was not found on the filesystem`);

      return undefined;
    } // workaround an issue when a component has a dependency with the same id as the component itself


    version.dependencies = version.dependencies.filter(d => !d.id.isEqualWithoutVersion(component.toBitId()));
    return returnComponent(version);
  }

  async _findComponent(component) {
    try {
      const foundComponent = await this.objects().load(component.hash());

      if (foundComponent instanceof _models().Symlink) {
        // eslint-disable-next-line @typescript-eslint/return-await
        return this._findComponentBySymlink(foundComponent);
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      if (foundComponent) return foundComponent;
    } catch (err) {
      _logger().default.error(`findComponent got an error ${err}`);
    }

    _logger().default.debug(`failed finding a component ${component.id()} with hash: ${component.hash().toString()}`);

    return undefined;
  }

  async _findComponentBySymlink(symlink) {
    const realComponentId = symlink.getRealComponentId();

    const realModelComponent = _models().ModelComponent.fromBitId(realComponentId);

    const foundComponent = await this.objects().load(realModelComponent.hash());

    if (!foundComponent) {
      throw new Error(`error: found a symlink object "${symlink.id()}" that references to a non-exist component "${realComponentId.toString()}".
if you have the steps to reproduce the issue, please open a Github issue with the details.
to quickly fix the issue, please delete the object at "${this.objects().objectPath(symlink.hash())}"`);
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return foundComponent;
  }

  getObjects(id) {
    return this.get(id).then(component => {
      if (!component) throw new (_exceptions().ComponentNotFound)(id.toString());
      return component.collectObjects(this.objects());
    });
  }

  findOrAddComponent(props) {
    const comp = _models().ModelComponent.from(props);

    return this._findComponent(comp).then(component => {
      if (!component) return comp;
      return component;
    });
  }

  modifyCIProps({
    source,
    ciProps
  }) {
    const objectRepo = this.objects(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return this.findOrAddComponent(source).then(component => {
      return component.loadVersion(component.latest(), objectRepo).then(version => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        version.setCIProps(ciProps);
        return objectRepo._writeOne(version);
      });
    });
  }

  modifySpecsResults({
    source,
    specsResults
  }) {
    const objectRepo = this.objects(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return this.findOrAddComponent(source).then(component => {
      return component.loadVersion(component.latest(), objectRepo).then(version => {
        version.setSpecsResults(specsResults);
        return objectRepo._writeOne(version);
      });
    });
  } // TODO: This should treat dist as an array


  updateDist({
    source
  }) {
    const objectRepo = this.objects(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return this.findOrAddComponent(source).then(component => {
      return component.loadVersion(component.latest(), objectRepo).then(version => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const dist = source.dist ? _models().Source.from(Buffer.from(source.dist.toString())) : undefined;
        version.setDist(dist);
        objectRepo.add(dist).add(version);
        return objectRepo.persist();
      });
    });
  }

  transformArtifactsFromVinylToSource(artifactsFiles) {
    const artifacts = [];
    artifactsFiles.forEach(artifactFiles => {
      const artifactsSource = _artifactFiles().ArtifactFiles.fromVinylsToSources(artifactFiles.vinyls);

      if (artifactsSource.length) artifactFiles.populateRefsFromSources(artifactsSource);
      artifacts.push(...artifactsSource);
    });
    return artifacts;
  }
  /**
   * given a consumer-component object, returns the Version representation.
   * useful for saving into the model or calculation the hash for comparing with other Version object.
   * among other things, it reverts the path manipulation that was done when a component was loaded
   * from the filesystem. it adds the originallySharedDir and strip the wrapDir.
   *
   * warning: Do not change anything on the consumerComponent instance! Only use its clone.
   *
   * @see model-components.toConsumerComponent() for the opposite action. (converting Version to
   * ConsumerComponent).
   */


  async consumerComponentToVersion({
    consumerComponent,
    consumer
  }) {
    const clonedComponent = consumerComponent.clone();

    const setEol = files => {
      if (!files) return null;
      const result = files.map(file => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        file.file = file.toSourceAsLinuxEOL();
        return file;
      });
      return result;
    };

    const manipulateDirs = pathStr => {
      return (0, _manipulateDir().revertDirManipulationForPath)(pathStr, clonedComponent.originallySharedDir, clonedComponent.wrapDir);
    };

    const files = consumerComponent.files.map(file => {
      return {
        name: file.basename,
        relativePath: manipulateDirs(file.relative),
        file: file.toSourceAsLinuxEOL(),
        test: file.test
      };
    }); // @todo: is this the best way to find out whether a compiler is set?

    const isCompileSet = Boolean(consumerComponent.compiler || clonedComponent.extensions.some(e => e.name === _constants().Extensions.compiler || e.name === 'bit.core/compile' || e.name === _constants().Extensions.envs));
    const {
      dists,
      mainDistFile
    } = clonedComponent.dists.toDistFilesModel(consumer, consumerComponent.originallySharedDir, isCompileSet);
    const compilerFiles = setEol((0, _path2().default)(['compiler', 'files'], consumerComponent));
    const testerFiles = setEol((0, _path2().default)(['tester', 'files'], consumerComponent));
    clonedComponent.mainFile = manipulateDirs(clonedComponent.mainFile);
    clonedComponent.getAllDependencies().forEach(dependency => {
      // ignoreVersion because when persisting the tag is higher than currently exist in .bitmap
      const depFromBitMap = consumer.bitMap.getComponentIfExist(dependency.id, {
        ignoreVersion: true
      });
      dependency.relativePaths.forEach(relativePath => {
        if (!relativePath.isCustomResolveUsed) {
          // for isCustomResolveUsed it was never stripped
          relativePath.sourceRelativePath = manipulateDirs(relativePath.sourceRelativePath);
        }

        if (depFromBitMap && depFromBitMap.origin !== _constants().COMPONENT_ORIGINS.AUTHORED) {
          // when a dependency is not authored, we need to also change the
          // destinationRelativePath, which is the path written in the link file, however, the
          // dir manipulation should be according to this dependency component, not the
          // consumerComponent passed to this function
          relativePath.destinationRelativePath = (0, _manipulateDir().revertDirManipulationForPath)(relativePath.destinationRelativePath, depFromBitMap.originallySharedDir, depFromBitMap.wrapDir);
        }
      });
    });
    clonedComponent.overrides.addOriginallySharedDir(clonedComponent.originallySharedDir);

    const version = _models().Version.fromComponent({
      component: clonedComponent,
      files: files,
      dists,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      mainDistFile
    }); // $FlowFixMe it's ok to override the pendingVersion attribute


    consumerComponent.pendingVersion = version; // helps to validate the version against the consumer-component

    return {
      version,
      files,
      dists,
      compilerFiles,
      testerFiles
    };
  }

  async consumerComponentToVersionHarmony(consumerComponent) {
    const clonedComponent = consumerComponent.clone();
    const files = consumerComponent.files.map(file => {
      return {
        name: file.basename,
        relativePath: file.relative,
        file: file.toSourceAsLinuxEOL(),
        test: file.test
      };
    });

    const version = _models().Version.fromComponent({
      component: clonedComponent,
      files: files
    }); // $FlowFixMe it's ok to override the pendingVersion attribute


    consumerComponent.pendingVersion = version; // helps to validate the version against the consumer-component

    return {
      version,
      files
    };
  }

  async enrichSource(consumerComponent) {
    const objectRepo = this.objects();
    const objects = await this.getObjectsToEnrichSource(consumerComponent);
    objects.forEach(obj => objectRepo.add(obj));
    return consumerComponent;
  }

  async getObjectsToEnrichSource(consumerComponent) {
    const component = await this.findOrAddComponent(consumerComponent);
    const version = await component.loadVersion(consumerComponent.id.version, this.objects());
    const artifactFiles = (0, _artifactFiles().getArtifactsFiles)(consumerComponent.extensions);
    const artifacts = this.transformArtifactsFromVinylToSource(artifactFiles);
    version.extensions = consumerComponent.extensions;
    version.buildStatus = consumerComponent.buildStatus;
    const artifactObjects = artifacts.map(file => file.source);
    return [version, ...artifactObjects];
  }

  async addSource({
    source,
    consumer,
    lane,
    resolveUnmerged = false
  }) {
    const objectRepo = this.objects(); // if a component exists in the model, add a new version. Otherwise, create a new component on the model
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const component = await this.findOrAddComponent(source);
    const unmergedComponent = consumer.scope.objects.unmergedComponents.getEntry(component.name);

    if (unmergedComponent && !unmergedComponent.resolved && !resolveUnmerged) {
      throw new (_generalError().default)(`unable to snap/tag "${component.name}", it is unmerged with conflicts. please run "bit merge <id> --resolve"`);
    }

    const artifactFiles = (0, _artifactFiles().getArtifactsFiles)(source.extensions);
    const artifacts = this.transformArtifactsFromVinylToSource(artifactFiles); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const {
      version,
      files,
      dists,
      compilerFiles,
      testerFiles
    } = await this.consumerComponentToVersion({
      consumerComponent: source,
      consumer
    });
    objectRepo.add(version);
    if (!source.version) throw new Error(`addSource expects source.version to be set`);
    component.addVersion(version, source.version, lane, objectRepo);

    if (unmergedComponent) {
      version.addParent(unmergedComponent.head);

      _logger().default.debug(`sources.addSource, unmerged component "${component.name}". adding a parent ${unmergedComponent.head.hash}`);

      version.log.message = version.log.message ? version.log.message : _unmergedComponents().default.buildSnapMessage(unmergedComponent);
      consumer.scope.objects.unmergedComponents.removeComponent(component.name);
    }

    objectRepo.add(component);
    files.forEach(file => objectRepo.add(file.file));
    if (dists) dists.forEach(dist => objectRepo.add(dist.file));
    if (compilerFiles) compilerFiles.forEach(file => objectRepo.add(file.file));
    if (testerFiles) testerFiles.forEach(file => objectRepo.add(file.file));
    if (artifacts) artifacts.forEach(file => objectRepo.add(file.source));
    return component;
  }

  async addSourceFromScope(source) {
    const objectRepo = this.objects(); // if a component exists in the model, add a new version. Otherwise, create a new component on the model

    const component = await this.findOrAddComponent(source);
    const artifactFiles = (0, _artifactFiles().getArtifactsFiles)(source.extensions);
    const artifacts = this.transformArtifactsFromVinylToSource(artifactFiles);
    const {
      version,
      files
    } = await this.consumerComponentToVersionHarmony(source);
    objectRepo.add(version);
    if (!source.version) throw new Error(`addSource expects source.version to be set`);
    component.addVersion(version, source.version, null, objectRepo);
    objectRepo.add(component);
    files.forEach(file => objectRepo.add(file.file));
    if (artifacts) artifacts.forEach(file => objectRepo.add(file.source));
    return component;
  }

  put({
    component,
    objects
  }) {
    _logger().default.debug(`sources.put, id: ${component.id()}, versions: ${component.listVersions().join(', ')}`);

    const repo = this.objects();
    repo.add(component);
    objects.forEach(obj => {
      repo.add(obj);
    });
    return component;
  }

  putObjects(objects) {
    const repo = this.objects();
    objects.forEach(obj => repo.add(obj));
  }
  /**
   * remove specified component versions from component.
   * if all versions of a component were deleted, delete also the component.
   * it doesn't persist anything to the filesystem.
   * (repository.persist() needs to be called at the end of the operation)
   */


  removeComponentVersions(component, versions, allVersionsObjects, lane) {
    _logger().default.debug(`removeComponentVersion, component ${component.id()}, versions ${versions.join(', ')}`);

    const objectRepo = this.objects();
    const componentHadHead = component.hasHead();
    const laneItem = lane === null || lane === void 0 ? void 0 : lane.getComponentByName(component.toBitId());
    const removedRefs = versions.map(version => {
      const ref = component.removeVersion(version);
      const versionObject = allVersionsObjects.find(v => v.hash().isEqual(ref));
      const refStr = ref.toString();
      if (!versionObject) throw new Error(`removeComponentVersions failed finding a version object of ${refStr}`);
      objectRepo.removeObject(ref);
      return ref;
    });

    const getNewHead = () => {
      const divergeData = component.getDivergeData();

      if (divergeData.isDiverged()) {
        if (!component.remoteHead) throw new Error(`remoteHead must be set when component is diverged`);
        return component.remoteHead;
      }

      const head = component.head || (laneItem === null || laneItem === void 0 ? void 0 : laneItem.head);

      if (!head) {
        return undefined;
      }

      const headVersion = allVersionsObjects.find(ver => ver.hash().isEqual(head));
      return this.findHeadInExistingVersions(allVersionsObjects, component.id(), headVersion);
    };

    const refWasDeleted = ref => removedRefs.find(removedRef => ref.isEqual(removedRef));

    if (component.head && refWasDeleted(component.head)) {
      const newHead = getNewHead();
      component.setHead(newHead);
    }

    if (laneItem && refWasDeleted(laneItem.head)) {
      const newHead = getNewHead();

      if (newHead) {
        laneItem.head = newHead;
      } else {
        lane === null || lane === void 0 ? void 0 : lane.removeComponent(component.toBitId());
      }

      component.laneHeadLocal = newHead;
      objectRepo.add(lane);
    }

    allVersionsObjects.forEach(versionObj => {
      const wasDeleted = refWasDeleted(versionObj.hash());

      if (!wasDeleted && versionObj.parents.some(parent => refWasDeleted(parent))) {
        throw new Error(`fatal: version "${versionObj.hash().toString()}" of "${component.id()}" has parents that got deleted, which makes the history invalid.`);
      }
    });

    if (componentHadHead && !component.hasHead() && component.versionArray.length) {
      throw new Error(`fatal: "head" prop was removed from "${component.id()}", although it has versions`);
    }

    if (component.versionArray.length || component.hasHead() || component.laneHeadLocal) {
      objectRepo.add(component); // add the modified component object
    } else {
      objectRepo.removeObject(component.hash());
    }

    objectRepo.unmergedComponents.removeComponent(component.name);
  }
  /**
   * needed during untag.
   * given all removed versions, find the new head by traversing the versions objects until finding a parent
   * that was not removed. this is the new head of the component.
   */


  findHeadInExistingVersions(versions, componentId, current) {
    if (!current) {
      return undefined;
    }

    const parents = current.parents;

    if (!parents.length) {
      return undefined;
    }

    if (parents.length > 1) {
      // @todo: it needs to be optimized. we can check if both parents were removed, then traverse each one of them
      // and find the new head.
      throw new Error(`removeComponentVersions found multiple parents for a local (un-exported) version ${current.hash()} of ${componentId}`);
    }

    const parentRef = parents[0];
    const parentExists = versions.find(ver => ver.hash().isEqual(parentRef));

    if (!parentExists) {
      return parentRef;
    }

    return this.findHeadInExistingVersions(versions, componentId, parentExists);
  }
  /**
   * get hashes needed for removing a component from a local scope.
   */


  async getRefsForComponentRemoval(bitId, includeVersions = true) {
    _logger().default.debug(`sources.removeComponentById: ${bitId.toString()}, includeVersions: ${includeVersions}`);

    const component = await this.get(bitId);
    if (!component) return [];
    const objectRefs = [component.hash()];
    if (includeVersions) objectRefs.push(...component.versionArray);
    return objectRefs;
  }
  /**
   * this gets called only during export. for import, the merge is different, see
   * objects-writable-stream.mergeModelComponent()
   *
   * it doesn't save anything to the file-system.
   * only if the returned mergedVersions is not empty, the mergedComponent has changed.
   *
   * when dealing with lanes, exporting/importing lane's components, this function doesn't do much
   * if any. that's because the head is not saved on the ModelComponent but on the lane object.
   * to rephrase with other words,
   * this function merges an incoming modelComponent with an existing modelComponent, so if all
   * changes where done on a lane, this function will not do anything because modelComponent
   * hasn't changed.
   */


  async merge(incomingComp, versionObjects) {
    var _existingComp$getHead;

    const existingComp = await this._findComponent(incomingComp);

    if (existingComp && incomingComp.isEqual(existingComp)) {
      return {
        mergedComponent: incomingComp,
        mergedVersions: []
      };
    } // don't throw if not found because on export not all objects are sent to the remote


    const allVersionsInfo = await (0, _traverseVersions().getAllVersionsInfo)({
      modelComponent: incomingComp,
      throws: false,
      versionObjects
    });
    const allHashes = allVersionsInfo.map(v => v.ref).filter(ref => ref);
    const incomingTagsAndSnaps = incomingComp.switchHashesWithTagsIfExist(allHashes);

    if (!existingComp) {
      this.throwForMissingVersions(allVersionsInfo, incomingComp);
      return {
        mergedComponent: incomingComp,
        mergedVersions: incomingTagsAndSnaps
      };
    }

    const hashesOfHistoryGraph = allVersionsInfo.map(v => v.isPartOfHistory ? v.ref : null).filter(ref => ref);
    const existingComponentHead = (_existingComp$getHead = existingComp.getHead()) === null || _existingComp$getHead === void 0 ? void 0 : _existingComp$getHead.clone();
    const existingHeadIsMissingInIncomingComponent = Boolean(incomingComp.hasHead() && existingComponentHead && !hashesOfHistoryGraph.find(ref => ref.isEqual(existingComponentHead))); // currently it'll always be true. later, we might want to support exporting
    // dependencies from other scopes and then isIncomingFromOrigin could be false

    const isIncomingFromOrigin = incomingComp.scope === this.scope.name;
    const modelComponentMerger = new (_modelComponentsMerger().ModelComponentMerger)(existingComp, incomingComp, false, isIncomingFromOrigin, existingHeadIsMissingInIncomingComponent);
    const {
      mergedComponent,
      mergedVersions
    } = await modelComponentMerger.merge();

    if (existingComponentHead) {
      const mergedSnaps = await this.getMergedSnaps(existingComponentHead, incomingComp, versionObjects);
      mergedVersions.push(...mergedSnaps);
    }

    return {
      mergedComponent,
      mergedVersions
    };
  }

  async getMergedSnaps(existingHead, incomingComp, versionObjects) {
    const allIncomingVersionsInfoUntilExistingHead = await (0, _traverseVersions().getAllVersionsInfo)({
      modelComponent: incomingComp,
      throws: false,
      versionObjects,
      stopAt: existingHead
    });
    const hashesOnly = allIncomingVersionsInfoUntilExistingHead.filter(v => !v.tag) // only non-tag, the tagged are already part of the mergedVersion
    .map(v => v.ref).filter(ref => ref);
    return hashesOnly.map(hash => hash.toString());
  }

  throwForMissingVersions(allVersionsInfo, component) {
    const missingVersions = allVersionsInfo.filter(c => !c.version).map(c => c.tag || c.ref.toString());

    if (missingVersions.length) {
      throw new (_exportMissingVersions().ExportMissingVersions)(component.id(), missingVersions);
    }
  }

  async mergeComponents(components, versions) {
    const mergeResults = [];
    const errors = [];
    await Promise.all(components.map(async component => {
      try {
        const result = await this.merge(component, versions);
        mergeResults.push(result);
      } catch (err) {
        if (err instanceof _exceptions().MergeConflict || err instanceof _componentNeedsUpdate().default) {
          // don't throw. instead, get all components with merge-conflicts
          errors.push(err);
        } else {
          throw err;
        }
      }
    }));
    return {
      mergeResults,
      errors
    };
  }
  /**
   * the merge is needed only when both, local lane and remote lane have the same component with
   * a different head.
   * the different head can be a result of one component is ahead of the other (fast-forward is
   *  possible), or they both have diverged.
   *
   * 1a) fast-forward case, existing is ahead. existing has snapA => snapB, incoming has snapA.
   * we can just ignore the incoming.
   *
   * 1b) fast-forward case, incoming is ahead. existing has snapA, incoming has snapA => snapB.
   * we should update the existing head according to the incoming.
   *
   * 2) true-merge case, existing has snapA => snapB, incoming has snapA => snapC.
   *
   * in case this is a remote (the incoming component comes as a result of export):
   * throw an error telling the client to pull the lane from the remote in order to merge the
   * new snaps. the client during the merge process will create a snap-merge that is going to be
   * the new head, which eventually becoming the case 1b.
   *
   * in case this is a local (the incoming component comes as a result of import):
   * do not update the lane object. only save the data on the refs/remote/lane-name.
   */


  async mergeLane(lane, isImport) {
    const repo = this.objects();
    const existingLane = await this.scope.loadLane(lane.toLaneId());
    const mergeResults = [];
    const mergeErrors = [];
    await Promise.all(lane.components.map(async component => {
      const modelComponent = await this.get(component.id);

      if (!modelComponent) {
        throw new Error(`unable to merge lane ${lane.name}, the component ${component.id.toString()} was not found`);
      }

      const existingComponent = existingLane ? existingLane.components.find(c => c.id.isEqual(component.id)) : null;

      if (!existingComponent) {
        modelComponent.laneHeadLocal = component.head;
        const allVersions = await (0, _traverseVersions().getAllVersionHashes)(modelComponent, repo);
        if (existingLane) existingLane.addComponent(component);
        mergeResults.push({
          mergedComponent: modelComponent,
          mergedVersions: allVersions.map(h => h.toString())
        });
        return;
      }

      if (existingComponent.head.isEqual(component.head)) {
        mergeResults.push({
          mergedComponent: modelComponent,
          mergedVersions: []
        });
        return;
      }

      modelComponent.laneHeadRemote = component.head;
      modelComponent.laneHeadLocal = existingComponent.head;
      await modelComponent.setDivergeData(repo);
      const divergeResults = modelComponent.getDivergeData();

      if (divergeResults.isDiverged()) {
        if (isImport) {
          // do not update the local lane. later, suggest to snap-merge.
          mergeResults.push({
            mergedComponent: modelComponent,
            mergedVersions: []
          });
          return;
        }

        mergeErrors.push(new (_componentNeedsUpdate().default)(component.id.toString(), existingComponent.head.toString()));
        return;
      }

      if (divergeResults.isRemoteAhead()) {
        existingComponent.head = component.head;
        mergeResults.push({
          mergedComponent: modelComponent,
          mergedVersions: divergeResults.snapsOnRemoteOnly.map(h => h.toString())
        });
        return;
      } // local is ahead, nothing to merge.


      mergeResults.push({
        mergedComponent: modelComponent,
        mergedVersions: []
      });
    }));
    return {
      mergeResults,
      mergeErrors,
      mergeLane: existingLane || lane
    };
  }

}

exports.default = SourceRepository;