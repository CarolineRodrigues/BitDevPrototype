"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDivergeData = getDivergeData;

function _difference2() {
  const data = _interopRequireDefault(require("ramda/src/difference"));

  _difference2 = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _noCommonSnap() {
  const data = require("../exceptions/no-common-snap");

  _noCommonSnap = function () {
    return data;
  };

  return data;
}

function _divergeData() {
  const data = require("./diverge-data");

  _divergeData = function () {
    return data;
  };

  return data;
}

function _traverseVersions() {
  const data = require("./traverse-versions");

  _traverseVersions = function () {
    return data;
  };

  return data;
}

/**
 * traversing the snaps history is not cheap, so we first try to avoid it and if not possible,
 * traverse by the local head, if it finds the remote head, no need to traverse by the remote
 * head. (it also means that we can do fast-forward and no need for snap-merge).
 */
async function getDivergeData(repo, modelComponent, remoteHead, checkedOutLocalHead, // in case locally on the workspace it has a different version
throws = true) {
  const isOnLane = modelComponent.laneHeadLocal || modelComponent.laneHeadLocal === null;
  const localHead = checkedOutLocalHead || (isOnLane ? modelComponent.laneHeadLocal : modelComponent.getHead());

  if (!remoteHead) {
    if (localHead) {
      const allLocalHashes = await (0, _traverseVersions().getAllVersionHashes)(modelComponent, repo, false);
      return new (_divergeData().DivergeData)(allLocalHashes);
    }

    return new (_divergeData().DivergeData)();
  }

  if (!localHead) {
    const allRemoteHashes = await (0, _traverseVersions().getAllVersionHashes)(modelComponent, repo, false, remoteHead);
    return new (_divergeData().DivergeData)([], allRemoteHashes);
  }

  if (remoteHead.isEqual(localHead)) {
    // no diverge they're the same
    return new (_divergeData().DivergeData)();
  }

  const snapsOnLocal = [];
  const snapsOnRemote = [];
  let remoteHeadExistsLocally = false;
  let localHeadExistsRemotely = false;
  let commonSnapBeforeDiverge;

  const addParentsRecursively = async (version, snaps, isLocal) => {
    if (isLocal && version.hash().isEqual(remoteHead)) {
      remoteHeadExistsLocally = true;
      return;
    }

    if (!isLocal && version.hash().isEqual(localHead)) {
      localHeadExistsRemotely = true;
      return;
    }

    if (!isLocal && !commonSnapBeforeDiverge) {
      const snapExistLocally = snapsOnLocal.find(snap => snap.isEqual(version.hash()));
      if (snapExistLocally) commonSnapBeforeDiverge = snapExistLocally;
    }

    snaps.push(version.hash());
    await Promise.all(version.parents.map(async parent => {
      const parentVersion = await parent.load(repo);

      if (parentVersion) {
        await addParentsRecursively(parentVersion, snaps, isLocal);
      } else if (throws) {
        throw new (_exceptions().ParentNotFound)(modelComponent.id(), version.hash().toString(), parent.toString());
      }
    }));
  };

  const localVersion = await repo.load(localHead);

  if (!localVersion) {
    throw new Error(`fatal: a component "${modelComponent.id()}" is missing the local head object (${localHead}) in the filesystem.
run the following command to fix it:
bit import ${modelComponent.id()} --objects`);
  }

  await addParentsRecursively(localVersion, snapsOnLocal, true);

  if (remoteHeadExistsLocally) {
    return new (_divergeData().DivergeData)(snapsOnLocal, [], remoteHead);
  }

  const remoteVersion = await repo.load(remoteHead);

  if (!remoteVersion) {
    throw new Error(`getDivergeData: unable to find Version ${remoteHead.toString()} of ${modelComponent.id()}`);
  }

  await addParentsRecursively(remoteVersion, snapsOnRemote, false);

  if (localHeadExistsRemotely) {
    return new (_divergeData().DivergeData)([], snapsOnRemote, localHead);
  } // @ts-ignore


  if (!commonSnapBeforeDiverge) throw new (_noCommonSnap().NoCommonSnap)(modelComponent.id());
  return new (_divergeData().DivergeData)((0, _difference2().default)(snapsOnLocal, snapsOnRemote), (0, _difference2().default)(snapsOnRemote, snapsOnLocal), commonSnapBeforeDiverge);
}