"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.groupByLanes = groupByLanes;
exports.groupByScopeName = groupByScopeName;

function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));

  _uniq2 = function () {
    return data;
  };

  return data;
}

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));

  _isNil2 = function () {
    return data;
  };

  return data;
}

function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));

  _reject2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _asyncMutex() {
  const data = require("async-mutex");

  _asyncMutex = function () {
    return data;
  };

  return data;
}

function _pMap() {
  const data = _interopRequireDefault(require("p-map"));

  _pMap = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _groupArray() {
  const data = _interopRequireDefault(require("group-array"));

  _groupArray = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _enrichContextFromGlobal() {
  const data = _interopRequireDefault(require("../../hooks/utils/enrich-context-from-global"));

  _enrichContextFromGlobal = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _objectList() {
  const data = require("../objects/object-list");

  _objectList = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("../scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _versionDependencies() {
  const data = _interopRequireDefault(require("../version-dependencies"));

  _versionDependencies = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _objectsFetcher() {
  const data = require("../objects-fetcher/objects-fetcher");

  _objectsFetcher = function () {
    return data;
  };

  return data;
}

function _concurrency() {
  const data = require("../../utils/concurrency");

  _concurrency = function () {
    return data;
  };

  return data;
}

const removeNils = (0, _reject2().default)(_isNil2().default);

class ScopeComponentsImporter {
  constructor(scope) {
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "sources", void 0);
    (0, _defineProperty2().default)(this, "repo", void 0);
    (0, _defineProperty2().default)(this, "fetchWithDepsMutex", new (_asyncMutex().Mutex)());
    if (!scope) throw new Error('unable to instantiate ScopeComponentsImporter without Scope');
    this.scope = scope;
    this.sources = scope.sources;
    this.repo = scope.objects;
  }

  static getInstance(scope) {
    return new ScopeComponentsImporter(scope);
  }
  /**
   * ensure the given ids and their dependencies are in the scope.
   * if they belong to this scope and are not exist, throw ComponentNotFound.
   * if they are external, fetch them from their remotes by calling this.getExternalMany(), which
   * fetches these components and all their flattened dependencies.
   *
   * keep in mind that as a rule, an indirect dependency should be fetched from its dependent
   * remote first and not from its original scope because it might not be available anymore in the
   * original scope but it must be available in the dependent scope.
   * to ensure we ask getExternalMany for the direct dependency only, the following is done for
   * each one of the components:
   * 1. get the component object.
   * 1.a. If It's a local component and not exists, throw ComponentNotFound.
   * 1.b. If it's an external component and not exists, put it in the externalsToFetch array.
   * 2. If all flattened exist locally - exit.
   * 3. otherwise, go to each one of the direct dependencies and do the following:
   * 3. a. Load the component. (Again, if it's local and not found, throw. Otherwise, put it in the externalsToFetch array).
   * 3. b. If all flattened exists locally - exit the loop.
   * 3. c. otherwise, put it in the externalsToFetch array.
   */


  async importMany({
    ids,
    cache = true,
    throwForDependencyNotFound = false,
    reFetchUnBuiltVersion = true,
    lanes = []
  }) {
    _logger().default.debugAndAddBreadCrumb('importMany', `cache ${cache}, throwForDependencyNotFound: ${throwForDependencyNotFound}. ids: {ids}`, {
      ids: ids.toString()
    });

    const idsToImport = (0, _lodash().compact)(ids.filter(id => id.hasScope()));

    if ((0, _isEmpty2().default)(idsToImport)) {
      _logger().default.debug(`importMany, nothing to import`);

      return [];
    }

    const externalsToFetch = [];
    const compDefs = await this.sources.getMany(idsToImport, reFetchUnBuiltVersion);
    const existingDefs = compDefs.filter(({
      id,
      component
    }) => {
      if (id.isLocal(this.scope.name)) {
        if (!component) throw new (_exceptions().ComponentNotFound)(id.toString());
        return true;
      }

      if (cache && component) return true;
      externalsToFetch.push(id);
      return false;
    });
    await this.findMissingExternalsRecursively(existingDefs, externalsToFetch);

    const uniqExternals = _bitId().BitIds.uniqFromArray(externalsToFetch);

    _logger().default.debug('importMany', `total missing externals: ${uniqExternals.length}`);

    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope); // we don't care about the VersionDeps returned here as it may belong to the dependencies

    await this.getExternalMany(uniqExternals, remotes, throwForDependencyNotFound, lanes);
    const versionDeps = await this.bitIdsToVersionDeps(idsToImport);

    _logger().default.debug('importMany, completed!');

    return versionDeps;
  }
  /**
   * as opposed to importMany, which imports from dependents only.
   * needed mostly for cases when importMany doesn't work due to corrupted cache or the cache
   * doesn't exist yet.
   *
   * the downside is that a flattened-dependency could be on a dependent only and not on the
   * original scope, so it won't be retrieved by this method, however, next time the component is
   * imported,
   */


  async importManyFromOriginalScopes(ids) {
    _logger().default.debugAndAddBreadCrumb('importManyFromOriginalScopes', `ids: {ids}`, {
      ids: ids.toString()
    });

    const idsToImport = (0, _lodash().compact)(ids);
    if ((0, _isEmpty2().default)(idsToImport)) return [];
    const externalsToFetch = [];
    const defs = await this.sources.getMany(idsToImport);
    const existingDefs = defs.filter(({
      id,
      component
    }) => {
      if (component) return true;
      if (id.isLocal(this.scope.name)) throw new (_exceptions().ComponentNotFound)(id.toString());
      externalsToFetch.push(id);
      return false;
    });
    const versionDeps = await this.multipleCompsDefsToVersionDeps(existingDefs);
    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);

    _logger().default.debugAndAddBreadCrumb('importManyFromOriginalScopes', 'successfully fetched local components and their dependencies. Going to fetch externals');

    const externalDeps = await this.getExternalMany(externalsToFetch, remotes);
    return [...versionDeps, ...externalDeps];
  }

  async importWithoutDeps(ids, cache = true, lanes = []) {
    if (!ids.length) return [];

    _logger().default.debugAndAddBreadCrumb('importWithoutDeps', `ids: {ids}`, {
      ids: ids.toString()
    });

    const idsWithoutNils = removeNils(ids);
    if ((0, _isEmpty2().default)(idsWithoutNils)) return Promise.resolve([]);
    const [externals, locals] = (0, _utils().splitBy)(idsWithoutNils, id => id.isLocal(this.scope.name));
    const localDefs = await this.sources.getMany(locals);
    const componentVersionArr = await Promise.all(localDefs.map(def => {
      if (!def.component) {
        _logger().default.warn(`importWithoutDeps failed to find a local component ${def.id.toString()}. continuing without this component`);

        return null;
      }

      return def.component.toComponentVersion(def.id.version);
    }));
    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
    const externalDeps = await this.getExternalManyWithoutDeps(externals, remotes, cache, undefined, lanes);
    return [...(0, _lodash().compact)(componentVersionArr), ...externalDeps];
  }

  async importManyWithAllVersions(ids, cache = true, allDepsVersions = false, // by default, only dependencies of the latest version are imported
  lanes = []) {
    _logger().default.debug(`scope.getManyWithAllVersions, Ids: ${ids.join(', ')}`);

    _analytics().Analytics.addBreadCrumb('getManyWithAllVersions', `scope.getManyWithAllVersions, Ids: ${_analytics().Analytics.hashData(ids)}`);

    const idsWithoutNils = removeNils(ids);
    if ((0, _isEmpty2().default)(idsWithoutNils)) return Promise.resolve([]);
    const versionDependenciesArr = await this.importMany({
      ids: idsWithoutNils,
      cache,
      lanes
    });
    const allIdsWithAllVersions = new (_bitId().BitIds)();
    versionDependenciesArr.forEach(versionDependencies => {
      const versions = versionDependencies.component.component.listVersions();
      const versionId = versionDependencies.component.id;
      const idsWithAllVersions = versions.map(version => {
        if (version === versionDependencies.component.version) return null; // imported already

        return versionId.changeVersion(version);
      });
      allIdsWithAllVersions.push(...removeNils(idsWithAllVersions));
      const head = versionDependencies.component.component.getHead();

      if (head) {
        allIdsWithAllVersions.push(versionId.changeVersion(head.toString()));
      }
    });

    if (allDepsVersions) {
      const verDepsOfOlderVersions = await this.importMany({
        ids: allIdsWithAllVersions,
        cache,
        lanes
      });
      versionDependenciesArr.push(...verDepsOfOlderVersions);
      const allFlattenDepsIds = versionDependenciesArr.map(v => v.allDependencies.map(d => d.id));
      const dependenciesOnly = (0, _flatten2().default)(allFlattenDepsIds).filter(id => !ids.hasWithoutVersion(id));
      const verDepsOfAllFlattenDeps = await this.importManyWithAllVersions(_bitId().BitIds.uniqFromArray(dependenciesOnly), undefined, undefined, lanes);
      versionDependenciesArr.push(...verDepsOfAllFlattenDeps);
    } else {
      await this.importWithoutDeps(allIdsWithAllVersions, undefined, lanes);
    }

    return versionDependenciesArr;
  }
  /**
   * delta between the local head and the remote head. mainly to improve performance
   * not applicable and won't work for legacy. for legacy, refer to importManyWithAllVersions
   */


  async importManyDeltaWithoutDeps(ids, allHistory = false) {
    _logger().default.debugAndAddBreadCrumb('importManyDeltaWithoutDeps', `Ids: {ids}`, {
      ids: ids.toString()
    });

    const idsWithoutNils = _bitId().BitIds.uniqFromArray((0, _lodash().compact)(ids));

    if ((0, _isEmpty2().default)(idsWithoutNils)) return;
    const compDef = await this.sources.getMany(idsWithoutNils.toVersionLatest(), true);
    const idsToFetch = await (0, _pMapSeries().default)(compDef, async ({
      id,
      component
    }) => {
      if (!component || allHistory) {
        // remove the version to fetch it with all versions.
        return id.changeVersion(undefined);
      } // @todo: fix to consider local lane


      const remoteLaneId = _laneId().RemoteLaneId.from(_constants().DEFAULT_LANE, id.scope);

      const remoteHead = await this.repo.remoteLanes.getRef(remoteLaneId, id);

      if (!remoteHead) {
        return id.changeVersion(undefined);
      }

      const remoteHeadExists = await this.repo.has(remoteHead);

      if (!remoteHeadExists) {
        _logger().default.warn(`remote-ref exists for ${id.toString()}, lane ${remoteLaneId.toString()}, but the object is missing on the fs`);

        return id.changeVersion(undefined);
      }

      return id.changeVersion(remoteHead.toString());
    });
    const groupedIds = groupByScopeName(idsToFetch);
    const idsOnlyDelta = idsToFetch.filter(id => id.hasVersion());
    const idsAllHistory = idsToFetch.filter(id => !id.hasVersion());
    const remotesCount = Object.keys(groupedIds).length;
    const statusMsg = `fetching ${idsToFetch.length} components from ${remotesCount} remotes. delta-only: ${idsOnlyDelta.length}, all-history: ${idsAllHistory.length}.`;

    _loader().default.start(statusMsg);

    _logger().default.debugAndAddBreadCrumb('importManyDeltaWithoutDeps', statusMsg);

    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
    await new (_objectsFetcher().ObjectFetcher)(this.repo, this.scope, remotes, {
      type: 'component-delta',
      withoutDependencies: true
    }, idsToFetch).fetchFromRemoteAndWrite();
  }

  async importFromLanes(remoteLaneIds) {
    const lanes = await this.importLanes(remoteLaneIds);
    const ids = lanes.map(lane => lane.toBitIds());

    const bitIds = _bitId().BitIds.uniqFromArray((0, _flatten2().default)(ids));

    await this.importManyWithAllVersions(bitIds, false, undefined, lanes);
    return lanes;
  }

  async importLanes(remoteLaneIds) {
    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
    const objectsStreamPerRemote = await remotes.fetch(groupByScopeName(remoteLaneIds), this.scope, {
      type: 'lane'
    });
    const multipleStreams = Object.values(objectsStreamPerRemote);
    const bitObjects = await this.multipleStreamsToBitObjects(multipleStreams);
    const lanes = bitObjects.getLanes();
    await Promise.all(lanes.map(lane => this.repo.remoteLanes.syncWithLaneObject(lane.scope, lane)));
    return lanes;
  }
  /**
   * currently used for import artifacts, but can be used to import any arbitrary array of hashes.
   * it takes care to remove any duplications and check whether the object exists locally before
   * going to the remote.
   * just make sure not to use it for components/lanes, as they require a proper "merge" before
   * persisting them to the filesystem. this method is good for immutable objects.
   */


  async importManyObjects(groupedHashes) {
    const groupedHashedMissing = {};
    await Promise.all(Object.keys(groupedHashes).map(async scopeName => {
      const uniqueHashes = (0, _uniq2().default)(groupedHashes[scopeName]);
      const missing = await (0, _bluebird().filter)(uniqueHashes, async hash => !(await this.repo.has(new (_objects().Ref)(hash))));

      if (missing.length) {
        groupedHashedMissing[scopeName] = missing;
      }
    }));
    if ((0, _isEmpty2().default)(groupedHashedMissing)) return;
    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
    const multipleStreams = await remotes.fetch(groupedHashedMissing, this.scope, {
      type: 'object'
    });
    const bitObjectsList = await this.multipleStreamsToBitObjects(Object.values(multipleStreams));
    await this.repo.writeObjectsToTheFS(bitObjectsList.getAll());
  }

  async fetchWithoutDeps(ids, allowExternal) {
    _logger().default.debugAndAddBreadCrumb('fetchWithoutDeps', `ids: {ids}`, {
      ids: ids.toString()
    });

    if (!allowExternal) this.throwIfExternalFound(ids);
    const localDefs = await this.sources.getMany(ids);
    const componentVersionArr = await Promise.all(localDefs.map(({
      id,
      component
    }) => {
      if (!component) {
        _logger().default.warn(`fetchWithoutDeps failed finding a local component ${id.toString()}`);

        return null;
      }

      return component.toComponentVersion(id.version);
    }));
    return (0, _lodash().compact)(componentVersionArr);
  }

  async fetchWithDeps(ids, allowExternal) {
    _logger().default.debugAndAddBreadCrumb('fetchWithDeps', `ids: {ids}`, {
      ids: ids.toString()
    });

    if (!allowExternal) this.throwIfExternalFound(ids); // avoid race condition of getting multiple "fetch" requests, which later translates into
    // multiple getExternalMany calls, which saves objects and write refs files at the same time

    return this.fetchWithDepsMutex.runExclusive(async () => {
      _logger().default.debug('fetchWithDeps, acquiring a lock');

      const localDefs = await this.sources.getMany(ids);
      const versionDeps = await this.multipleCompsDefsToVersionDeps(localDefs);

      _logger().default.debug('fetchWithDeps, releasing the lock');

      return versionDeps;
    });
  }

  async componentToVersionDependencies(component, id) {
    const versionComp = component.toComponentVersion(id.version);
    const version = await this.getVersionFromComponentDef(component, id);

    if (!version) {
      // must be external, otherwise, it'd be thrown at getVersionFromComponentDef
      _logger().default.debug(`toVersionDependencies, component ${component.id().toString()}, version ${versionComp.version} not found, going to fetch from a remote`);

      const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
      const versionDeps = await this.getExternalMany([id], remotes);
      return versionDeps.length ? versionDeps[0] : null;
    }

    _logger().default.debug(`toVersionDependencies, component ${component.id().toString()}, version ${versionComp.version} found, going to collect its dependencies`);

    const dependencies = await this.importWithoutDeps(version.flattenedDependencies);
    return new (_versionDependencies().default)(versionComp, dependencies, version);
  }
  /**
   * get ConsumerComponent by bitId. if the component was not found locally, import it from a remote scope
   */


  async loadRemoteComponent(id) {
    const component = await this._getComponentVersion(id);
    if (!component) throw new (_exceptions().ComponentNotFound)(id.toString());
    return component.toConsumer(this.scope.objects, null);
  }

  async loadComponent(id, localOnly = true) {
    _logger().default.debugAndAddBreadCrumb('ScopeComponentsImporter', 'loadComponent {id}', {
      id: id.toString()
    });

    if (localOnly && !id.isLocal(this.scope.name)) {
      throw new (_generalError().default)('cannot load a component from remote scope, please import first');
    }

    return this.loadRemoteComponent(id);
  }
  /**
   * get a single component from a remote without saving it locally
   */


  async getRemoteComponent(id) {
    if (!id.scope) {
      throw new Error(`unable to get remote component "${id.toString()}", the scope is empty`);
    }

    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
    let bitObjectsList;

    try {
      const streams = await remotes.fetch({
        [id.scope]: [id.toString()]
      }, this.scope);
      bitObjectsList = await this.multipleStreamsToBitObjects(Object.values(streams));
    } catch (err) {
      _logger().default.error(`getRemoteComponent, failed to get ${id.toString()}`, err);

      return null; // probably doesn't exist
    }

    return bitObjectsList;
  }

  async multipleStreamsToBitObjects(streams) {
    const objectListPerRemote = await Promise.all(streams.map(stream => _objectList().ObjectList.fromReadableStream(stream)));

    const objectList = _objectList().ObjectList.mergeMultipleInstances(objectListPerRemote);

    const bitObjects = await objectList.toBitObjects();
    return bitObjects;
  }

  async getVersionFromComponentDef(component, id) {
    const versionComp = component.toComponentVersion(id.version);
    const version = await versionComp.getVersion(this.scope.objects, false);
    if (version) return version;

    if (id.isLocal(this.scope.name)) {
      // it should have been fetched locally, since it wasn't found, this is an error
      throw new (_showDoctorError().default)(`Version ${versionComp.version} of ${id.toString()} was not found in scope ${this.scope.name}`);
    }

    return null;
  }

  async multipleCompsDefsToVersionDeps(compsDefs) {
    const concurrency = (0, _concurrency().concurrentComponentsLimit)();
    const componentsWithVersionsWithNulls = await (0, _pMap().default)(compsDefs, async ({
      component,
      id
    }) => {
      if (!component) return null;

      if (component.isEmpty() && !id.hasVersion() && !component.laneHeadLocal) {
        // this happens for example when importing a remote lane and then running "bit fetch --components"
        // the head is empty because it exists on the lane only, it was never tagged and
        // laneHeadLocal was never set as it originated from the scope, not the consumer.
        return null;
      }

      const versionComp = component.toComponentVersion(id.version);
      const version = await this.getVersionFromComponentDef(component, id);

      if (!version) {
        throw new Error(`ScopeComponentImporter, expect ${id.toString()} to have a Version object`);
      }

      return {
        componentVersion: versionComp,
        versionObj: version
      };
    }, {
      concurrency
    });
    const componentsWithVersion = (0, _lodash().compact)(componentsWithVersionsWithNulls);
    const idsToFetch = new (_bitId().BitIds)();
    componentsWithVersion.forEach(compWithVer => {
      idsToFetch.add(compWithVer.versionObj.flattenedDependencies);
    });
    const compVersionsOfDeps = await this.importWithoutDeps(idsToFetch);
    const versionDeps = componentsWithVersion.map(({
      componentVersion,
      versionObj
    }) => {
      const dependencies = versionObj.flattenedDependencies.map(dep => compVersionsOfDeps.find(c => c.id.isEqual(dep)));
      return new (_versionDependencies().default)(componentVersion, (0, _lodash().compact)(dependencies), versionObj);
    });
    return versionDeps;
  }
  /**
   * get multiple components from remotes with their dependencies.
   * never checks if exist locally. always fetches from remote and then, save into the model.
   */


  async getExternalMany(ids, remotes, throwForDependencyNotFound = false, lanes = []) {
    if (!ids.length) return [];

    _logger().default.debugAndAddBreadCrumb('ScopeComponentsImporter.getExternalMany', `fetching from remote scope. Ids: {ids}`, {
      ids: ids.join(', ')
    });

    const context = {};
    ids.forEach(id => {
      if (id.isLocal(this.scope.name)) throw new Error(`getExternalMany expects to get external ids only, got ${id.toString()}`);
    });
    (0, _enrichContextFromGlobal().default)(Object.assign({}, {
      requestedBitIds: ids.map(id => id.toString())
    }));
    await new (_objectsFetcher().ObjectFetcher)(this.repo, this.scope, remotes, {
      withoutDependencies: false
    }, ids, lanes, context).fetchFromRemoteAndWrite();
    const componentDefs = await this.sources.getMany(ids);
    const versionDeps = await this.multipleCompsDefsToVersionDeps(componentDefs);

    if (throwForDependencyNotFound) {
      versionDeps.forEach(verDep => verDep.throwForMissingDependencies());
    }

    return versionDeps;
  }

  async getExternalManyWithoutDeps(ids, remotes, localFetch = false, context = {}, lanes = []) {
    if (!ids.length) return [];

    _logger().default.debugAndAddBreadCrumb('getExternalManyWithoutDeps', `ids: {ids}, localFetch: ${localFetch.toString()}`, {
      ids: ids.join(', ')
    });

    const defs = await this.sources.getMany(ids, true);
    const left = defs.filter(def => !localFetch || !def.component);

    if (left.length === 0) {
      _logger().default.debugAndAddBreadCrumb('getExternalManyWithoutDeps', 'no more ids left, all found locally'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      return Promise.all(defs.map(def => def.component.toComponentVersion(def.id.version)));
    }

    _logger().default.debugAndAddBreadCrumb('getExternalManyWithoutDeps', `${left.length} left. Fetching them from a remote`);

    (0, _enrichContextFromGlobal().default)(Object.assign(context, {
      requestedBitIds: ids.map(id => id.toString())
    }));
    await new (_objectsFetcher().ObjectFetcher)(this.repo, this.scope, remotes, {
      withoutDependencies: true
    }, left.map(def => def.id), lanes, context).fetchFromRemoteAndWrite();
    const finalDefs = await this.sources.getMany(ids);
    return Promise.all(finalDefs.filter(def => def.component) // @todo: should we warn about the non-missing?
    // @ts-ignore
    .map(def => def.component.toComponentVersion(def.id.version)));
  }

  async _getComponentVersion(id) {
    if (!id.isLocal(this.scope.name)) {
      const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
      const componentVersions = await this.getExternalManyWithoutDeps([id], remotes, true);
      if (!componentVersions.length) throw new (_generalError().default)(`unable to find ${id.toString()} in its remote`);
      return componentVersions[0];
    }

    return this.sources.get(id).then(component => {
      if (!component) throw new (_exceptions().ComponentNotFound)(id.toString()); // $FlowFixMe version is set
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return component.toComponentVersion(id.version);
    });
  }
  /**
   * once we discover that a component is external, no need to dig deeper to its dependencies, we
   * just add it to `externalsToFetch` array. later, its dependencies will be fetched from the
   * dependent remote.
   * the recursive is needed for locals. if this component is local, we need to know what
   * components to ask for from the remote. we iterate over the direct dependencies and if some of
   * them are local as well, we need to iterate over their dependencies and so on.
   */


  async findMissingExternalsRecursively(compDefs, externalsToFetch, visited = [], existingCache = new (_bitId().BitIds)()) {
    if (!compDefs.length) return;
    const idsStr = compDefs.map(c => c.id.toString()).join(', ');

    _logger().default.debug(`findMissingExternalsRecursively, components ${idsStr}`);

    const compDefsForNextIteration = [];
    await (0, _pMapSeries().default)(compDefs, async ({
      component,
      id
    }) => {
      const idStr = id.toString();
      if (visited.includes(idStr)) return;
      visited.push(idStr);

      if (!component) {
        if (id.isLocal(this.scope.name)) throw new (_exceptions().ComponentNotFound)(idStr);
        externalsToFetch.push(id);
        return;
      }

      const version = await this.getVersionFromComponentDef(component, id);

      if (!version) {
        // it must be external. otherwise, getVersionFromComponentDef would throw
        externalsToFetch.push(id);
        return;
      }

      const flattenedDepsToLocate = version.flattenedDependencies.filter(dep => !existingCache.has(dep));
      const flattenedDepsDefs = await this.sources.getMany(flattenedDepsToLocate, true);
      const allFlattenedExist = flattenedDepsDefs.every(def => {
        if (!def.component) return false;
        existingCache.push(def.id);
        return true;
      });

      if (allFlattenedExist) {
        return;
      } // some flattened are missing


      if (!id.isLocal(this.scope.name)) {
        externalsToFetch.push(id);
        return;
      } // it's local and some flattened are missing, check the direct dependencies


      const directDepsDefs = await this.sources.getMany(version.getAllDependenciesIds(), true);
      compDefsForNextIteration.push(...directDepsDefs);
    });
    await this.findMissingExternalsRecursively(compDefsForNextIteration, externalsToFetch, visited, existingCache);
  }
  /**
   * convert ids to VersionDependencies with performance in mind.
   * it doesn't go to any remote and it fetches each component only once.
   */


  async bitIdsToVersionDeps(ids) {
    _logger().default.debug(`bitIdsToVersionDeps, ${ids.length} ids`);

    const compDefs = await this.sources.getMany(ids);
    const versionDepsWithNulls = await (0, _pMapSeries().default)(compDefs, async ({
      component,
      id
    }) => {
      if (!component) throw new (_exceptions().ComponentNotFound)(id.toString());

      if (component.isEmpty() && !id.hasVersion() && !component.laneHeadLocal) {
        // this happens for example when importing a remote lane and then running "bit fetch --components"
        // the head is empty because it exists on the lane only, it was never tagged and
        // laneHeadLocal was never set as it originated from the scope, not the consumer.
        return null;
      }

      const versionComp = component.toComponentVersion(id.version);
      const version = await this.getVersionFromComponentDef(component, id);

      if (!version) {
        // should have been fetched before by getExternalMany(). probably doesn't exist on the remote.
        throw new (_showDoctorError().default)(`Version ${versionComp.version} of ${component.id().toString()} was not found`);
      }

      return new (_versionDependencies().default)(versionComp, [], version);
    });
    const versionDeps = (0, _lodash().compact)(versionDepsWithNulls);
    const allFlattened = versionDeps.map(v => v.version.getAllFlattenedDependencies());

    const allFlattenedUniq = _bitId().BitIds.uniqFromArray((0, _lodash().flatten)(allFlattened));

    const allFlattenedDefs = await this.sources.getMany(allFlattenedUniq);
    const flattenedComponentVersions = (0, _lodash().compact)(allFlattenedDefs.map(({
      id,
      component
    }) => {
      if (!component) {
        _logger().default.warn(`fetchWithoutDeps failed finding a local component ${id.toString()}`);

        return null;
      }

      return component.toComponentVersion(id.version);
    }));
    versionDeps.forEach(versionDep => {
      const deps = versionDep.version.flattenedDependencies.map(dep => flattenedComponentVersions.find(c => c.id.isEqual(dep)));
      versionDep.dependencies = (0, _lodash().compact)(deps);
    });
    return versionDeps;
  }

  throwIfExternalFound(ids) {
    const [externals] = (0, _utils().splitBy)(ids, id => id.isLocal(this.scope.name));

    if (externals.length) {
      const externalStr = externals.map(id => id.toString()).join(', '); // we can't support fetching-with-dependencies of external components as we risk going into an infinite loop

      throw new Error(`fatal API does not support fetching components from different scopes.
current scope: "${this.scope.name}", externals: "${externalStr}"
please make sure that the scope-resolver points to the right scope.`);
    }
  }

}

exports.default = ScopeComponentsImporter;

function groupByScopeName(ids) {
  const grouped = (0, _groupArray().default)(ids, 'scope');
  Object.keys(grouped).forEach(scopeName => {
    grouped[scopeName] = grouped[scopeName].map(id => id.toString());
  });
  return grouped;
}

function groupByLanes(ids, lanes) {
  const bitIdsStr = ids.map(id => id.toString());
  const grouped = {};
  lanes.forEach(lane => {
    const scope = lane.scope;

    if (!scope) {
      throw new Error(`can't group by Lane object, the scope is undefined for ${lane.id()}`);
    }

    const laneIdsStr = lane.toBitIds().map(id => id.toString());
    const intersectIds = (0, _lodash().intersection)(bitIdsStr, laneIdsStr);
    if (!intersectIds.length) return;
    (grouped[scope] || (grouped[scope] = [])).push(...laneIdsStr);
  });
  return grouped;
}