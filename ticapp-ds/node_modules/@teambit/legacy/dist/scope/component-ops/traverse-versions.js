"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllVersionHashes = getAllVersionHashes;
exports.getAllVersionHashesByVersionsObjects = getAllVersionHashesByVersionsObjects;
exports.getAllVersionsInfo = getAllVersionsInfo;
exports.getAllVersionsObjects = getAllVersionsObjects;
exports.hasVersionByRef = hasVersionByRef;

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

/**
 * the snaps are saved as DAG (Direct Acyclic Graph).
 * each snap has `parents` prop.
 * when this is the first snap, the `parents` is empty.
 * the followed snap has the first snap as a parent.
 * in case of a merge between lanes, the `parents` have two snaps from the two lanes.
 *
 * traverse all versions is not cheap. it must load the Version object to extract the `parents`
 * data. so, we plan to cache it. once this is cached, we'll change the implementation of a few
 * methods here.
 */

/**
 * by default it starts the traverse from the head or lane-head, unless "startFrom" is passed.
 * if versionObjects passed, use it instead of loading from the repo.
 */
async function getAllVersionsInfo({
  modelComponent,
  repo,
  throws = true,
  versionObjects,
  startFrom,
  stopAt
}) {
  var _modelComponent$getHe;

  const results = [];

  const getVersionObj = async ref => {
    if (versionObjects) return versionObjects.find(v => v.hash().isEqual(ref));
    if (repo) return await ref.load(repo);
    throw new TypeError('getAllVersionsInfo expect to get either repo or versionObjects');
  };

  const getRefToStartFrom = () => {
    if (typeof startFrom !== 'undefined') return startFrom;
    return modelComponent.laneHeadLocal || modelComponent.getHead();
  };

  const laneHead = getRefToStartFrom();
  let stopped = false;
  const headOnMain = (_modelComponent$getHe = modelComponent.getHead()) === null || _modelComponent$getHe === void 0 ? void 0 : _modelComponent$getHe.toString();
  let foundOnMain = (laneHead === null || laneHead === void 0 ? void 0 : laneHead.toString()) === headOnMain;

  if (laneHead) {
    const headInfo = {
      ref: laneHead,
      tag: modelComponent.getTagOfRefIfExists(laneHead),
      parents: [],
      onLane: !foundOnMain
    };
    const head = await getVersionObj(laneHead);

    if (head) {
      if (stopAt && stopAt.isEqual(head.hash())) {
        return [];
      }

      headInfo.version = head;
      headInfo.parents = head.parents;
    } else {
      headInfo.error = new (_exceptions().HeadNotFound)(modelComponent.id(), laneHead.toString());
      if (throws) throw headInfo.error;
    }

    results.push(headInfo);

    const addParentsRecursively = async version => {
      await Promise.all(version.parents.map(async parent => {
        if (stopAt && stopAt.isEqual(parent)) {
          stopped = true;
          return;
        }

        const parentVersion = await getVersionObj(parent);
        if (!foundOnMain) foundOnMain = (parentVersion === null || parentVersion === void 0 ? void 0 : parentVersion._hash) === headOnMain;
        const versionInfo = {
          ref: parent,
          tag: modelComponent.getTagOfRefIfExists(parent),
          isPartOfHistory: true,
          parents: (parentVersion === null || parentVersion === void 0 ? void 0 : parentVersion.parents) || [],
          onLane: !foundOnMain
        };

        if (parentVersion) {
          versionInfo.version = parentVersion;
        } else {
          versionInfo.error = versionInfo.tag ? new (_exceptions().VersionNotFound)(versionInfo.tag, modelComponent.id()) : new (_exceptions().ParentNotFound)(modelComponent.id(), version.hash().toString(), parent.toString());
          if (throws) throw versionInfo.error;
        }

        results.push(versionInfo);
        if (parentVersion) await addParentsRecursively(parentVersion);
      }));
    };

    if (head) await addParentsRecursively(head);
  }

  if (stopped) return results; // backward compatibility.
  // components created before v15, might not have head.
  // even if they do have head (as a result of tag/snap after v15), they
  // have old versions without parents and new versions with parents

  await Promise.all(Object.keys(modelComponent.versionsIncludeOrphaned).map(async version => {
    if (!results.find(r => r.tag === version)) {
      const ref = modelComponent.versionsIncludeOrphaned[version];
      const versionObj = await getVersionObj(ref);
      const versionInfo = {
        ref,
        tag: version,
        parents: (versionObj === null || versionObj === void 0 ? void 0 : versionObj.parents) || [],
        onLane: false
      };

      if (versionObj) {
        versionInfo.version = versionObj; // legacy versions didn't have the "parents" concept and they're part of the history.
        // for new versions, since we didn't find this tag during the traversal, they're not part of history.

        versionInfo.isPartOfHistory = Boolean(versionObj.isLegacy);
      } else {
        versionInfo.error = new (_exceptions().VersionNotFound)(version, modelComponent.id());
        if (throws) throw versionInfo.error;
      }

      results.push(versionInfo);
    }
  }));
  return results;
}

async function getAllVersionsObjects(modelComponent, repo, throws = true) {
  const allVersionsInfo = await getAllVersionsInfo({
    modelComponent,
    repo,
    throws
  });
  return allVersionsInfo.map(a => a.version).filter(a => a);
}

async function getAllVersionHashesByVersionsObjects(modelComponent, versionObjects, throws = true) {
  const allVersionsInfo = await getAllVersionsInfo({
    modelComponent,
    throws,
    versionObjects
  });
  return allVersionsInfo.map(v => v.ref).filter(ref => ref);
}

async function getAllVersionHashes(modelComponent, repo, throws = true, startFrom, stopAt) {
  const allVersionsInfo = await getAllVersionsInfo({
    modelComponent,
    repo,
    throws,
    startFrom,
    stopAt
  });
  return allVersionsInfo.map(v => v.ref).filter(ref => ref);
}

async function hasVersionByRef(modelComponent, ref, repo, startFrom) {
  const allVersionHashes = await getAllVersionHashes(modelComponent, repo, true, startFrom);
  return allVersionHashes.some(hash => hash.isEqual(ref));
}