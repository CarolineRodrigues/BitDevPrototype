import { BitId, BitIds } from '../../bit-id';
import { Lane, Version } from '../models';
import Scope from '../scope';
import { ObjectList } from '../objects/object-list';
import { MergeResult } from '../repositories/sources';
export declare type OnExportIdTransformer = (id: BitId) => BitId;
declare type UpdateDependenciesOnExportFunc = (version: Version, idTransformer: OnExportIdTransformer) => Version;
export declare function registerUpdateDependenciesOnExport(func: UpdateDependenciesOnExportFunc): void;
/**
 * ** Legacy and "bit sign" Only **
 *
 * @TODO there is no real difference between bare scope and a working directory scope - let's adjust terminology to avoid confusions in the future
 * saves a component into the objects directory of the remote scope, then, resolves its
 * dependencies, saves them as well. Finally runs the build process if needed on an isolated
 * environment.
 */
export declare function exportManyBareScope(scope: Scope, objectList: ObjectList): Promise<BitIds>;
/**
 * the export process uses four steps. read more about it here: https://github.com/teambit/bit/pull/3371
 */
export declare function exportMany({ scope, isLegacy, ids, // when exporting a lane, the ids are the lane component ids
remoteName, context, includeDependencies, // kind of fork. by default dependencies only cached, with this, their scope-name is changed
changeLocallyAlthoughRemoteIsDifferent, // by default only if remote stays the same the component is changed from staged to exported
codemod, laneObject, allVersions, originDirectly, idsWithFutureScope, resumeExportId, ignoreMissingArtifacts, }: {
    scope: Scope;
    isLegacy: boolean;
    ids: BitIds;
    remoteName: string | null | undefined;
    context?: Record<string, any>;
    includeDependencies: boolean;
    changeLocallyAlthoughRemoteIsDifferent: boolean;
    codemod: boolean;
    laneObject?: Lane;
    allVersions: boolean;
    originDirectly?: boolean;
    idsWithFutureScope: BitIds;
    resumeExportId?: string | undefined;
    ignoreMissingArtifacts?: boolean;
}): Promise<{
    exported: BitIds;
    updatedLocally: BitIds;
    newIdsOnRemote: BitId[];
}>;
/**
 * save objects into the scope.
 */
export declare function saveObjects(scope: Scope, objectList: ObjectList): Promise<BitIds>;
declare type MergeObjectsResult = {
    mergedIds: BitIds;
    mergedComponentsResults: MergeResult[];
    mergedLanes: Lane[];
};
/**
 * merge components into the scope.
 *
 * a component might have multiple versions that some where merged and some were not.
 * the BitIds returned here includes the versions that were merged. so it could contain multiple
 * ids of the same component with different versions
 */
export declare function mergeObjects(scope: Scope, objectList: ObjectList, throwForMissingDeps?: boolean): Promise<MergeObjectsResult>;
export declare function resumeExport(scope: Scope, exportId: string, remotes: string[]): Promise<string[]>;
export {};
