"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLocalVersion = removeLocalVersion;
exports.removeLocalVersionsForAllComponents = removeLocalVersionsForAllComponents;
exports.removeLocalVersionsForComponentsMatchedByWildcard = removeLocalVersionsForComponentsMatchedByWildcard;

function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

/**
 * If not specified version, remove all local versions.
 */
async function removeLocalVersion(scope, id, lane, version, force = false) {
  const component = await scope.getModelComponentIgnoreScope(id);
  await component.setDivergeData(scope.objects);
  const idStr = id.toString();
  const localVersions = component.getLocalTagsOrHashes();
  if (!localVersions.length) throw new (_generalError().default)(`unable to untag ${idStr}, the component is not staged`);

  if (version) {
    const hasVersion = await component.hasVersion(version, scope.objects, false);

    if (!hasVersion) {
      throw new (_generalError().default)(`unable to untag ${idStr}, the version ${version} does not exist`);
    }
  }

  if (version && !localVersions.includes(version)) {
    throw new (_generalError().default)(`unable to untag ${idStr}, the version ${version} was exported already`);
  }

  if (version && component.hasHead()) {
    var _component$laneHeadLo;

    const headTagOrSnap = component.getHeadAsTagIfExist();

    if (version !== headTagOrSnap && version !== ((_component$laneHeadLo = component.laneHeadLocal) === null || _component$laneHeadLo === void 0 ? void 0 : _component$laneHeadLo.toString())) {
      throw new (_generalError().default)(`unable to untag "${idStr}", the version "${version}" is not the head.
as a result, newer versions have this version as part of their history`);
    }
  }

  const versionsToRemove = version ? [version] : localVersions;

  if (!force) {
    const dependencyGraph = await scope.getDependencyGraph();
    versionsToRemove.forEach(versionToRemove => {
      const idWithVersion = component.toBitId().changeVersion(versionToRemove);
      const dependents = dependencyGraph.getImmediateDependentsPerId(idWithVersion);

      if (dependents.length) {
        throw new (_generalError().default)(`unable to untag ${idStr}, the version ${versionToRemove} has the following dependent(s) ${dependents.join(', ')}`);
      }
    });
  }

  const allVersionsObjects = await Promise.all(versionsToRemove.map(localVer => component.loadVersion(localVer, scope.objects)));
  scope.sources.removeComponentVersions(component, versionsToRemove, allVersionsObjects, lane);
  return {
    id,
    versions: versionsToRemove,
    component
  };
}

async function removeLocalVersionsForAllComponents(consumer, lane, version, force = false) {
  const componentsToUntag = await getComponentsWithOptionToUntag(consumer, version);
  return removeLocalVersionsForMultipleComponents(componentsToUntag, lane, version, force, consumer.scope);
}

async function removeLocalVersionsForComponentsMatchedByWildcard(consumer, lane, version, force = false, idWithWildcard) {
  const candidateComponents = await getComponentsWithOptionToUntag(consumer, version);
  const componentsToUntag = idWithWildcard ? _componentsList().default.filterComponentsByWildcard(candidateComponents, idWithWildcard) : candidateComponents;
  return removeLocalVersionsForMultipleComponents(componentsToUntag, lane, version, force, consumer.scope);
}

async function removeLocalVersionsForMultipleComponents(componentsToUntag, lane, version, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
force, scope) {
  if (!componentsToUntag.length) {
    const versionOutput = version ? `${version} ` : '';
    throw new (_generalError().default)(`no components found with version ${versionOutput}to untag on your workspace`);
  } // if no version is given, there is risk of deleting dependencies version without their dependents.


  if (!force && version) {
    const dependencyGraph = await scope.getDependencyGraph();
    const candidateComponentsIds = componentsToUntag.map(component => {
      const bitId = component.toBitId();
      return bitId.changeVersion(version);
    });
    const candidateComponentsIdsStr = candidateComponentsIds.map(id => id.toString());
    candidateComponentsIds.forEach(bitId => {
      const dependents = dependencyGraph.getImmediateDependentsPerId(bitId); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const dependentsNotCandidates = dependents.filter(dependent => !candidateComponentsIdsStr.includes(dependent));

      if (dependentsNotCandidates.length) {
        throw new (_generalError().default)( // $FlowFixMe
        `unable to untag ${bitId}, the version ${version} has the following dependent(s) ${dependents.join(', ')}`);
      }
    });
  }

  _logger().default.debug(`found ${componentsToUntag.length} components to untag`);

  return Promise.all(componentsToUntag.map(component => removeLocalVersion(scope, component.toBitId(), lane, version, true)));
}

async function getComponentsWithOptionToUntag(consumer, version) {
  const componentList = new (_componentsList().default)(consumer);
  const laneObj = await consumer.getCurrentLaneObject();
  const components = await componentList.listExportPendingComponents(laneObj);
  const candidateComponents = components.filter(component => {
    const localVersions = component.getLocalTagsOrHashes();
    if (!localVersions.length) return false;
    return version ? localVersions.includes(version) : true;
  });
  return candidateComponents;
}