"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addFlattenedDependenciesToComponents = addFlattenedDependenciesToComponents;
exports.default = tagModelComponent;
exports.getPublishedPackages = getPublishedPackages;
exports.registerUpdateDependenciesOnTag = registerUpdateDependenciesOnTag;
exports.updateComponentsByTagResult = updateComponentsByTagResult;

function _values2() {
  const data = _interopRequireDefault(require("ramda/src/values"));

  _values2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _ramdaAdjunct() {
  const data = require("ramda-adjunct");

  _ramdaAdjunct = function () {
    return data;
  };

  return data;
}

function _pMap() {
  const data = _interopRequireDefault(require("p-map"));

  _pMap = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = require("uuid");

  _uuid = function () {
    return data;
  };

  return data;
}

function globalConfig() {
  const data = _interopRequireWildcard(require("../../api/consumer/lib/global-config"));

  globalConfig = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _componentSchema() {
  const data = require("../../consumer/component/component-schema");

  _componentSchema = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../../consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _validationError() {
  const data = _interopRequireDefault(require("../../error/validation-error"));

  _validationError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _autoTag() {
  const data = require("./auto-tag");

  _autoTag = function () {
    return data;
  };

  return data;
}

function _getFlattenedDependencies() {
  const data = require("./get-flattened-dependencies");

  _getFlattenedDependencies = function () {
    return data;
  };

  return data;
}

function _semverHelper() {
  const data = require("../../utils/semver-helper");

  _semverHelper = function () {
    return data;
  };

  return data;
}

function _concurrency() {
  const data = require("../../utils/concurrency");

  _concurrency = function () {
    return data;
  };

  return data;
}

function _messagePerComponent() {
  const data = require("./message-per-component");

  _messagePerComponent = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let updateDependenciesOnTag;

function registerUpdateDependenciesOnTag(func) {
  updateDependenciesOnTag = func;
}

function updateDependenciesVersions(componentsToTag) {
  const getNewDependencyVersion = id => {
    const foundDependency = componentsToTag.find(component => component.id.isEqualWithoutVersion(id));
    return foundDependency ? id.changeVersion(foundDependency.version) : null;
  };

  const changeExtensionsVersion = component => {
    component.extensions.forEach(ext => {
      if (ext.extensionId) {
        const newDepId = getNewDependencyVersion(ext.extensionId);
        if (newDepId) ext.extensionId = newDepId;
      }
    });
  };

  componentsToTag.forEach(oneComponentToTag => {
    oneComponentToTag.getAllDependencies().forEach(dependency => {
      const newDepId = getNewDependencyVersion(dependency.id);
      if (newDepId) dependency.id = newDepId;
    });
    changeExtensionsVersion(oneComponentToTag);

    if (updateDependenciesOnTag && typeof updateDependenciesOnTag === 'function') {
      // @ts-ignore
      oneComponentToTag = updateDependenciesOnTag(oneComponentToTag, getNewDependencyVersion.bind(this));
    }
  });
}

function setHashes(componentsToTag) {
  componentsToTag.forEach(componentToTag => {
    componentToTag.version = (0, _utils().sha1)((0, _uuid().v4)());
  });
}

async function setFutureVersions(componentsToTag, scope, releaseType, exactVersion, persist, autoTagIds, ids, incrementBy, preRelease) {
  await Promise.all(componentsToTag.map(async componentToTag => {
    var _componentToTag$compo, _componentToTag$compo2;

    const isAutoTag = autoTagIds.hasWithoutVersion(componentToTag.id);
    const modelComponent = await scope.sources.findOrAddComponent(componentToTag);
    const nextVersion = (_componentToTag$compo = componentToTag.componentMap) === null || _componentToTag$compo === void 0 ? void 0 : (_componentToTag$compo2 = _componentToTag$compo.nextVersion) === null || _componentToTag$compo2 === void 0 ? void 0 : _componentToTag$compo2.version;
    componentToTag.previouslyUsedVersion = componentToTag.version;

    if (nextVersion && persist) {
      var _componentToTag$compo3, _componentToTag$compo4;

      const exactVersionOrReleaseType = (0, _semverHelper().getValidVersionOrReleaseType)(nextVersion);
      componentToTag.version = modelComponent.getVersionToAdd(exactVersionOrReleaseType.releaseType, exactVersionOrReleaseType.exactVersion, undefined, (_componentToTag$compo3 = componentToTag.componentMap) === null || _componentToTag$compo3 === void 0 ? void 0 : (_componentToTag$compo4 = _componentToTag$compo3.nextVersion) === null || _componentToTag$compo4 === void 0 ? void 0 : _componentToTag$compo4.preRelease);
    } else if (isAutoTag) {
      componentToTag.version = modelComponent.getVersionToAdd('patch', undefined, incrementBy, preRelease); // auto-tag always bumped as patch
    } else {
      const enteredId = ids.searchWithoutVersion(componentToTag.id);

      if (enteredId && enteredId.hasVersion()) {
        const exactVersionOrReleaseType = (0, _semverHelper().getValidVersionOrReleaseType)(enteredId.version);
        componentToTag.version = modelComponent.getVersionToAdd(exactVersionOrReleaseType.releaseType, exactVersionOrReleaseType.exactVersion);
      } else {
        componentToTag.version = modelComponent.getVersionToAdd(releaseType, exactVersion, incrementBy, preRelease);
      }
    }
  }));
}
/**
 * make sure the originallySharedDir was added before saving the component. also, make sure it was
 * not added twice.
 * we need three objects for this:
 * 1) component.pendingVersion => version pending to be saved in the filesystem. we want to make sure it has the added sharedDir.
 * 2) component.componentFromModel => previous version of the component. it has the original sharedDir.
 * 3) component.componentMap => current paths in the filesystem, which don't have the sharedDir.
 *
 * The component may be changed from the componentFromModel. The files may be removed and added and
 * new files may added, so we can't compare the files of componentFromModel to component.
 *
 * What we can do is calculating the sharedDir from component.componentFromModel
 * then, make sure that calculatedSharedDir + pathFromComponentMap === component.pendingVersion
 *
 * Also, make sure that the wrapDir has been removed
 */


function validateDirManipulation(components) {
  const throwOnError = (expectedPath, actualPath) => {
    if (expectedPath !== actualPath) {
      throw new (_validationError().default)(`failed validating the component paths with sharedDir, expected path ${expectedPath}, got ${actualPath}`);
    }
  };

  const validateComponent = component => {
    if (!component.componentMap) throw new Error(`componentMap is missing from ${component.id.toString()}`);
    if (!component.componentFromModel) return; // component.componentFromModel.setOriginallySharedDir();

    const sharedDir = component.componentFromModel.originallySharedDir;
    const wrapDir = component.componentFromModel.wrapDir;

    const pathWithSharedDir = pathStr => {
      // $FlowFixMe componentMap is set here
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (sharedDir && component.componentMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED) {
        return (0, _utils().pathJoinLinux)(sharedDir, pathStr);
      }

      return pathStr;
    };

    const pathWithoutWrapDir = pathStr => {
      if (wrapDir) {
        return pathStr.replace(`${wrapDir}/`, '');
      }

      return pathStr;
    };

    const pathAfterDirManipulation = pathStr => {
      const withoutWrapDir = pathWithoutWrapDir(pathStr);
      return pathWithSharedDir(withoutWrapDir);
    };

    const expectedMainFile = pathAfterDirManipulation(component.componentMap.mainFile); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    throwOnError(expectedMainFile, component.pendingVersion.mainFile); // $FlowFixMe componentMap is set here

    const componentMapFiles = component.componentMap.getAllFilesPaths(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const componentFiles = component.pendingVersion.files.map(file => file.relativePath);
    componentMapFiles.forEach(file => {
      const expectedFile = pathAfterDirManipulation(file);

      if (!componentFiles.includes(expectedFile)) {
        throw new (_validationError().default)(`failed validating the component paths, expected a file ${expectedFile} to be in ${componentFiles.toString()} array`);
      }
    });
  };

  components.forEach(component => validateComponent(component));
}

async function tagModelComponent({
  consumerComponents,
  ids,
  scope,
  message,
  editor,
  exactVersion,
  releaseType,
  preRelease,
  force,
  consumer,
  ignoreNewestVersion = false,
  skipTests = false,
  verbose = false,
  skipAutoTag,
  soft,
  build,
  persist,
  resolveUnmerged,
  isSnap = false,
  disableTagAndSnapPipelines,
  forceDeploy,
  incrementBy
}) {
  const consumerComponentsIdsMap = {}; // Concat and unique all the dependencies from all the components so we will not import
  // the same dependency more then once, it's mainly for performance purpose

  consumerComponents.forEach(consumerComponent => {
    const componentIdString = consumerComponent.id.toString(); // Store it in a map so we can take it easily from the sorted array which contain only the id

    consumerComponentsIdsMap[componentIdString] = consumerComponent;
  });
  const componentsToTag = (0, _values2().default)(consumerComponentsIdsMap); // consumerComponents unique

  const idsToTag = _bitId().BitIds.fromArray(componentsToTag.map(c => c.id)); // ids without versions are new. it's impossible that tagged (and not-modified) components has
  // them as dependencies.


  const idsToTriggerAutoTag = idsToTag.filter(id => id.hasVersion());
  const autoTagData = skipAutoTag ? [] : await (0, _autoTag().getAutoTagInfo)(consumer, _bitId().BitIds.fromArray(idsToTriggerAutoTag));
  const autoTagComponents = autoTagData.map(autoTagItem => autoTagItem.component);
  const autoTagComponentsFiltered = autoTagComponents.filter(c => !idsToTag.has(c.id));

  const autoTagIds = _bitId().BitIds.fromArray(autoTagComponentsFiltered.map(autoTag => autoTag.id));

  const allComponentsToTag = [...componentsToTag, ...autoTagComponentsFiltered];
  const messagesFromEditorFetcher = new (_messagePerComponent().MessagePerComponentFetcher)(idsToTag, autoTagIds);
  const messagePerId = editor ? await messagesFromEditorFetcher.getMessagesFromEditor(scope.tmp, editor) : []; // check for each one of the components whether it is using an old version

  if (!ignoreNewestVersion && !isSnap) {
    const newestVersionsP = allComponentsToTag.map(async component => {
      if (component.componentFromModel) {
        // otherwise it's a new component, so this check is irrelevant
        const modelComponent = await scope.getModelComponentIfExist(component.id);
        if (!modelComponent) throw new (_showDoctorError().default)(`component ${component.id} was not found in the model`);
        if (!modelComponent.listVersions().length) return null; // no versions yet, no issues.

        const latest = modelComponent.latest();

        if (latest !== component.version) {
          return {
            componentId: component.id.toStringWithoutVersion(),
            currentVersion: component.version,
            latestVersion: latest
          };
        }
      }

      return null;
    });
    const newestVersions = await Promise.all(newestVersionsP);
    const newestVersionsWithoutEmpty = newestVersions.filter(newest => newest);

    if (!(0, _ramdaAdjunct().isNilOrEmpty)(newestVersionsWithoutEmpty)) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      throw new (_exceptions().NewerVersionFound)(newestVersionsWithoutEmpty);
    }
  }

  let testsResults = [];

  if (consumer.isLegacy) {
    _logger().default.debugAndAddBreadCrumb('tag-model-components', 'sequentially build all components');

    await scope.buildMultiple(allComponentsToTag, consumer, false, verbose);

    _logger().default.debug('scope.putMany: sequentially test all components');

    if (!skipTests) {
      const testsResultsP = scope.testMultiple({
        components: allComponentsToTag,
        consumer,
        verbose,
        rejectOnFailure: !force
      });

      try {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        testsResults = await testsResultsP;
      } catch (err) {
        // if force is true, ignore the tests and continue
        if (!force) {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          if (!verbose) throw new (_exceptions().ComponentSpecsFailed)();
          throw err;
        }
      }
    }
  }

  _logger().default.debugAndAddBreadCrumb('tag-model-components', 'sequentially persist all components'); // go through all components and find the future versions for them


  isSnap ? setHashes(allComponentsToTag) : await setFutureVersions(allComponentsToTag, scope, releaseType, exactVersion, persist, autoTagIds, ids, incrementBy, preRelease);
  setCurrentSchema(allComponentsToTag, consumer); // go through all dependencies and update their versions

  updateDependenciesVersions(allComponentsToTag);
  await addLogToComponents(componentsToTag, autoTagComponents, persist, message, messagePerId);

  if (soft) {
    consumer.updateNextVersionOnBitmap(allComponentsToTag, exactVersion, releaseType, preRelease);
  } else {
    if (!skipTests) addSpecsResultsToComponents(allComponentsToTag, testsResults);
    await addFlattenedDependenciesToComponents(consumer.scope, allComponentsToTag);
    await throwForLegacyDependenciesInsideHarmony(consumer, allComponentsToTag);
    emptyBuilderData(allComponentsToTag);
    addBuildStatus(consumer, allComponentsToTag, _constants().BuildStatus.Pending);
    await addComponentsToScope(consumer, allComponentsToTag, Boolean(resolveUnmerged));
    if (consumer.isLegacy) validateDirManipulation(allComponentsToTag);
    await consumer.updateComponentsVersions(allComponentsToTag);
  }

  const publishedPackages = [];

  if (!consumer.isLegacy && build) {
    const onTagOpts = {
      disableTagAndSnapPipelines,
      throwOnError: true,
      forceDeploy,
      skipTests,
      isSnap
    };
    const results = await (0, _pMapSeries().default)(scope.onTag, func => func(allComponentsToTag, onTagOpts));
    results.forEach(tagResult => updateComponentsByTagResult(allComponentsToTag, tagResult));
    publishedPackages.push(...getPublishedPackages(allComponentsToTag));
    addBuildStatus(consumer, allComponentsToTag, _constants().BuildStatus.Succeed);
    await (0, _pMapSeries().default)(allComponentsToTag, consumerComponent => scope.sources.enrichSource(consumerComponent));
  }

  if (!soft) {
    await scope.objects.persist();
  }

  return {
    taggedComponents: componentsToTag,
    autoTaggedResults: autoTagData,
    publishedPackages
  };
}

async function addComponentsToScope(consumer, components, resolveUnmerged) {
  const lane = await consumer.getCurrentLaneObject();
  await (0, _pMapSeries().default)(components, async component => {
    await consumer.scope.sources.addSource({
      source: component,
      consumer,
      lane,
      resolveUnmerged
    });
  });
}

function emptyBuilderData(components) {
  components.forEach(component => {
    const existingBuilder = component.extensions.findCoreExtension(_constants().Extensions.builder);
    if (existingBuilder) existingBuilder.data = {};
  });
}

async function addFlattenedDependenciesToComponents(scope, components) {
  _loader().default.start('importing missing dependencies...');

  const flattenedDependenciesGetter = new (_getFlattenedDependencies().FlattenedDependenciesGetter)(scope, components);
  await flattenedDependenciesGetter.populateFlattenedDependencies();

  _loader().default.stop();
}

async function throwForLegacyDependenciesInsideHarmony(consumer, components) {
  if (consumer.isLegacy) {
    return;
  }

  const throwForComponent = async component => {
    const dependenciesIds = component.getAllDependenciesIds();
    await Promise.all(dependenciesIds.map(async depId => {
      if (!depId.hasVersion()) return;
      const modelComp = await consumer.scope.getModelComponentIfExist(depId);
      if (!modelComp) return;
      const version = await modelComp.loadVersion(depId.version, consumer.scope.objects);

      if (version.isLegacy) {
        throw new Error(`unable tagging "${component.id.toString()}", its dependency "${depId.toString()}" is legacy`);
      }
    }));
  };

  await (0, _pMap().default)(components, component => throwForComponent(component), {
    concurrency: (0, _concurrency().concurrentComponentsLimit)()
  });
}

function addSpecsResultsToComponents(components, testsResults) {
  components.forEach(component => {
    const testResult = testsResults.find(result => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return component.id.isEqualWithoutScopeAndVersion(result.componentId);
    });
    component.specsResults = testResult ? testResult.specs : undefined;
  });
}

async function addLogToComponents(components, autoTagComps, persist, message, messagePerComponent) {
  const username = await globalConfig().get(_constants().CFG_USER_NAME_KEY);
  const email = await globalConfig().get(_constants().CFG_USER_EMAIL_KEY);

  const getLog = component => {
    var _component$componentM, _messagePerComponent$;

    const nextVersion = persist ? (_component$componentM = component.componentMap) === null || _component$componentM === void 0 ? void 0 : _component$componentM.nextVersion : null;
    const msgFromEditor = (_messagePerComponent$ = messagePerComponent.find(item => item.id.isEqualWithoutVersion(component.id))) === null || _messagePerComponent$ === void 0 ? void 0 : _messagePerComponent$.msg;
    return {
      username: (nextVersion === null || nextVersion === void 0 ? void 0 : nextVersion.username) || username,
      email: (nextVersion === null || nextVersion === void 0 ? void 0 : nextVersion.email) || email,
      message: (nextVersion === null || nextVersion === void 0 ? void 0 : nextVersion.message) || msgFromEditor || message,
      date: Date.now().toString()
    };
  };

  components.forEach(component => {
    component.log = getLog(component);
  });
  autoTagComps.forEach(autoTagComp => {
    autoTagComp.log = getLog(autoTagComp);
    const defaultMsg = 'bump dependencies versions';

    if (message) {
      autoTagComp.log.message += ` (${defaultMsg})`;
    } else if (!autoTagComp.log.message) {
      autoTagComp.log.message = defaultMsg;
    }
  });
}

function setCurrentSchema(components, consumer) {
  if (consumer.isLegacy) return;
  components.forEach(component => {
    component.schema = _componentSchema().CURRENT_SCHEMA;
  });
}
/**
 * @todo: currently, there is only one function registered to the OnTag, which is the builder.
 * we set the extensions data and artifacts we got from the builder to the consumer-components.
 * however, if there is more than one function registered to the OnTag, the data will be overridden
 * by the last called function. when/if this happen, some kind of merge need to be done between the
 * results.
 */


function updateComponentsByTagResult(components, tagResult) {
  tagResult.forEach(result => {
    const matchingComponent = components.find(c => c.id.isEqual(result.id));

    if (matchingComponent) {
      const existingBuilder = matchingComponent.extensions.findCoreExtension(_constants().Extensions.builder);
      if (existingBuilder) existingBuilder.data = result.builderData.data;else matchingComponent.extensions.push(result.builderData);
    }
  });
}

function getPublishedPackages(components) {
  const publishedPackages = components.map(comp => {
    var _builderExt$data, _builderExt$data$aspe, _pkgData$data;

    const builderExt = comp.extensions.findCoreExtension(_constants().Extensions.builder);
    const pkgData = builderExt === null || builderExt === void 0 ? void 0 : (_builderExt$data = builderExt.data) === null || _builderExt$data === void 0 ? void 0 : (_builderExt$data$aspe = _builderExt$data.aspectsData) === null || _builderExt$data$aspe === void 0 ? void 0 : _builderExt$data$aspe.find(a => a.aspectId === _constants().Extensions.pkg);
    return pkgData === null || pkgData === void 0 ? void 0 : (_pkgData$data = pkgData.data) === null || _pkgData$data === void 0 ? void 0 : _pkgData$data.publishedPackage;
  });
  return (0, _ramdaAdjunct().compact)(publishedPackages);
}

function addBuildStatus(consumer, components, buildStatus) {
  if (consumer.isLegacy) return;
  components.forEach(component => {
    component.buildStatus = buildStatus;
  });
}