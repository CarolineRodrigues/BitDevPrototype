/// <reference types="node" />
import * as semver from 'semver';
import { LegacyComponentLog } from '@teambit/legacy-component-log';
import { BitId } from '../../bit-id';
import ConsumerComponent from '../../consumer/component';
import { ManipulateDirItem } from '../../consumer/component-ops/manipulate-dir';
import ComponentObjects from '../component-objects';
import { DivergeData } from '../component-ops/diverge-data';
import ComponentVersion from '../component-version';
import { BitObject, Ref } from '../objects';
import Repository from '../objects/repository';
import { Lane } from '.';
import Version from './version';
import { ObjectItem } from '../objects/object-list';
declare type State = {
    versions?: {
        [version: string]: {
            local?: boolean;
        };
    };
};
declare type Versions = {
    [version: string]: Ref;
};
export declare type ScopeListItem = {
    url: string;
    name: string;
    date: string;
};
export declare type ComponentLog = LegacyComponentLog;
export declare type ComponentProps = {
    scope: string | null | undefined;
    name: string;
    versions?: Versions;
    orphanedVersions?: Versions;
    lang: string;
    deprecated: boolean;
    bindingPrefix: string;
    /**
     * @deprecated since 0.12.6. It's currently stored in 'state' attribute
     */
    local?: boolean;
    state?: State;
    scopesList?: ScopeListItem[];
    head?: Ref;
    schema?: string | undefined;
};
/**
 * we can't rename the class as ModelComponent because old components are already saved in the model
 * with 'Component' in their headers. see object-registrar.types()
 */
export default class Component extends BitObject {
    scope: string | null | undefined;
    name: string;
    versions: Versions;
    orphanedVersions: Versions;
    lang: string;
    /**
     * @deprecated moved to the Version object inside teambit/deprecation aspect
     */
    deprecated: boolean;
    bindingPrefix: string;
    /**
     * @deprecated since 0.12.6 (long long ago :) probably can be removed)
     */
    local: boolean | null | undefined;
    state: State;
    scopesList: ScopeListItem[];
    head?: Ref;
    remoteHead?: Ref | null;
    /**
     * doesn't get saved in the scope, used to easier access the local snap head data
     * when checked out to a lane, this prop is either Ref or null. otherwise (when on main), this
     * prop is undefined.
     */
    laneHeadLocal?: Ref | null;
    laneHeadRemote?: Ref | null;
    schema: string | undefined;
    private divergeData?;
    constructor(props: ComponentProps);
    get versionArray(): Ref[];
    setVersion(tag: string, ref: Ref): void;
    setOrphanedVersion(tag: string, ref: Ref): void;
    getRef(version: string): Ref | null;
    getHeadStr(): string | null;
    getHead(): Ref | undefined;
    /**
     * returns the head hash. regardless of whether current lane is the default or not.
     * if on a lane, it returns the head of the component on the lane.
     */
    getHeadRegardlessOfLane(): Ref | undefined;
    getHeadAsTagIfExist(): string | undefined;
    hasHead(): boolean;
    setHead(head: Ref | undefined): void;
    listVersions(sort?: 'ASC' | 'DESC'): string[];
    listVersionsIncludeOrphaned(sort?: 'ASC' | 'DESC'): string[];
    hasVersion(version: string, repo: Repository, includeOrphaned?: boolean): Promise<boolean>;
    hasTag(version: string): boolean;
    get versionsIncludeOrphaned(): Versions;
    hasTagIncludeOrphaned(version: string): boolean;
    /**
     * whether the head is a snap (not a tag)
     */
    isHeadSnap(): boolean | undefined;
    /**
     * add a new remote if it is not there already
     */
    addScopeListItem(scopeListItem: ScopeListItem): void;
    setDivergeData(repo: Repository, throws?: boolean, fromCache?: boolean): Promise<void>;
    getDivergeData(): DivergeData;
    populateLocalAndRemoteHeads(repo: Repository, lane: Lane | null): Promise<void>;
    setLaneHeadLocal(lane: Lane | null): void;
    /**
     * returns only the versions that exist in both components (regardless whether the hash are the same)
     * e.g. this.component = [0.0.1, 0.0.2, 0.0.3], other component = [0.0.3, 0.0.4]. it returns only [0.0.3].
     * also, in case it is coming from 'bit import', the version must be locally changed.
     * otherwise, it doesn't matter whether the hashes are different.
     */
    _getComparableVersionsObjects(otherComponent: Component, // in case of merging, the otherComponent is the existing component, and "this" is the incoming component
    local: boolean): {
        thisComponentVersions: Versions;
        otherComponentVersions: Versions;
    };
    compatibleWith(component: Component, local: boolean): boolean;
    diffWith(component: Component, local: boolean): string[];
    isEmpty(): boolean;
    latest(): string;
    /**
     * a user can be checked out to a lane, in which case, `this.laneHeadLocal` and `this.laneHeadRemote`
     * may be populated.
     * `this.head` may not be populated, e.g. when a component was created on
     * this lane and never got snapped on main.
     * it's impossible that `this.head.isEqual(this.laneHeadLocal)`, because when snapping it's either
     * on main, which goes to this.head OR on a lane, which goes to this.laneHeadLocal.
     */
    latestIncludeRemote(repo: Repository): Promise<string>;
    latestVersion(): string;
    isLatestGreaterThan(version: string | null | undefined): boolean;
    /**
     * Return the lateset version which actuall exists in the scope
     * (exists means the object itself exists)
     * This relevant for cases when the component version array has few versions
     * but we don't have all the refs in the object
     *
     * @returns {number}
     * @memberof Component
     */
    latestExisting(repository: Repository): string;
    collectLogs(repo: Repository, shortHash?: boolean, startFrom?: Ref): Promise<ComponentLog[]>;
    collectVersions(repo: Repository): Promise<ConsumerComponent[]>;
    getTagOfRefIfExists(ref: Ref, allTags?: Versions): string | undefined;
    switchHashesWithTagsIfExist(refs: Ref[]): string[];
    /**
     * if exactVersion is defined, add exact version instead of using the semver mechanism
     */
    getVersionToAdd(releaseType?: semver.ReleaseType, exactVersion?: string | null, incrementBy?: number, preRelease?: string): string;
    isEqual(component: Component, considerOrphanedVersions?: boolean): boolean;
    getSnapToAdd(): string;
    addVersion(version: Version, versionToAdd: string, lane: Lane | null, repo: Repository): string;
    version(releaseType?: semver.ReleaseType, incrementBy?: number, preRelease?: string): string;
    id(): string;
    toBitId(): BitId;
    toBitIdWithLatestVersion(): BitId;
    toBitIdWithLatestVersionAllowNull(): BitId;
    toObject(): {
        name: string;
        scope: string | null | undefined;
        versions: {};
        lang: string;
        deprecated: boolean;
        bindingPrefix: string;
        remotes: ScopeListItem[];
        schema: string | undefined;
    };
    loadVersion(versionStr: string, repository: Repository, throws?: boolean): Promise<Version>;
    loadVersionSync(version: string, repository: Repository, throws?: boolean): Version;
    collectVersionsObjects(repo: Repository, versions: string[], ignoreMissingArtifacts?: boolean): Promise<ObjectItem[]>;
    collectObjects(repo: Repository): Promise<ComponentObjects>;
    /**
     * to delete a version from a component, don't call this method directly. Instead, use sources.removeVersion()
     */
    removeVersion(version: string): Ref;
    toComponentVersion(versionStr?: string): ComponentVersion;
    isDeprecated(repo: Repository): Promise<any>;
    /**
     * convert a ModelComponent of a specific version to ConsumerComponent
     * when it's being called from the Consumer, some manipulation are done on the component, such
     * as stripping the originallySharedDir and adding wrapDir.
     * when it's being called from the Scope, no manipulations are done.
     *
     * @see sources.consumerComponentToVersion() for the opposite action.
     */
    toConsumerComponent(versionStr: string, scopeName: string, repository: Repository, manipulateDirData?: ManipulateDirItem[] | null): Promise<ConsumerComponent>;
    refs(): Ref[];
    replaceRef(oldRef: Ref, newRef: Ref): void;
    validateBeforePersisting(componentStr: string): void;
    toBuffer(pretty: boolean): Buffer;
    /**
     * Clear data that is relevant only for the local scope and should not be moved to the remote scope
     */
    clearStateData(): void;
    markVersionAsLocal(version: string): void;
    /**
     * local versions that are not exported on the main lane.
     * @see `this.getLocalTagsOrHashes()`, to get local snaps on the current lane
     */
    getLocalVersions(): string[];
    hasLocalTag(tag: string): boolean;
    hasLocalVersion(version: string): boolean;
    getLocalTagsOrHashes(): string[];
    /**
     * for most cases, use `isLocallyChanged`, which takes into account lanes.
     * this is for cases when we only care about the versions exist in the `state` prop.
     */
    isLocallyChangedRegardlessOfLanes(): boolean;
    /**
     * whether the component was locally changed, either by adding a new snap/tag or by merging
     * components from different lanes.
     * if no lanes provided, make sure to run `this.setDivergeData` before calling this method.
     * (it'll throw otherwise).
     */
    isLocallyChanged(lane?: Lane | null, repo?: Repository): Promise<boolean>;
    static parse(contents: string): Component;
    static from(props: ComponentProps): Component;
    static fromBitId(bitId: BitId): Component;
    get isLegacy(): boolean;
    validate(): void;
}
export {};
