"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = require("uuid");

  _uuid = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _validationError() {
  const data = _interopRequireDefault(require("../../error/validation-error"));

  _validationError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = _interopRequireDefault(require("../../lane-id/lane-id"));

  _laneId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _traverseVersions() {
  const data = require("../component-ops/traverse-versions");

  _traverseVersions = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("../objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

class Lane extends _objects().BitObject {
  // @todo: delete this. seems like it being written to the filesystem and it should not
  // scope is only needed to know where a lane came from, it should not be written to the fs
  // reason for the underscore prefix is that we already have hash as a method
  constructor(props) {
    super();
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "remoteLaneId", void 0);
    (0, _defineProperty2().default)(this, "components", void 0);
    (0, _defineProperty2().default)(this, "_hash", void 0);
    if (!props.name) throw new TypeError('Lane constructor expects to get a name parameter');
    this.name = props.name;
    this.scope = props.scope;
    this.components = props.components || [];
    this._hash = props.hash;
  }

  id() {
    return this.name;
  }

  hash() {
    if (!this._hash) {
      throw new Error('hash is missing from a Lane object');
    }

    return new (_objects().Ref)(this._hash);
  }

  refs() {
    return this.components.map(c => c.head);
  }

  validateBeforePersisting(str) {
    _logger().default.debug(`validating lane object: ${this.hash().toString()} ${this.id()}`);

    const lane = Lane.parse(str, this.hash().toString());
    lane.validate();
  }

  toObject() {
    return (0, _utils().filterObject)({
      name: this.name,
      scope: this.scope,
      components: this.components.map(component => ({
        id: {
          scope: component.id.scope,
          name: component.id.name
        },
        head: component.head.toString()
      }))
    }, val => !!val);
  }

  static from(props) {
    return new Lane(props);
  }

  static create(name) {
    return new Lane({
      name,
      hash: (0, _utils().sha1)((0, _uuid().v4)())
    });
  }

  static parse(contents, hash) {
    const laneObject = JSON.parse(contents);
    return Lane.from({
      name: laneObject.name,
      scope: laneObject.scope,
      components: laneObject.components.map(component => ({
        id: new (_bitId().BitId)({
          scope: component.id.scope,
          name: component.id.name
        }),
        head: new (_objects().Ref)(component.head)
      })),
      hash: laneObject.hash || hash
    });
  }

  toBuffer(pretty) {
    const args = (0, _utils().getStringifyArgs)(pretty);
    const obj = this.toObject();
    const str = JSON.stringify(obj, ...args);
    if (this.validateBeforePersist) this.validateBeforePersisting(str);
    return Buffer.from(str);
  }

  addComponent(component) {
    const existsComponent = this.getComponentByName(component.id);

    if (existsComponent) {
      existsComponent.id = component.id;
      existsComponent.head = component.head;
    } else {
      this.components.push(component);
    }
  }

  removeComponent(id) {
    const existsComponent = this.getComponentByName(id);
    if (!existsComponent) return false;
    this.components = this.components.filter(c => !c.id.isEqualWithoutScopeAndVersion(id));
    return true;
  }

  getComponentByName(bitId) {
    return this.components.find(c => c.id.isEqualWithoutScopeAndVersion(bitId));
  }

  getComponent(id) {
    return this.components.find(c => c.id.isEqualWithoutVersion(id));
  }

  getComponentHead(bitId) {
    const found = this.components.find(c => c.id.isEqual(bitId));
    if (found) return found.head;
    return null;
  }

  setLaneComponents(laneComponents) {
    // this gets called when adding lane-components from other lanes/remotes, so it's better to
    // clone the objects to not change the original data.
    this.components = laneComponents.map(c => ({
      id: c.id.clone(),
      head: c.head.clone()
    }));
  }

  async isFullyMerged(scope) {
    const {
      unmerged
    } = await this.getMergedAndUnmergedIds(scope);
    return unmerged.length === 0;
  }

  async getMergedAndUnmergedIds(scope) {
    const merged = [];
    const unmerged = [];
    await Promise.all(this.components.map(async component => {
      const modelComponent = await scope.getModelComponentIfExist(component.id);

      if (!modelComponent) {
        unmerged.push(component.id);
        return;
      }

      const startTraverseFrom = modelComponent.getHead() || null; // it's important to have it as null and not as undefined, see hasVersionByRef

      const headExist = await (0, _traverseVersions().hasVersionByRef)(modelComponent, component.head, scope.objects, startTraverseFrom);
      if (headExist) merged.push(component.id);else unmerged.push(component.id);
    }));
    return {
      merged,
      unmerged
    };
  }

  toBitIds() {
    return this.components.map(c => c.id.changeVersion(c.head.toString()));
  }

  toLaneId() {
    return new (_laneId().default)({
      name: this.name
    });
  }

  collectObjectsById(repo) {
    return Promise.all(this.components.map(async component => {
      const headVersion = await component.head.load(repo);
      const objects = [headVersion, ...headVersion.collect(repo)];
      return {
        id: component.id,
        objects
      };
    }));
  }

  validate() {
    const message = `unable to save Lane object "${this.id()}"`;
    this.components.forEach(component => {
      if (this.components.filter(c => c.id.name === component.id.name).length > 1) {
        throw new (_validationError().default)(`${message}, the following component is duplicated "${component.id.name}"`);
      }
    });

    if (this.name === _constants().DEFAULT_LANE) {
      throw new (_generalError().default)(`${message}, this name is reserved as the default lane`);
    }

    if (this.name === _constants().PREVIOUS_DEFAULT_LANE) {
      throw new (_generalError().default)(`${message}, this name is reserved as the old default lane`);
    }
  }

}

exports.default = Lane;