import BaseExtension from './base-extension';
import { BaseExtensionProps, BaseLoadArgsProps, BaseExtensionOptions } from './base-extension';
declare type RegisteredHooksActions = {};
export declare type Commands = {};
export declare type ExtensionProps = BaseExtensionProps & {
    newHooks?: string[];
    registeredHooksActions?: RegisteredHooksActions;
    commands?: Array<Commands>;
};
export declare type ExtensionOptions = BaseExtensionOptions & {
    core?: boolean;
    disabled?: boolean;
};
export declare type LoadArgsProps = BaseLoadArgsProps;
/**
 * A class which represent an extension
 * The different attributes,
 * Extension API,
 * Load extension
 * Config
 */
export default class Extension extends BaseExtension {
    registeredHooksActions: RegisteredHooksActions;
    newHooks: string[];
    commands: Array<Commands>;
    api: any;
    constructor(extensionProps: ExtensionProps);
    /**
     * Load extension by name
     * The extension will be from scope by default or from file
     * if there is file(path) in the options
     * The file path is relative to the bit.json of the project or absolute
     * @param {string} props - loading properties with the following fields:
     * {string} name - name of the extension
     * {Object} rawConfig - raw config for the extension
     * {Object} options - extension options such as - disabled, file, core
     * {string} consumerPath - path to the consumer folder (to load the file relatively)
     * {string} scopePath - scope which stores the extension code
     */
    static load(props: LoadArgsProps): Promise<Extension>;
    /**
     * Register the hooks on the global hooks manager
     * We don't do this directly on the api in order to be able to register to hooks defined by another extensions
     * So we want to make sure to first load and register all new hooks from all extensions and only then register the actions
     */
    registerHookActionsOnHooksManager(): void;
}
export {};
