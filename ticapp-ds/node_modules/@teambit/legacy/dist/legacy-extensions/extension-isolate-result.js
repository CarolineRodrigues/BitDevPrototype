"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _linkGenerator() {
  const data = require("../links/link-generator");

  _linkGenerator = function () {
    return data;
  };

  return data;
}

/**
 * This is a formal API for extension developers, changes in this API should result a major version.
 */
class ExtensionIsolateResult {
  constructor(isolator, componentWithDependencies) {
    (0, _defineProperty2().default)(this, "isolator", void 0);
    (0, _defineProperty2().default)(this, "capsule", void 0);
    (0, _defineProperty2().default)(this, "componentWithDependencies", void 0);
    this.isolator = isolator;
    this.capsule = isolator.capsule;
    this.componentWithDependencies = componentWithDependencies;
  }

  async capsuleExec(cmd, options) {
    await this.isolator.capsuleExec(cmd, options);
  }

  async writeDists(builtFiles, mainDist) {
    const capsuleComponent = this.componentWithDependencies.component;

    if (!capsuleComponent.dists || capsuleComponent.dists.isEmpty()) {
      if (!builtFiles) {
        return;
      }

      capsuleComponent.setDists(builtFiles.map(file => new (_sources().Dist)(file)), mainDist);
    } // Make sure we are going to write the dists files (also for testers)


    capsuleComponent.dists.writeDistsFiles = true;
    const distsToWrite = await capsuleComponent.dists.getDistsToWrite(capsuleComponent, this.isolator.capsuleBitMap, null, true, this.componentWithDependencies);

    if (distsToWrite) {
      await distsToWrite.persistAllToCapsule(this.capsule);
    }
  }

  async writeLinks() {
    await this.isolator.writeLinks();
  }

  getDependenciesLinks() {
    const links = (0, _linkGenerator().getComponentsDependenciesLinks)([this.componentWithDependencies], null, false, this.isolator.capsuleBitMap);
    return links.files;
  }

  addSharedDir(filesToAdd) {
    const sharedDir = this.componentWithDependencies.component.originallySharedDir;
    let updatedFiles = filesToAdd;

    if (sharedDir) {
      updatedFiles = filesToAdd.map(file => {
        const fileAsAbstractVinyl = _sources().AbstractVinyl.fromVinyl(file);

        fileAsAbstractVinyl.updatePaths({
          newRelative: _path().default.join(sharedDir, file.relative)
        });
        return fileAsAbstractVinyl;
      });
    }

    return updatedFiles;
  }

  async installPackages(packages = []) {
    await this.isolator.installPackagesOnRoot(packages); // after installing packages on capsule root, some links/symlinks from node_modules might
    // be deleted. rewrite the links to recreate them.

    await this.isolator.writeLinksOnNodeModules();
  }

}

exports.default = ExtensionIsolateResult;