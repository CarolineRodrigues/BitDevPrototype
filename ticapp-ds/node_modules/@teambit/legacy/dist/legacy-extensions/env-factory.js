"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
exports.makeEnvFromModel = makeEnvFromModel;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _baseExtension() {
  const data = _interopRequireDefault(require("./base-extension"));

  _baseExtension = function () {
    return data;
  };

  return data;
}

function _compilerExtension() {
  const data = _interopRequireDefault(require("./compiler-extension"));

  _compilerExtension = function () {
    return data;
  };

  return data;
}

function _envExtension() {
  const data = _interopRequireDefault(require("./env-extension"));

  _envExtension = function () {
    return data;
  };

  return data;
}

function _testerExtension() {
  const data = _interopRequireDefault(require("./tester-extension"));

  _testerExtension = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var makeEnv = async function makeEnv(envType, props) {
  _logger().default.trace(`env-factory, create ${envType}`);

  props.envType = envType;
  props.throws = true;
  const envExtensionProps = await _envExtension().default.load(props);
  const extension = getEnvInstance(envType, envExtensionProps);

  if (extension.loaded) {
    const throws = true;
    await extension.init(throws);
  }

  return extension;
};

exports.default = makeEnv;

async function makeEnvFromModel(envType, modelObject) {
  _logger().default.trace(`env-factory, create ${envType} from model`);

  if (!modelObject) return undefined;
  const actualObject = typeof modelObject === 'string' ? _objectSpread({
    envType
  }, _baseExtension().default.transformStringToModelObject(modelObject)) : _objectSpread({
    envType
  }, modelObject);
  const envExtensionProps = await _envExtension().default.loadFromModelObject(actualObject);
  const extension = getEnvInstance(envType, envExtensionProps);
  return extension;
}

function getEnvInstance(envType, envExtensionProps) {
  switch (envType) {
    case _constants().COMPILER_ENV_TYPE:
      return new (_compilerExtension().default)(envExtensionProps);

    case _constants().TESTER_ENV_TYPE:
      return new (_testerExtension().default)(envExtensionProps);

    default:
      throw new Error(`unrecognized env type ${envType}`);
  }
}