import { PathOsBased } from '../utils/path';
import { EnvExtensionOptions } from './env-extension-types';
import { ExtensionOptions } from './extension';
export declare type BaseExtensionOptions = {
    file?: string | null | undefined;
};
declare type BaseArgs = {
    name: string;
    rawConfig: Record<string, any>;
    options: ExtensionOptions | EnvExtensionOptions;
};
export declare type BaseLoadArgsProps = BaseArgs & {
    consumerPath?: PathOsBased | null | undefined;
    scopePath?: PathOsBased | null | undefined;
    context?: Record<string, any> | null | undefined;
    throws?: boolean;
};
declare type BaseLoadFromFileArgsProps = BaseArgs & {
    filePath: string;
    rootDir?: string;
    throws?: boolean;
};
declare type StaticProps = BaseArgs & {
    dynamicConfig: Record<string, any>;
    filePath: string;
    rootDir?: string | null | undefined;
    schema?: Record<string, any> | null | undefined;
    script?: Function;
    disabled: boolean;
    loaded: boolean;
    context?: Record<string, any> | null | undefined;
};
declare type InstanceSpecificProps = {
    api: Record<string, any>;
};
export declare type BaseExtensionProps = InstanceSpecificProps & StaticProps;
export declare type BaseExtensionModel = {
    name: string;
    config: Record<string, any>;
};
export declare type InitOptions = {
    writeConfigFilesOnAction: boolean | null | undefined;
};
export default class BaseExtension {
    name: string;
    loaded: boolean;
    initialized: boolean;
    disabled: boolean;
    filePath: string;
    rootDir: string;
    rawConfig: Record<string, any>;
    schema: Record<string, any> | null | undefined;
    options: Record<string, any>;
    dynamicConfig: Record<string, any>;
    context: Record<string, any> | null | undefined;
    script: Function | null | undefined;
    _initOptions: InitOptions | null | undefined;
    api: any;
    constructor(extensionProps: BaseExtensionProps);
    get writeConfigFilesOnAction(): any;
    get initOptions(): Record<string, any> | null | undefined;
    set initOptions(opts: Record<string, any> | null | undefined);
    /**
     * Run the extension's init function
     */
    init(throws?: boolean): Promise<boolean>;
    extendAPI(baseApi: Record<string, any>, api: Record<string, any>): void;
    toString(): string;
    toBitJsonObject(): {
        [x: string]: {
            rawConfig: Record<string, any>;
            options: Record<string, any>;
        };
    };
    toModelObject(): {
        name: string;
        config: Record<string, any>;
    };
    toObject(): Record<string, any>;
    /**
     * Reload the extension, this mainly contain the process of going to the extension file requiring it and get the dynamic config
     * It mostly used for env extension when sometime on the first load the env didn't installed yet (only during build / test) phase
     */
    reload(scopePath: string, { throws }: Record<string, any>): Promise<void>;
    setExtensionPathInScope(scopePath: string): void;
    static transformStringToModelObject(name: string): BaseExtensionModel;
    /**
     * Load extension by name
     * The extension will be from scope by default or from file
     * if there is file(path) in the options
     * The file path is relative to the bit.json of the project or absolute
     * @param {string} name - name of the extension
     * @param {Object} rawConfig - raw config for the extension
     * @param {Object} options - extension options such as - disabled, file, core
     * @param {string} consumerPath - path to the consumer folder (to load the file relatively)
     * @param {string} scopePath - scope which stores the extension code
     */
    static load({ name, rawConfig, options, consumerPath, scopePath, throws, context, }: BaseLoadArgsProps): Promise<BaseExtensionProps | BaseExtension>;
    static loadFromModelObjectBase(modelObject: string | BaseExtensionModel): BaseExtensionProps;
    static loadFromFile({ name, filePath, rootDir, rawConfig, options, throws, }: BaseLoadFromFileArgsProps): Promise<StaticProps>;
    static loadDynamicConfig(extensionProps: StaticProps): Record<string, any> | null | undefined;
}
export {};
