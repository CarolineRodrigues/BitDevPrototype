"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadExtensions;

function _mapObjIndexed2() {
  const data = _interopRequireDefault(require("ramda/src/mapObjIndexed"));

  _mapObjIndexed2 = function () {
    return data;
  };

  return data;
}

function _values2() {
  const data = _interopRequireDefault(require("ramda/src/values"));

  _values2 = function () {
    return data;
  };

  return data;
}

function _mergeDeepLeft2() {
  const data = _interopRequireDefault(require("ramda/src/mergeDeepLeft"));

  _mergeDeepLeft2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _extension() {
  const data = _interopRequireDefault(require("./extension"));

  _extension = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Load the global bit.json file (in order to get the global extensions)
 * @param {boolean} throws - whether to throw an error if the file corrupted
 */
const _getGlobalBitJson = async throws => {
  const globalBitJsonPath = path().join(_constants().GLOBAL_CONFIG, _constants().BIT_JSON);
  const exists = await _fsExtra().default.pathExists(globalBitJsonPath);
  if (!exists) return null;
  return _fsExtra().default.readJson(globalBitJsonPath, {
    throws
  }) // Implementing the catch my self since the throws: false not really working
  .catch(e => {
    if (throws) {
      throw e;
    }

    _logger().default.debug('error during loading global bit.json', e);

    return null;
  });
};
/**
 * Load specific extension
 * @param {string} consumerPath
 * @param {string} scopePath
 */


const _loadExtension = (consumerPath, scopePath) => (rawConfig = {}, name) => {
  const loadArgs = {
    name,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    rawConfig: rawConfig.config,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    options: rawConfig.options,
    consumerPath,
    scopePath
  };
  return _extension().default.load(loadArgs);
};
/**
 * Load all extensions
 * Regular, core, globals
 */


async function loadExtensions() {
  try {
    _logger().default.debug('legacy-extensions.extensions-loader, start loading extensions');

    const getConsumer = async () => {
      try {
        const consumer = await (0, _consumer().loadConsumer)();
        return consumer;
      } catch (err) {
        return null;
      }
    };

    const consumer = await getConsumer();
    let consumerPath = null;
    let scopePath = null;
    let rawExtensions = {};

    if (consumer) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      consumerPath = consumer.getPath(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      scopePath = consumer.scope.path;
    } // Load global extensions


    const globalBitJson = await _getGlobalBitJson(false);
    const globalRawExtensions = globalBitJson && globalBitJson.extensions; // Merge the global with the local extensions only if exists
    // The local extension is higher priority than the global ones since they are closer to the user
    // This mechanism is for internal use by bitsrc server and should not be used by the users

    if (globalRawExtensions) {
      rawExtensions = (0, _mergeDeepLeft2().default)(rawExtensions, globalRawExtensions);
    }

    const extensions = (0, _values2().default)((0, _mapObjIndexed2().default)(_loadExtension(consumerPath, scopePath), rawExtensions));
    return await Promise.all(extensions);
  } catch (err) {
    _logger().default.error('loading extensions failed', err);

    return [];
  }
}