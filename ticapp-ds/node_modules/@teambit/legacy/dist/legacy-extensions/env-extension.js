"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));

  _path2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = _interopRequireDefault(require("../bit-id/bit-id"));

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _abstractConfig() {
  const data = _interopRequireDefault(require("../consumer/config/abstract-config"));

  _abstractConfig = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _installExtensions() {
  const data = _interopRequireDefault(require("../scope/extensions/install-extensions"));

  _installExtensions = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _baseExtension() {
  const data = _interopRequireDefault(require("./base-extension"));

  _baseExtension = function () {
    return data;
  };

  return data;
}

function _envFactory() {
  const data = _interopRequireDefault(require("./env-factory"));

  _envFactory = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicConfigError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-config-error"));

  _extensionGetDynamicConfigError = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicPackagesError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-packages-error"));

  _extensionGetDynamicPackagesError = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

class EnvExtension extends _baseExtension().default {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  /**
   * Return the action
   */
  get action() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.script && this.script.action && typeof this.script.action === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.action;
    }

    return undefined;
  }
  /**
   * return old actions (to support old compilers / testers which uses run / compile functions)
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get oldAction() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.script && this.script.run && typeof this.script.run === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.run;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (this.script && this.script.compile && typeof this.script.compile === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.compile;
    }

    return undefined;
  }

  constructor(extensionProps) {
    super(extensionProps);
    (0, _defineProperty2().default)(this, "envType", void 0);
    (0, _defineProperty2().default)(this, "dynamicPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    this.envType = extensionProps.envType;
    this.dynamicPackageDependencies = extensionProps.dynamicPackageDependencies;
  }

  async install(scope, opts, context) {
    _logger().default.debugAndAddBreadCrumb('env-extension', 'install env extension'); // Skip the installation in case of using specific file
    // options.file usually used for develop your extension
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (this.options.file) {
      return undefined;
    }

    const dependentId = (0, _path2().default)(['dependentId'], context);

    const installOpts = _objectSpread({
      ids: [{
        componentId: _bitId().default.parse(this.name, true),
        type: this.envType.toLowerCase()
      }],
      // @todo: make sure it always has a scope name
      dependentId,
      scope
    }, opts); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    const installResult = await (0, _installExtensions().default)(installOpts);
    this.setExtensionPathInScope(scope.getPath());
    await this.reload(scope.getPath(), context);
    return installResult;
  }

  toModelObject() {
    const baseObject = super.toModelObject();

    const modelObject = _objectSpread({}, baseObject);

    return modelObject;
  }

  toObject() {
    const baseObject = super.toObject();

    const object = _objectSpread({}, baseObject);

    return object;
  }
  /**
   * Get a bit.json representation of the env instance
   * @param {string} ejectedEnvDirectory - The base path of where the env config files are stored
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  toBitJsonObject() {
    _logger().default.trace('env-extension, toBitJsonObject');

    const envVal = {
      rawConfig: this.dynamicConfig,
      options: this.options
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return {
      [this.name]: envVal
    };
  }

  async reload(scopePath, context) {
    _logger().default.trace('env-extension, reload');

    if (context) {
      this.context = context;
    }

    const throws = true;
    await super.reload(scopePath, {
      throws
    }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const dynamicPackageDependencies = EnvExtension.loadDynamicPackageDependencies(this);
    this.dynamicPackageDependencies = dynamicPackageDependencies;
  }
  /**
   * Loading from props (usually from bit.json)
   * @param {*} props
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */


  static async load(props) {
    const baseExtensionProps = await super.load(props);

    const envExtensionProps = _objectSpread({
      envType: props.envType
    }, baseExtensionProps);

    const dynamicPackageDependencies = EnvExtension.loadDynamicPackageDependencies(envExtensionProps);
    envExtensionProps.dynamicPackageDependencies = dynamicPackageDependencies;
    const dynamicConfig = EnvExtension.loadDynamicConfig(envExtensionProps); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    envExtensionProps.dynamicConfig = dynamicConfig;
    return envExtensionProps;
  }

  static loadDynamicPackageDependencies(envExtensionProps) {
    const getDynamicPackageDependencies = (0, _path2().default)(['script', 'getDynamicPackageDependencies'], envExtensionProps);

    if (!getDynamicPackageDependencies || typeof getDynamicPackageDependencies !== 'function') {
      return undefined;
    }

    let dynamicPackageDependencies;

    try {
      dynamicPackageDependencies = getDynamicPackageDependencies({
        rawConfig: envExtensionProps.rawConfig,
        dynamicConfig: envExtensionProps.dynamicConfig,
        context: envExtensionProps.context
      });
    } catch (err) {
      throw new (_extensionGetDynamicPackagesError().default)(err, envExtensionProps.name);
    }

    if (!dynamicPackageDependencies) return undefined;

    if (typeof dynamicPackageDependencies !== 'object') {
      throw new (_generalError().default)('expect getDynamicPackageDependencies to return an object');
    } // old format returned an object of the packages, without any separation between
    // dependencies, devDependencies and peerDependencies


    const usesOldFormat = Object.keys(dynamicPackageDependencies).some(field => !_constants().DEPENDENCIES_FIELDS.includes(field));

    if (usesOldFormat) {
      throw new (_generalError().default)(`getDynamicPackageDependencies expects to return the following keys only: [${_constants().DEPENDENCIES_FIELDS.join(', ')}]`);
    }

    return dynamicPackageDependencies;
  }

  static loadDynamicConfig(envExtensionProps) {
    const getDynamicConfig = (0, _path2().default)(['script', 'getDynamicConfig'], envExtensionProps);

    if (getDynamicConfig && typeof getDynamicConfig === 'function') {
      try {
        const dynamicConfig = getDynamicConfig({
          rawConfig: envExtensionProps.rawConfig,
          context: envExtensionProps.context
        });
        return dynamicConfig;
      } catch (err) {
        throw new (_extensionGetDynamicConfigError().default)(err, envExtensionProps.name);
      }
    }

    return undefined;
  }

  static async loadFromModelObject(modelObject) {
    const baseExtensionProps = super.loadFromModelObjectBase(modelObject);

    const envExtensionProps = _objectSpread({
      envType: modelObject.envType
    }, baseExtensionProps);

    return envExtensionProps;
  }

  static async loadFromSerializedModelObject(modelObject) {
    _logger().default.trace('env-extension, loadFromModelObject');

    const baseExtensionProps = super.loadFromModelObjectBase(modelObject);

    const envExtensionProps = _objectSpread({
      envType: modelObject.envType
    }, baseExtensionProps);

    return envExtensionProps;
  }
  /**
   * load the compiler/tester according to the following strategies:
   * 1. from component config (bit.json/package.json of the component) if it was written.
   * 2. from component model. an imported component might not have the config written.
   * for author, it's irrelevant, because upon import it's written to consumer config (if changed).
   * 3. from consumer config overrides. (bit.json/package.json of the consumer when this component
   * overrides the general env config).
   * 4. from consumer config.
   */


  static async loadFromCorrectSource({
    consumerPath,
    scopePath,
    componentOrigin,
    componentFromModel,
    componentConfig,
    overrides,
    workspaceConfig,
    envType,
    context
  }) {
    _logger().default.trace(`env-extension (${envType}) loadFromCorrectSource`);

    const isAuthor = componentOrigin === _constants().COMPONENT_ORIGINS.AUTHORED;

    const componentHasWrittenConfig = componentConfig && componentConfig.componentHasWrittenConfig; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (componentHasWrittenConfig && componentConfig[envType]) {
      // load from component config.
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (Object.keys(componentConfig[envType])[0] === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
        _logger().default.debug(`env-extension, ${envType} was manually removed from the component config`);

        return null;
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const envConfig = {
        [envType]: componentConfig[envType]
      }; // $FlowFixMe we made sure before that componentConfig is defined
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const configPath = path().dirname(componentConfig.path);

      _logger().default.trace(`env-extension loading ${envType} from component config`);

      return loadFromConfig({
        envConfig,
        envType,
        consumerPath,
        scopePath,
        configPath,
        context
      });
    }

    if (isAuthor && componentConfig && componentConfig[envType]) {
      // load from component config.
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (Object.keys(componentConfig[envType])[0] === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
        _logger().default.debug(`env-extension, ${envType} was manually removed from the component config`);

        return null;
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const envConfig = {
        [envType]: componentConfig[envType]
      };

      _logger().default.trace(`env-extension loading ${envType} from component config in workspace config`);

      return loadFromConfig({
        envConfig,
        envType,
        consumerPath,
        scopePath,
        configPath: consumerPath,
        context
      });
    }

    if (!componentHasWrittenConfig && !isAuthor && componentFromModel && componentFromModel[envType]) {
      // config was not written into component dir, load the config from the model
      _logger().default.trace(`env-extension, loading ${envType} from the model`);

      return componentFromModel[envType];
    }

    const envFromOverride = overrides.getEnvByType(envType);

    if (envFromOverride) {
      if (envFromOverride === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
        _logger().default.debug(`env-extension, ${envType} was manually removed from the overrides`);

        return null;
      }

      _logger().default.trace(`env-extension, loading ${envType} from the overrides`);

      const envConfig = {
        [envType]: _abstractConfig().default.transformEnvToObject(envFromOverride)
      };
      return loadFromConfig({
        envConfig,
        envType,
        consumerPath,
        scopePath,
        configPath: consumerPath,
        context
      });
    }

    if (isAuthor && workspaceConfig[`_${envType}`]) {
      _logger().default.trace(`env-extension, loading ${envType} from the consumer config`);

      const envConfig = {
        [envType]: workspaceConfig[`_${envType}`]
      };
      return loadFromConfig({
        envConfig,
        envType,
        consumerPath,
        scopePath,
        configPath: consumerPath,
        context
      });
    }

    return null;
  }
  /**
   * are two envs (in the model/scope format) different
   */


  static areEnvsDifferent(envModelA, envModelB) {
    const sortEnv = env => {
      env.config = (0, _utils().sortObject)(env.config);
      const result = (0, _utils().sortObject)(env);
      return result;
    };

    const stringifyEnv = env => {
      if (!env) {
        return '';
      }

      if (typeof env === 'string') {
        return env;
      }

      return JSON.stringify(sortEnv(env));
    };

    const envModelAString = stringifyEnv(envModelA);
    const envModelBString = stringifyEnv(envModelB); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return (0, _utils().sha1)(envModelAString) !== (0, _utils().sha1)(envModelBString);
  }

}

exports.default = EnvExtension;

async function loadFromConfig({
  envConfig,
  envType,
  consumerPath,
  scopePath,
  configPath,
  context
}) {
  const env = envConfig[envType];
  if (!env) return null;
  const envName = Object.keys(env)[0];
  const envObject = env[envName];
  const envProps = {
    name: envName,
    consumerPath,
    scopePath,
    rawConfig: envObject.rawConfig,
    files: envObject.files,
    bitJsonPath: configPath,
    options: envObject.options,
    envType,
    context
  };
  return (0, _envFactory().default)(envType, envProps);
}