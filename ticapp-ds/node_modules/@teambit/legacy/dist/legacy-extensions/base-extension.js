"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));

  _clone2 = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));

  _path2 = function () {
    return data;
  };

  return data;
}

function _merge2() {
  const data = _interopRequireDefault(require("ramda/src/merge"));

  _merge2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ajv() {
  const data = _interopRequireDefault(require("ajv"));

  _ajv = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _environment() {
  const data = _interopRequireDefault(require("../environment"));

  _environment = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireWildcard(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicConfigError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-config-error"));

  _extensionGetDynamicConfigError = function () {
    return data;
  };

  return data;
}

function _extensionLoadError() {
  const data = _interopRequireDefault(require("./exceptions/extension-load-error"));

  _extensionLoadError = function () {
    return data;
  };

  return data;
}

function _extensionNameNotValid() {
  const data = _interopRequireDefault(require("./exceptions/extension-name-not-valid"));

  _extensionNameNotValid = function () {
    return data;
  };

  return data;
}

function _extensionSchemaError() {
  const data = _interopRequireDefault(require("./exceptions/extension-schema-error"));

  _extensionSchemaError = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const ajv = new (_ajv().default)();
const CORE_EXTENSIONS_PATH = './core-extensions';

// export type BaseExtensionProps = {
//   ...InstanceSpecificProps,
//   ...StaticProps
// };
// type staticProps = $Diff<BaseExtensionProps, instanceSpecificProps>
class BaseExtension {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // Store the required plugin
  // Store the required plugin
  // @ts-ignore this code is obsolete, no point of fixing the types
  constructor(extensionProps) {
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "loaded", void 0);
    (0, _defineProperty2().default)(this, "initialized", void 0);
    (0, _defineProperty2().default)(this, "disabled", void 0);
    (0, _defineProperty2().default)(this, "filePath", void 0);
    (0, _defineProperty2().default)(this, "rootDir", void 0);
    (0, _defineProperty2().default)(this, "rawConfig", void 0);
    (0, _defineProperty2().default)(this, "schema", void 0);
    (0, _defineProperty2().default)(this, "options", void 0);
    (0, _defineProperty2().default)(this, "dynamicConfig", void 0);
    (0, _defineProperty2().default)(this, "context", void 0);
    (0, _defineProperty2().default)(this, "script", void 0);
    (0, _defineProperty2().default)(this, "_initOptions", void 0);
    (0, _defineProperty2().default)(this, "api", _getConcreteBaseAPI({
      name: this.name
    }));
    this.name = extensionProps.name;
    this.rawConfig = extensionProps.rawConfig;
    this.schema = extensionProps.schema;
    this.options = extensionProps.options;
    this.dynamicConfig = extensionProps.dynamicConfig || extensionProps.rawConfig;
    this.context = extensionProps.context;
    this.script = extensionProps.script;
    this.disabled = extensionProps.disabled;
    this.filePath = extensionProps.filePath;
    this.rootDir = extensionProps.rootDir || '';
    this.loaded = extensionProps.loaded;
    this.api = extensionProps.api;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get writeConfigFilesOnAction() {
    if (!this.initOptions) {
      return false;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return this.initOptions.writeConfigFilesOnAction;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get initOptions() {
    return this._initOptions;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  set initOptions(opts) {
    const defaultInitOpts = {
      writeConfigFilesOnAction: false
    };

    if (!opts) {
      this._initOptions = defaultInitOpts;
      return;
    }

    const res = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (opts.write) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      res.writeConfigFilesOnAction = true;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    this._initOptions = res;
  }
  /**
   * Run the extension's init function
   */


  async init(throws = false) {
    _analytics().Analytics.addBreadCrumb('base-extension', 'initialize extension');

    try {
      let initOptions = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (this.script && this.script.init && typeof this.script.init === 'function') {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        initOptions = this.script.init({
          rawConfig: this.rawConfig,
          dynamicConfig: this.dynamicConfig,
          api: this.api
        });
      } // wrap in promise, in case a script has async init


      this.initOptions = await Promise.resolve(initOptions);
      this.initialized = true; // Make sure to not kill the process if an extension didn't load correctly
    } catch (err) {
      _logger().default.error(`initialized extension ${this.name} failed`, err);

      if (throws) {
        throw new (_extensionLoadError().default)(err, this.name);
      }

      this.initialized = false;
      return false;
    }

    return true;
  }

  extendAPI(baseApi, api) {
    this.api = (0, _merge2().default)(baseApi, api);
  }

  toString() {
    return JSON.stringify(this, null, 2);
  }

  toBitJsonObject() {
    return {
      [this.name]: {
        rawConfig: this.rawConfig,
        options: this.options
      }
    };
  }

  toModelObject() {
    return {
      name: this.name,
      config: this.dynamicConfig
    };
  }

  toObject() {
    return this.toModelObject();
  }
  /**
   * Reload the extension, this mainly contain the process of going to the extension file requiring it and get the dynamic config
   * It mostly used for env extension when sometime on the first load the env didn't installed yet (only during build / test) phase
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  async reload(scopePath, {
    throws
  }) {
    _analytics().Analytics.addBreadCrumb('base-extension', 'reload extension'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (!this.filePath && !this.options.core) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const {
        resolvedPath,
        componentPath
      } = _getExtensionPath(this.name, scopePath, this.options.core);

      this.filePath = resolvedPath;
      this.rootDir = componentPath;
    }

    this.name = _addVersionToNameFromPathIfMissing(this.name, this.rootDir, this.options);
    const baseProps = await BaseExtension.loadFromFile({
      name: this.name,
      filePath: this.filePath,
      rootDir: this.rootDir,
      rawConfig: this.rawConfig,
      options: this.options,
      throws
    });

    if (baseProps.loaded) {
      this.loaded = baseProps.loaded;
      this.script = baseProps.script;
      this.dynamicConfig = baseProps.dynamicConfig;
      await this.init();
    }
  }

  setExtensionPathInScope(scopePath) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const {
      resolvedPath,
      componentPath
    } = _getExtensionPath(this.name, scopePath, this.options.core);

    this.filePath = resolvedPath;
    this.rootDir = componentPath;
  }

  static transformStringToModelObject(name) {
    return {
      name,
      config: {}
    };
  }
  /**
   * Load extension by name
   * The extension will be from scope by default or from file
   * if there is file(path) in the options
   * The file path is relative to the bit.json of the project or absolute
   * @param {string} name - name of the extension
   * @param {Object} rawConfig - raw config for the extension
   * @param {Object} options - extension options such as - disabled, file, core
   * @param {string} consumerPath - path to the consumer folder (to load the file relatively)
   * @param {string} scopePath - scope which stores the extension code
   */


  static async load({
    name,
    rawConfig = {},
    options = {},
    consumerPath,
    scopePath,
    throws = false,
    context
  }) {
    _logger().default.debug(`base-extension loading ${name}`);

    const concreteBaseAPI = _getConcreteBaseAPI({
      name
    });

    if (options.file) {
      let absPath = options.file;
      const file = options.file || '';

      if (!path().isAbsolute(options.file) && consumerPath) {
        absPath = path().resolve(consumerPath, file);
      }

      const staticExtensionProps = await BaseExtension.loadFromFile({
        name,
        filePath: absPath,
        rawConfig,
        options,
        throws
      });

      const extensionProps = _objectSpread({
        api: concreteBaseAPI,
        context
      }, staticExtensionProps);

      extensionProps.api = concreteBaseAPI;
      return extensionProps;
    }

    let staticExtensionProps = {
      name,
      rawConfig,
      dynamicConfig: rawConfig,
      options,
      disabled: false,
      loaded: false,
      filePath: ''
    }; // Require extension from scope

    if (scopePath) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const {
        resolvedPath,
        componentPath
      } = _getExtensionPath(name, scopePath, options.core);

      const nameWithVersion = _addVersionToNameFromPathIfMissing(name, componentPath, options);

      staticExtensionProps = await BaseExtension.loadFromFile({
        name: nameWithVersion,
        filePath: resolvedPath,
        rootDir: componentPath,
        rawConfig,
        options,
        throws
      });
    }

    const extensionProps = _objectSpread({
      api: concreteBaseAPI,
      context
    }, staticExtensionProps);

    return extensionProps;
  }

  static loadFromModelObjectBase(modelObject) {
    let staticExtensionProps;

    if (typeof modelObject === 'string') {
      staticExtensionProps = {
        name: modelObject,
        rawConfig: {},
        dynamicConfig: {},
        options: {},
        disabled: false,
        loaded: false,
        filePath: ''
      };
    } else {
      staticExtensionProps = {
        name: modelObject.name,
        rawConfig: modelObject.config,
        dynamicConfig: modelObject.config,
        options: {},
        disabled: false,
        loaded: false,
        filePath: ''
      };
    }

    const concreteBaseAPI = _getConcreteBaseAPI({
      name: staticExtensionProps.name
    });

    const extensionProps = _objectSpread({
      api: concreteBaseAPI
    }, staticExtensionProps);

    return extensionProps;
  }

  static async loadFromFile({
    name,
    filePath,
    rootDir,
    rawConfig = {},
    options = {},
    throws = false
  }) {
    _logger().default.debug(`base-extension, loading extension ${name} from ${filePath}`);

    const extensionProps = {
      name,
      rawConfig,
      dynamicConfig: rawConfig,
      options,
      disabled: false,
      loaded: false,
      filePath: '',
      rootDir: ''
    }; // Skip disabled extensions
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (options.disabled) {
      extensionProps.disabled = true;

      _logger().default.info(`skip extension ${extensionProps.name} because it is disabled`);

      extensionProps.loaded = false;
      return extensionProps;
    }

    extensionProps.filePath = filePath;
    extensionProps.rootDir = rootDir;
    const isFileExist = await _fsExtra().default.pathExists(filePath);

    if (!isFileExist) {
      // Do not throw an error if the file not exist since we will install it later
      // unless you specify the options.file which means you want a specific file which won't be installed automatically later
      if (throws && options.file) {
        const err = new Error(`the file ${filePath} not found`);
        throw new (_extensionLoadError().default)(err, extensionProps.name);
      }

      extensionProps.loaded = false;
      return extensionProps;
    }

    if (rootDir && !_environment().default.isEnvironmentInstalled(rootDir)) {
      extensionProps.loaded = false;
      return extensionProps;
    }

    try {
      const script = require(filePath); // eslint-disable-line


      extensionProps.script = script.default ? script.default : script; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (extensionProps.script.getSchema && typeof extensionProps.script.getSchema === 'function') {
        // the function may or may not be a promise
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        extensionProps.schema = await Promise.resolve(extensionProps.script.getSchema()); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        const valid = ajv.validate(extensionProps.schema, rawConfig);

        if (!valid) {
          throw new (_extensionSchemaError().default)(name, ajv.errorsText());
        }
      } // Make sure to not kill the process if an extension didn't load correctly

    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        const msg = `loading extension ${extensionProps.name} failed, the file ${extensionProps.filePath} not found`;

        _logger().default.warn(msg); // console.error(msg); // eslint-disable-line no-console

      }

      _logger().default.error(`loading extension ${extensionProps.name} failed`, err);

      extensionProps.loaded = false;

      if (throws) {
        let printStack = true;

        if (err instanceof _extensionSchemaError().default) {
          printStack = false;
        }

        throw new (_extensionLoadError().default)(err, extensionProps.name, printStack);
      }

      return extensionProps;
    }

    extensionProps.loaded = true;
    return extensionProps;
  }

  static loadDynamicConfig(extensionProps) {
    _logger().default.debug('base-extension - loadDynamicConfig');

    const getDynamicConfig = (0, _path2().default)(['script', 'getDynamicConfig'], extensionProps);

    if (getDynamicConfig && typeof getDynamicConfig === 'function') {
      try {
        const dynamicConfig = getDynamicConfig({
          rawConfig: extensionProps.rawConfig
        });
        return dynamicConfig;
      } catch (err) {
        throw new (_extensionGetDynamicConfigError().default)(err, extensionProps.name);
      }
    }

    return undefined;
  }

}

exports.default = BaseExtension;

function _getExtensionPath(name, scopePath, isCore = false) {
  if (isCore) {
    return _getCoreExtensionPath(name);
  }

  if (!scopePath) {
    throw new Error('base-extension._getExtensionPath expects to get scopePath');
  }

  return _getRegularExtensionPath(name, scopePath);
}

function _getCoreExtensionPath(name) {
  const componentPath = path().join(__dirname, CORE_EXTENSIONS_PATH, name);
  return {
    resolvedPath: componentPath,
    componentPath
  };
}

function _getRegularExtensionPath(name, scopePath) {
  let bitId;

  try {
    bitId = _bitId().BitId.parse(name, true); // todo: make sure it always has a scope
  } catch (err) {
    throw new (_extensionNameNotValid().default)(name);
  }

  if (!bitId || !bitId.scope) throw new (_extensionNameNotValid().default)(name);

  const internalComponentsPath = _scope().Scope.getComponentsRelativePath();

  const internalComponentPath = _scope().Scope.getComponentRelativePath(bitId, scopePath);

  const componentPath = path().join(scopePath, internalComponentsPath, internalComponentPath);

  try {
    // This might throw an error in case of imported component when the env
    // isn't installed yet
    // It will be handled in higher functions
    const resolved = require.resolve(componentPath);

    return {
      resolvedPath: typeof resolved === 'string' ? resolved : componentPath,
      componentPath
    };
  } catch (e) {
    return {
      resolvedPath: componentPath,
      componentPath
    };
  }
}

function _getExtensionVersionFromComponentPath(componentPath) {
  const parsed = path().parse(componentPath);
  const version = parsed.base;

  if (!_semver().default.valid(version)) {
    return undefined;
  }

  return version;
}

function _addVersionToNameFromPathIfMissing(name, componentPath, options) {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  if (options && options.core) return name; // if it's a core extension, it's not a bit-id.

  let bitId;

  try {
    bitId = _bitId().BitId.parse(name, true); // @todo: make sure it always has a scope name
  } catch (err) {
    throw new (_extensionNameNotValid().default)(name);
  }

  if (bitId.getVersion().latest) {
    const version = _getExtensionVersionFromComponentPath(componentPath);

    return bitId.changeVersion(version).toString();
  }

  return name;
}

const baseApi = {
  /**
   * API to get logger
   */
  getLogger: name => () => (0, _logger().createExtensionLogger)(name)
};
/**
 * Function which get actual params and return a concrete base api
 */

function _getConcreteBaseAPI({
  name
}) {
  const concreteBaseAPI = (0, _clone2().default)(baseApi);
  concreteBaseAPI.getLogger = baseApi.getLogger(name);
  return concreteBaseAPI;
}