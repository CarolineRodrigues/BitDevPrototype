"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

/**
 * each lane holds hashes per component-id. this hash is the checked out version of the current user.
 * the data is not synced by git and available only to the current user.
 * once a lane is exported, the hash replaces the version on .bitmap and then it gets synched
 */
class WorkspaceLane {
  constructor(lanePath, laneName, ids) {
    (0, _defineProperty2().default)(this, "lanePath", void 0);
    (0, _defineProperty2().default)(this, "laneName", void 0);
    (0, _defineProperty2().default)(this, "ids", void 0);
    this.lanePath = lanePath;
    this.laneName = laneName;
    this.ids = ids;
  }

  addEntry(componentId, replaceIgnoreVersion = true) {
    if (!componentId.version) return; // do nothing

    const existing = this.ids.search(componentId);
    if (existing) return;
    const existingDiffVersion = this.ids.searchWithoutVersion(componentId);

    if (existingDiffVersion && replaceIgnoreVersion) {
      this.ids = this.ids.removeIfExistWithoutVersion(existingDiffVersion);
    }

    this.ids.push(componentId);
  }

  removeEntry(componentId) {
    this.ids = this.ids.removeIfExist(componentId);
  }

  reset() {
    this.ids = new (_bitId().BitIds)();
  }

  getIds() {
    return this.ids;
  }

  static load(laneName, scopePath) {
    const lanePath = _path().default.join(scopePath, _constants().WORKSPACE_LANES_DIR, laneName);

    const loadIds = () => {
      try {
        const laneFile = _fsExtra().default.readJsonSync(lanePath);

        return _bitId().BitIds.fromArray(laneFile.map(id => new (_bitId().BitId)(id)));
      } catch (err) {
        if (err.code === 'ENOENT') {
          return new (_bitId().BitIds)();
        }

        throw err;
      }
    };

    const ids = loadIds();
    return new WorkspaceLane(lanePath, laneName, ids);
  }

  async write() {
    const obj = this.ids.map(id => ({
      scope: id.scope,
      name: id.name,
      version: id.version
    }));
    return _fsExtra().default.outputFile(this.lanePath, JSON.stringify(obj, null, 2));
  }

}

exports.default = WorkspaceLane;