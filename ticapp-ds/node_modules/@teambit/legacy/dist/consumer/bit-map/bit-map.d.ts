/// <reference types="node" />
import type { Consumer } from '..';
import { BitId, BitIds } from '../../bit-id';
import { BitIdStr } from '../../bit-id/bit-id';
import { RemoteLaneId } from '../../lane-id/lane-id';
import { PathLinux, PathOsBased, PathOsBasedAbsolute, PathOsBasedRelative, PathRelative } from '../../utils/path';
import { ComponentFsCache } from '../component/component-fs-cache';
import ComponentMap, { ComponentMapFile, ComponentOrigin, Config, PathChange } from './component-map';
import WorkspaceLane from './workspace-lane';
export declare type PathChangeResult = {
    id: BitId;
    changes: PathChange[];
};
export declare type IgnoreFilesDirs = {
    files: PathLinux[];
    dirs: PathLinux[];
};
export declare type GetBitMapComponentOptions = {
    ignoreVersion?: boolean;
    ignoreScopeAndVersion?: boolean;
};
export declare const LANE_KEY = "_bit_lane";
export declare const CURRENT_BITMAP_SCHEMA = "14.9.0";
export declare const SCHEMA_FIELD = "$schema-version";
/**
 * When working on lanes, a component version can be different than the main.
 * For example, when tagging 1.0.0 on main, then switching to a new lane and snapping.
 * The version saved in .bitmap file is the one of main (in this case 1.0.0).
 * The hash of the snap is saved on the 'workspace-lane' file.
 * These files are saved in .bit/workspace/lanes/<lane-name> directory, and they're not get
 * synched by Git.
 * Once a lane is exported to a remote scope, then .bitmap gets a new property
 * "lanes" array that includes the remote-lane-id and the version hash.
 * Still, the version on the ID doesn't get changed and it reflects the main version.
 * Since all operations on .bitmap are not aware of this new workspace-lane file and the "lanes" prop,
 * we do a manipulation when loading and when saving the .bitmap file.
 * When loading .bitmap file, it also loads the workspace-lane of the active lane if exists.
 * In case a bit-id has a different version on the workspace lane file, the version is changed
 * to the lane version and the old version is saved into a prop "defaultVersion".
 * This way, all methods that interact with .bitmap gets the correct version.
 * Once .bitmap is saved, the "version" is related by the "defaultVersion" if exists.
 */
export default class BitMap {
    projectRoot: string;
    private mapPath;
    schema: string;
    private isLegacy;
    workspaceLane: WorkspaceLane | null;
    private remoteLaneName?;
    components: ComponentMap[];
    hasChanged: boolean;
    paths: {
        [path: string]: BitId;
    };
    pathsLowerCase: {
        [path: string]: BitId;
    };
    markAsChangedBinded: Function;
    _cacheIds: {
        [origin: string]: BitIds | undefined;
    };
    allTrackDirs: {
        [trackDir: string]: BitId;
    } | null | undefined;
    private updatedIds;
    constructor(projectRoot: string, mapPath: string, schema: string, isLegacy: boolean, workspaceLane: WorkspaceLane | null, // null if not checked out to a lane
    remoteLaneName?: RemoteLaneId | undefined);
    markAsChanged(): void;
    setComponent(bitId: BitId, componentMap: ComponentMap): void;
    /**
     * in case the added component's root-dir is a parent-dir of other components
     * or other component's root-dir is a parent root-dir of this component, throw an error
     */
    private throwForExistingParentDir;
    setComponentProp(id: BitId, propName: keyof ComponentMap, val: any): ComponentMap;
    isEmpty(): any;
    removeComponentProp(id: BitId, propName: keyof ComponentMap): ComponentMap;
    static load(consumer: Consumer): Promise<BitMap>;
    static removeNonComponentFields(componentsJson: Record<string, any>): void;
    loadFiles(): Promise<void>;
    static loadRawSync(dirPath: PathOsBasedAbsolute): Buffer | undefined;
    static getBitMapLocation(dirPath: PathOsBasedAbsolute): {
        currentLocation: string | undefined;
        defaultLocation: string;
    };
    /**
     * if resetHard, delete the bitMap file.
     * Otherwise, try to load it and only if the file is corrupted then delete it.
     */
    static reset(dirPath: PathOsBasedAbsolute, resetHard: boolean): void;
    resetToNewComponents(): void;
    private throwForDuplicateRootDirs;
    loadComponents(componentsJson: Record<string, any>): void;
    static getBitIdFromComponentJson(componentId: string, componentFromJson: Record<string, any>, isLegacy?: boolean): BitId;
    getAllComponents(origin?: ComponentOrigin | ComponentOrigin[]): ComponentMap[];
    /**
     * important! you probably want to use "getAllIdsAvailableOnLane".
     * this method returns ids that are not available on the current lane and will throw errors when
     * trying to load them.
     */
    getAllBitIdsFromAllLanes(origin?: ComponentOrigin[]): BitIds;
    getAllIdsAvailableOnLane(origin?: ComponentOrigin[]): BitIds;
    /**
     * get existing bitmap bit-id by bit-id.
     * throw an exception if not found
     * @see also getBitIdIfExist
     */
    getBitId(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion }?: GetBitMapComponentOptions): BitId;
    /**
     * get existing bitmap bit-id by bit-id
     * don't throw an exception if not found
     * @see also getBitId
     */
    getBitIdIfExist(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion, }?: {
        ignoreVersion?: boolean;
        ignoreScopeAndVersion?: boolean;
    }): BitId | undefined;
    /**
     * get componentMap from bitmap by bit-id.
     * throw an exception if not found.
     * @see also getComponentIfExist
     */
    getComponent(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion }?: GetBitMapComponentOptions): ComponentMap;
    /**
     * get componentMap from bitmap by bit-id
     * don't throw an exception if not found
     * @see also getComponent
     */
    getComponentIfExist(bitId: BitId, { ignoreVersion, ignoreScopeAndVersion }?: GetBitMapComponentOptions): ComponentMap | undefined;
    getNonNestedComponentIfExist(bitId: BitId): ComponentMap | undefined;
    getComponentPreferNonNested(bitId: BitId): ComponentMap | undefined;
    getAuthoredAndImportedBitIds(): BitIds;
    getAuthoredAndImportedBitIdsOfDefaultLane(): BitIds;
    getAuthoredExportedComponents(): BitId[];
    getAuthoredNonExportedComponents(): BitId[];
    _makePathRelativeToProjectRoot(pathToChange: PathRelative): PathOsBasedRelative;
    /**
     * find ids that have the same name but different version
     * if compareWithoutScope is false, the scope should be identical in addition to the name
     */
    findSimilarIds(id: BitId, compareWithoutScope?: boolean): BitIds;
    deleteOlderVersionsOfComponent(componentId: BitId): void;
    /**
     * --- Don't use this function when you have the ID parsed. Use this.getBitId() instead ---
     *
     * id entered by the user may or may not include scope-name
     * search for a similar id in the bitmap and return the full BitId
     */
    getExistingBitId(id: BitIdStr, shouldThrow?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId | undefined;
    /**
     * check if both arrays are equal according to their 'relativePath', regardless the order
     */
    _areFilesArraysEqual(filesA: ComponentMapFile[], filesB: ComponentMapFile[]): boolean;
    /**
     * add files from filesB that are not in filesA
     */
    mergeFilesArray(filesA: ComponentMapFile[], filesB: ComponentMapFile[]): ComponentMapFile[];
    addComponent({ componentId, files, defaultScope, mainFile, origin, rootDir, trackDir, originallySharedDir, wrapDir, onLanesOnly, config, }: {
        componentId: BitId;
        files: ComponentMapFile[];
        defaultScope?: string;
        mainFile: PathLinux;
        origin: ComponentOrigin;
        rootDir?: PathOsBasedAbsolute | PathOsBasedRelative;
        trackDir?: PathOsBased;
        originallySharedDir?: PathLinux;
        wrapDir?: PathLinux;
        onLanesOnly?: boolean;
        config?: Config;
    }): ComponentMap;
    addFilesToComponent({ componentId, files }: {
        componentId: BitId;
        files: ComponentMapFile[];
    }): ComponentMap;
    reLoadAfterSwitchingLane(workspaceLane: null | WorkspaceLane): void;
    sortValidateAndMarkAsChanged(componentMap: ComponentMap): void;
    _invalidateCache: () => void;
    _removeFromComponentsArray(componentId: BitId): void;
    removeComponent(bitId: BitId): BitId | undefined;
    removeComponents(ids: BitIds): (BitId | undefined)[];
    isExistWithSameVersion(id: BitId): boolean;
    /**
     * needed after exporting or tagging a component.
     * We don't support export/tag of nested components, only authored or imported. For authored/imported components, could be
     * in the file-system only one instance with the same component-name. As a result, we can strip the
     * scope-name and the version, find the older version in bit.map and update the id with the new one.
     */
    updateComponentId(id: BitId, updateScopeOnly?: boolean): BitId;
    removeConfig(id: BitId): void;
    updateLanesProperty(workspaceLane: WorkspaceLane, remoteLaneId: RemoteLaneId): void;
    /**
     * Return a component id as listed in bit.map file
     * by a path exist in the files object
     *
     * @param {string} componentPath relative to consumer - as stored in bit.map files object
     * @returns {BitId} component id
     * @memberof BitMap
     */
    getComponentIdByPath(componentPath: PathLinux, caseSensitive?: boolean): BitId;
    _populateAllPaths(): void;
    getAllTrackDirs(): {
        [trackDir: string]: BitId;
    };
    updatePathLocation(from: PathOsBasedRelative, to: PathOsBasedRelative, existingPath: PathOsBasedAbsolute): PathChangeResult[];
    setRemoteLane(remoteLane: RemoteLaneId): void;
    /**
     * remove the id property before saving the components to the file as they are redundant with the keys
     */
    toObjects(): Record<string, any>;
    /**
     * do not call this function directly, let consumer.onDestroy() call it.
     * consumer.onDestroy() is being called (manually) at the end of the command process.
     * the risk of calling this method in other places is a parallel writing of this file, which
     * may result in a damaged file
     */
    write(componentFsCache: ComponentFsCache): Promise<any>;
    private contentToString;
    getContent(): Record<string, any>;
}
