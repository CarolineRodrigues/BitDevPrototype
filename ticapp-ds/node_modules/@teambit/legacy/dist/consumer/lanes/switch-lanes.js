"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = switchLanes;

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _repositories() {
  const data = require("../../scope/repositories");

  _repositories = function () {
    return data;
  };

  return data;
}

function _workspaceLane() {
  const data = _interopRequireDefault(require("../bit-map/workspace-lane"));

  _workspaceLane = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _checkoutVersion() {
  const data = require("../versions-ops/checkout-version");

  _checkoutVersion = function () {
    return data;
  };

  return data;
}

function _mergeVersion() {
  const data = require("../versions-ops/merge-version");

  _mergeVersion = function () {
    return data;
  };

  return data;
}

function _threeWayMerge() {
  const data = _interopRequireDefault(require("../versions-ops/merge-version/three-way-merge"));

  _threeWayMerge = function () {
    return data;
  };

  return data;
}

function _createLane() {
  const data = _interopRequireDefault(require("./create-lane"));

  _createLane = function () {
    return data;
  };

  return data;
}

async function switchLanes(consumer, switchProps, checkoutProps) {
  const {
    ids
  } = switchProps;
  const allComponentsStatus = await getAllComponentsStatus();
  const componentWithConflict = allComponentsStatus.find(component => component.mergeResults && component.mergeResults.hasConflicts);

  if (componentWithConflict) {
    if (!checkoutProps.promptMergeOptions && !checkoutProps.mergeStrategy) {
      throw new (_generalError().default)(`automatic merge has failed for component ${componentWithConflict.id.toStringWithoutVersion()}.\nplease use "--manual" to manually merge changes or use "--theirs / --ours" to choose one of the conflicted versions`);
    }

    if (!checkoutProps.mergeStrategy) checkoutProps.mergeStrategy = await (0, _mergeVersion().getMergeStrategyInteractive)();
  }

  const failedComponents = allComponentsStatus.filter(componentStatus => componentStatus.failureMessage).map(componentStatus => ({
    id: componentStatus.id,
    failureMessage: componentStatus.failureMessage
  }));
  const succeededComponents = allComponentsStatus.filter(componentStatus => !componentStatus.failureMessage); // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,
  // which can be an issue when some components are also dependencies of others

  const componentsResults = await (0, _pMapSeries().default)(succeededComponents, ({
    id,
    componentFromFS,
    mergeResults
  }) => {
    return (0, _checkoutVersion().applyVersion)(consumer, id, componentFromFS, mergeResults, checkoutProps);
  });
  (0, _checkoutVersion().markFilesToBeRemovedIfNeeded)(succeededComponents, componentsResults);
  await saveLanesData();
  const componentsWithDependencies = componentsResults.map(c => c.component).filter(c => c);
  const manyComponentsWriter = new (_manyComponentsWriter().default)({
    consumer,
    componentsWithDependencies,
    installNpmPackages: !checkoutProps.skipNpmInstall,
    override: true,
    verbose: checkoutProps.verbose,
    writeDists: !checkoutProps.ignoreDist,
    writeConfig: checkoutProps.writeConfig,
    writePackageJson: !checkoutProps.ignorePackageJson
  });
  await manyComponentsWriter.writeAll();
  await (0, _checkoutVersion().deleteFilesIfNeeded)(componentsResults, consumer);
  const appliedVersionComponents = componentsResults.map(c => c.applyVersionResult);
  return {
    components: appliedVersionComponents,
    failedComponents
  };

  async function getAllComponentsStatus() {
    const tmp = new (_repositories().Tmp)(consumer.scope);

    try {
      const componentsStatusP = ids.map(id => getComponentStatus(consumer, id, switchProps));
      const componentsStatus = await Promise.all(componentsStatusP);
      await tmp.clear(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }

  async function saveLanesData() {
    await saveCheckedOutLaneInfo(consumer, {
      remoteLaneScope: switchProps.remoteLaneScope,
      remoteLaneName: switchProps.remoteLaneName,
      localLaneName: switchProps.localLaneName,
      addTrackingInfo: !switchProps.localTrackedLane,
      laneComponents: switchProps.remoteLaneComponents
    });
  }
}

async function saveCheckedOutLaneInfo(consumer, opts) {
  const saveRemoteLaneToBitmap = () => {
    if (opts.remoteLaneScope) {
      consumer.bitMap.setRemoteLane(_laneId().RemoteLaneId.from(opts.remoteLaneName, opts.remoteLaneScope)); // add versions to lane
    }
  };

  const throwIfLaneExists = async () => {
    const allLanes = await consumer.scope.listLanes();

    if (allLanes.find(l => l.name === opts.localLaneName)) {
      throw new (_generalError().default)(`unable to checkout to lane "${opts.localLaneName}".
the lane already exists. please switch to the lane and merge`);
    }
  };

  if (opts.remoteLaneScope) {
    await throwIfLaneExists();
    await (0, _createLane().default)(consumer, opts.localLaneName, opts.laneComponents);

    if (opts.addTrackingInfo) {
      // otherwise, it is tracked already
      consumer.scope.lanes.trackLane({
        localLane: opts.localLaneName,
        remoteLane: opts.remoteLaneName,
        remoteScope: opts.remoteLaneScope
      });
    }
  }

  saveRemoteLaneToBitmap();
  consumer.scope.lanes.setCurrentLane(opts.localLaneName);
  const workspaceLane = opts.localLaneName === _constants().DEFAULT_LANE ? null : _workspaceLane().default.load(opts.localLaneName, consumer.scope.path);
  consumer.bitMap.reLoadAfterSwitchingLane(workspaceLane);
}

async function getComponentStatus(consumer, id, switchProps) {
  const componentStatus = {
    id
  };

  const returnFailure = msg => {
    componentStatus.failureMessage = msg;
    return componentStatus;
  };

  const modelComponent = await consumer.scope.getModelComponentIfExist(id);

  if (!modelComponent) {
    return returnFailure(`component ${id.toString()} had never imported`);
  }

  const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);

  if (unmerged && unmerged.resolved === false) {
    return returnFailure(`component ${id.toStringWithoutVersion()} has conflicts that need to be resolved first, please use bit merge --resolve/--abort`);
  }

  const version = id.version;

  if (!version) {
    return returnFailure(`component doesn't have any snaps on ${_constants().DEFAULT_LANE}`);
  }

  const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, {
    ignoreVersion: true
  });
  const componentOnLane = await modelComponent.loadVersion(version, consumer.scope.objects);

  if (!existingBitMapId) {
    if (switchProps.existingOnWorkspaceOnly) {
      return returnFailure(`component ${id.toStringWithoutVersion()} is not in the workspace`);
    }

    return {
      componentFromFS: undefined,
      componentFromModel: componentOnLane,
      id,
      mergeResults: null
    };
  }

  if (!existingBitMapId.hasVersion()) {
    // happens when switching from main to a lane and a component was snapped on the lane.
    // in the .bitmap file, the version is "latest" or empty. so we just need to write the component according to the
    // model. we don't care about the componentFromFS
    return {
      componentFromFS: undefined,
      componentFromModel: componentOnLane,
      id,
      mergeResults: null
    };
  }

  const currentlyUsedVersion = existingBitMapId.version;

  if (currentlyUsedVersion === version) {
    return returnFailure(`component ${id.toStringWithoutVersion()} is already at version ${version}`);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  const baseComponent = await modelComponent.loadVersion(currentlyUsedVersion, consumer.scope.objects);
  const component = await consumer.loadComponent(existingBitMapId);
  const isModified = await consumer.isComponentModified(baseComponent, component);
  let mergeResults;

  const isHeadSameAsMain = () => {
    const head = modelComponent.getHead();
    if (!head) return false;
    if (!existingBitMapId.version) return false;
    const tagVersion = modelComponent.getTagOfRefIfExists(head);
    const headVersion = tagVersion || head.toString();
    return existingBitMapId.version === headVersion;
  };

  if (isModified) {
    if (!isHeadSameAsMain()) {
      throw new (_generalError().default)(`unable to checkout ${id.toStringWithoutVersion()}, the component is modified and belongs to another lane`);
    }

    const otherComponent = await modelComponent.loadVersion(existingBitMapId.version, // we are here because the head is same as main. so, existingBitMapId.version must be set
    consumer.scope.objects);
    mergeResults = await (0, _threeWayMerge().default)({
      consumer,
      otherComponent,
      otherLabel: version,
      currentComponent: component,
      currentLabel: `${currentlyUsedVersion} modified`,
      baseComponent
    });
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  return {
    componentFromFS: component,
    componentFromModel: componentOnLane,
    id,
    mergeResults
  };
}