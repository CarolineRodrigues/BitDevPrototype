"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _uniqBy2() {
  const data = _interopRequireDefault(require("ramda/src/uniqBy"));

  _uniqBy2 = function () {
    return data;
  };

  return data;
}

function _is2() {
  const data = _interopRequireDefault(require("ramda/src/is"));

  _is2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _noIdMatchWildcard() {
  const data = _interopRequireDefault(require("../../api/consumer/lib/exceptions/no-id-match-wildcard"));

  _noIdMatchWildcard = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _modelComponent() {
  const data = _interopRequireDefault(require("../../scope/models/model-component"));

  _modelComponent = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("../../scope/scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _isBitIdMatchByWildcards() {
  const data = _interopRequireDefault(require("../../utils/bit/is-bit-id-match-by-wildcards"));

  _isBitIdMatchByWildcards = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("../component"));

  _component = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class ComponentsList {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore
  constructor(consumer) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "_fromFileSystem", {});
    (0, _defineProperty2().default)(this, "_fromObjectsIds", void 0);
    (0, _defineProperty2().default)(this, "_modelComponents", void 0);
    (0, _defineProperty2().default)(this, "_invalidComponents", void 0);
    (0, _defineProperty2().default)(this, "_modifiedComponents", void 0);
    (0, _defineProperty2().default)(this, "_mergePendingComponents", void 0);
    this.consumer = consumer;
    this.scope = consumer.scope;
    this.bitMap = consumer.bitMap;
  }

  async getModelComponents() {
    if (!this._modelComponents) {
      this._modelComponents = await this.scope.listIncludeRemoteHead(this.consumer.getCurrentLaneId());
    }

    return this._modelComponents;
  }
  /**
   * List all bit ids stored in the model
   */


  async getFromObjects() {
    if (!this._fromObjectsIds) {
      const modelComponents = await this.getModelComponents();
      this._fromObjectsIds = modelComponents.map(componentObjects => {
        return new (_bitId().BitId)({
          scope: componentObjects.scope,
          name: componentObjects.name,
          version: componentObjects.scope ? componentObjects.latest() : undefined
        });
      });
    }

    return this._fromObjectsIds;
  }

  async getAuthoredAndImportedFromFS() {
    let [authored, imported] = await Promise.all([this.getFromFileSystem(_constants().COMPONENT_ORIGINS.AUTHORED), this.getFromFileSystem(_constants().COMPONENT_ORIGINS.IMPORTED)]);
    authored = authored || [];
    imported = imported || [];
    return authored.concat(imported);
  }
  /**
   * Components that are in the model (either, tagged from a local scope or imported), and were
   * changed in the file system
   *
   * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
   * @return {Promise<string[]>}
   */


  async listModifiedComponents(load = false) {
    if (!this._modifiedComponents) {
      const fileSystemComponents = await this.getAuthoredAndImportedFromFS();
      const componentsWithUnresolvedConflicts = this.listDuringMergeStateComponents();
      const componentStatuses = await this.consumer.getManyComponentsStatuses(fileSystemComponents.map(f => f.id));
      this._modifiedComponents = fileSystemComponents.filter(component => {
        const status = componentStatuses.find(s => s.id.isEqual(component.id));
        if (!status) throw new Error(`listModifiedComponents unable to find status for ${component.id.toString()}`);
        return status.status.modified;
      }).filter(component => !componentsWithUnresolvedConflicts.hasWithoutScopeAndVersion(component.id));
    }

    if (load) return this._modifiedComponents;
    return this._modifiedComponents.map(component => component.id);
  }

  async listOutdatedComponents() {
    const fileSystemComponents = await this.getAuthoredAndImportedFromFS();
    const componentsFromModel = await this.getModelComponents();
    const componentsWithUnresolvedConflicts = this.listDuringMergeStateComponents();
    const mergePendingComponents = await this.listMergePendingComponents();

    const mergePendingComponentsIds = _bitId().BitIds.fromArray(mergePendingComponents.map(c => c.id));

    await Promise.all(fileSystemComponents.map(async component => {
      const modelComponent = componentsFromModel.find(c => c.toBitId().isEqualWithoutVersion(component.id));
      if (!modelComponent || !component.id.hasVersion() || componentsWithUnresolvedConflicts.hasWithoutScopeAndVersion(component.id)) return;

      if (mergePendingComponentsIds.hasWithoutVersion(component.id)) {
        // by default, outdated include merge-pending since the remote-head and local-head are
        // different, however we want them both to be separated as they need different treatment
        return;
      }

      const latestVersionLocally = modelComponent.latest();
      const latestIncludeRemoteHead = await modelComponent.latestIncludeRemote(this.scope.objects);

      const isOutdated = () => {
        if (latestIncludeRemoteHead !== latestVersionLocally) return true;
        return modelComponent.isLatestGreaterThan(component.id.version);
      };

      if (isOutdated()) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        component.latestVersion = latestIncludeRemoteHead;
      }
    })); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return fileSystemComponents.filter(f => f.latestVersion);
  }
  /**
   * list components that their head is a snap, not a tag.
   * this is relevant only when the lane is the default (main), otherwise, the head is always a snap.
   * components that are during-merge are filtered out, we don't want them during tag and don't want
   * to show them in the "snapped" section in bit-status.
   */


  async listSnappedComponentsOnMain() {
    if (!this.scope.lanes.isOnDefaultLane()) {
      return [];
    }

    const componentsFromModel = await this.getModelComponents();
    const authoredAndImportedIds = this.bitMap.getAuthoredAndImportedBitIds();
    const compsDuringMerge = this.listDuringMergeStateComponents();
    return componentsFromModel.filter(c => authoredAndImportedIds.hasWithoutVersion(c.toBitId())).filter(c => !compsDuringMerge.hasWithoutVersion(c.toBitId())).filter(c => c.isHeadSnap());
  }

  async listMergePendingComponents() {
    if (!this._mergePendingComponents) {
      const componentsFromFs = await this.getAuthoredAndImportedFromFS();
      const componentsFromModel = await this.getModelComponents();
      const componentsWithUnresolvedConflicts = this.listDuringMergeStateComponents();
      this._mergePendingComponents = (await Promise.all(componentsFromFs.map(async component => {
        const modelComponent = componentsFromModel.find(c => c.toBitId().isEqualWithoutVersion(component.id));
        if (!modelComponent || componentsWithUnresolvedConflicts.hasWithoutScopeAndVersion(component.id)) return null;
        await modelComponent.setDivergeData(this.scope.objects);
        const divergedData = modelComponent.getDivergeData();
        if (!modelComponent.getDivergeData().isDiverged()) return null;
        return {
          id: modelComponent.toBitId(),
          diverge: divergedData
        };
      }))).filter(x => x);
    }

    return this._mergePendingComponents;
  }

  listComponentsWithUnresolvedConflicts() {
    const unresolvedComponents = this.scope.objects.unmergedComponents.getUnresolvedComponents();
    return _bitId().BitIds.fromArray(unresolvedComponents.map(u => new (_bitId().BitId)(u.id)));
  }

  listDuringMergeStateComponents() {
    const unresolvedComponents = this.scope.objects.unmergedComponents.getComponents();
    return _bitId().BitIds.fromArray(unresolvedComponents.map(u => new (_bitId().BitId)(u.id)));
  }

  listSoftTaggedComponents() {
    return this.bitMap.components.filter(c => c.nextVersion).map(c => c.id);
  }

  async newModifiedAndAutoTaggedComponents() {
    const [newComponents, modifiedComponents] = await Promise.all([this.listNewComponents(true), this.listModifiedComponents(true)]);
    const autoTagPending = await this.listAutoTagPendingComponents(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const components = [...newComponents, ...modifiedComponents, ...autoTagPending];
    return Promise.all(components);
  }

  async authoredAndImportedComponents() {
    return this.getAuthoredAndImportedFromFS();
  }

  async idsFromObjects() {
    const fromObjects = await this.getFromObjects(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return new (_bitId().BitIds)(...fromObjects);
  }
  /**
   * Components that are registered in bit.map but have never been tagged
   *
   * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
   * @return {Promise.<string[] | Component[]>}
   * @memberof ComponentsList
   */


  async listNewComponents(load = false) {
    const idsFromBitMap = this.idsFromBitMap();
    const idsFromObjects = await this.idsFromObjects();
    const newComponents = [];
    idsFromBitMap.forEach(id => {
      if (!idsFromObjects.searchWithoutVersion(id)) {
        newComponents.push(id);
      }
    }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const newComponentsIds = new (_bitId().BitIds)(...newComponents);
    if (!load || !newComponents.length) return newComponentsIds;
    const {
      components
    } = await this.consumer.loadComponents(newComponentsIds, false);
    return components;
  }

  async listTagPendingOfAllScope(includeImported = false) {
    const tagPendingComponents = this.idsFromBitMap(_constants().COMPONENT_ORIGINS.AUTHORED);

    if (includeImported) {
      const importedComponents = this.idsFromBitMap(_constants().COMPONENT_ORIGINS.IMPORTED);
      tagPendingComponents.push(...importedComponents);
    }

    return tagPendingComponents;
  }
  /**
   * New and modified components are tag pending
   *
   * @return {Promise<string[]>}
   */


  async listTagPendingComponents() {
    const [newComponents, modifiedComponents] = await Promise.all([this.listNewComponents(), this.listModifiedComponents()]); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return _bitId().BitIds.fromArray([...newComponents, ...modifiedComponents]);
  }

  async listExportPendingComponentsIds(lane) {
    const fromBitMap = this.bitMap.getAuthoredAndImportedBitIds();
    const modelComponents = await this.getModelComponents();
    const pendingExportComponents = await (0, _utils().filterAsync)(modelComponents, async component => {
      if (!fromBitMap.searchWithoutVersion(component.toBitId())) {
        // it's not on the .bitmap only in the scope, as part of the out-of-sync feature, it should
        // be considered as staged and should be exported. notice that we use `hasLocalChanges`
        // and not `isLocallyChanged` by purpose. otherwise, cached components that were not
        // updated from a remote will be calculated as remote-ahead in the setDivergeData and will
        // be exported unexpectedly.
        return component.isLocallyChangedRegardlessOfLanes();
      }

      await component.setDivergeData(this.scope.objects);
      return component.isLocallyChanged(lane, this.scope.objects);
    });

    const ids = _bitId().BitIds.fromArray(pendingExportComponents.map(c => c.toBitId()));

    return this.updateIdsFromModelIfTheyOutOfSync(ids);
  }

  async listNonNewComponentsIds() {
    const authoredAndImported = await this.getAuthoredAndImportedFromFS(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const newComponents = await this.listNewComponents();
    const nonNewComponents = authoredAndImported.filter(component => !newComponents.has(component.id));
    return _bitId().BitIds.fromArray(nonNewComponents.map(c => c.id.changeVersion(undefined)));
  }

  async updateIdsFromModelIfTheyOutOfSync(ids) {
    const authoredAndImported = this.bitMap.getAuthoredAndImportedBitIds();
    const updatedIdsP = ids.map(async id => {
      const idFromBitMap = authoredAndImported.searchWithoutScopeAndVersion(id);

      if (idFromBitMap && !idFromBitMap.hasVersion()) {
        // component is out of sync, fix it by loading it from the consumer
        const component = await this.consumer.loadComponent(id.changeVersion(_constants().LATEST));
        return component.id;
      }

      return id;
    });
    const updatedIds = await Promise.all(updatedIdsP);
    return _bitId().BitIds.fromArray(updatedIds);
  }

  async listExportPendingComponents(laneObj) {
    const exportPendingComponentsIds = await this.listExportPendingComponentsIds(laneObj);
    return Promise.all(exportPendingComponentsIds.map(id => this.scope.getModelComponent(id)));
  }

  async listAutoTagPendingComponents() {
    const modifiedComponents = await this.listModifiedComponents();
    const newComponents = await this.listNewComponents();
    if (!modifiedComponents || !modifiedComponents.length) return [];
    const autoTagPending = await this.consumer.listComponentsForAutoTagging(_bitId().BitIds.fromArray(modifiedComponents));
    return autoTagPending.filter(autoTagComp => !newComponents.has(autoTagComp.id));
  }

  idsFromBitMap(origin) {
    const fromBitMap = this.getFromBitMap(origin);
    return fromBitMap;
  }

  async listAllIdsFromWorkspaceAndScope() {
    const idsFromBitMap = this.idsFromBitMap();
    const idsFromObjects = await this.idsFromObjects();
    return _bitId().BitIds.uniqFromArray([...idsFromBitMap, ...idsFromObjects]);
  }
  /**
   * Finds all components that are saved in the file system.
   * Components might be stored in the default component directory and also might be outside
   * of that directory. The bit.map is used to find them all
   * If they are on bit.map but not on the file-system, populate them to _invalidComponents property
   */


  async getFromFileSystem(origin) {
    const cacheKeyName = origin || 'all';

    if (!this._fromFileSystem[cacheKeyName]) {
      const idsFromBitMap = this.idsFromBitMap(origin); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const {
        components,
        invalidComponents
      } = await this.consumer.loadComponents(idsFromBitMap, false);
      this._fromFileSystem[cacheKeyName] = components;

      if (!this._invalidComponents && !origin) {
        this._invalidComponents = invalidComponents;
      }
    }

    return this._fromFileSystem[cacheKeyName];
  }
  /**
   * components that are on bit.map but not on the file-system
   */


  async listInvalidComponents() {
    if (!this._invalidComponents) {
      await this.getFromFileSystem();
    }

    return this._invalidComponents;
  }
  /**
   * valid on legacy only. Harmony requires components to have their own directories
   */


  async listComponentsWithIndividualFiles() {
    if (this.consumer.isLegacy) return [];
    const workspaceComponents = await this.getFromFileSystem(_constants().COMPONENT_ORIGINS.AUTHORED);
    return workspaceComponents.filter(component => {
      const componentMap = component.componentMap;
      if (!componentMap) throw new Error('listComponentsWithIndividualFiles componentMap is missing');
      return Boolean(!componentMap.trackDir && !componentMap.rootDir);
    });
  }
  /**
   * valid on legacy only. Harmony creates `rootDir` instead of the `trackDir`.
   */


  async listComponentsWithTrackDir() {
    if (this.consumer.isLegacy) return [];
    const workspaceComponents = await this.getFromFileSystem(_constants().COMPONENT_ORIGINS.AUTHORED);
    return workspaceComponents.filter(component => {
      const componentMap = component.componentMap;
      if (!componentMap) throw new Error('listComponentsWithIndividualFiles componentMap is missing');
      return Boolean(componentMap.trackDir);
    });
  }

  getFromBitMap(origin) {
    const originParam = origin ? [origin] : undefined;
    return this.bitMap.getAllIdsAvailableOnLane(originParam);
  }

  getPathsForAllFilesOfAllComponents(origin, absolute = false) {
    // TODO: maybe cache this as well
    const componentMaps = this.bitMap.getAllComponents(origin);
    const result = [];

    const populatePaths = componentMap => {
      const relativePaths = componentMap.getFilesRelativeToConsumer();

      if (!absolute) {
        result.push(...relativePaths);
        return;
      }

      const consumerPath = this.consumer.getPath();
      const absPaths = relativePaths.map(relativePath => path().join(consumerPath, relativePath));
      result.push(...absPaths);
    };

    componentMaps.forEach(componentMap => populatePaths(componentMap));
    return result;
  }
  /**
   * get called when the Consumer is available, shows also components from remote scopes
   */


  async listAll(showRemoteVersion, listScope, namespacesUsingWildcards) {
    const modelComponents = await this.getModelComponents();
    const authoredAndImportedIds = this.bitMap.getAuthoredAndImportedBitIds();
    const authoredAndImportedIdsNoVer = authoredAndImportedIds.map(id => id.changeVersion(undefined));
    const modelComponentsIds = modelComponents.map(c => c.toBitId());
    const allIds = listScope ? modelComponentsIds : _bitId().BitIds.uniqFromArray([...authoredAndImportedIdsNoVer, ...modelComponentsIds]);
    const idsFilteredByWildcards = namespacesUsingWildcards ? ComponentsList.filterComponentsByWildcard(allIds, namespacesUsingWildcards) : allIds;
    const idsSorted = ComponentsList.sortComponentsByName(idsFilteredByWildcards);
    const listAllResults = await Promise.all(idsSorted.map(async id => {
      const component = modelComponents.find(c => c.toBitId().isEqualWithoutVersion(id));
      const deprecated = await (component === null || component === void 0 ? void 0 : component.isDeprecated(this.scope.objects));
      return {
        id: component ? component.toBitIdWithLatestVersion() : id,
        deprecated
      };
    }));
    const componentsIds = listAllResults.map(result => result.id);

    if (showRemoteVersion) {
      const latestVersionsInfo = await (0, _scopeRemotes().fetchRemoteVersions)(this.scope, componentsIds);
      latestVersionsInfo.forEach(componentId => {
        const listResult = listAllResults.find(c => c.id.isEqualWithoutVersion(componentId));
        if (!listResult) throw new Error(`failed finding ${componentId.toString()} in componentsIds`); // $FlowFixMe version must be set as it came from a remote
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        listResult.remoteVersion = componentId.version;
      });
    }

    listAllResults.forEach(listResult => {
      const existingBitMapId = authoredAndImportedIds.searchWithoutVersion(listResult.id);

      if (existingBitMapId) {
        listResult.currentlyUsedVersion = existingBitMapId.hasVersion() ? existingBitMapId.version : undefined;
      }
    });

    if (listScope) {
      return listAllResults;
    }

    const currentLane = await this.consumer.getCurrentLaneObject();

    const isIdOnCurrentLane = componentMap => {
      if (!componentMap.onLanesOnly) return true; // component is on main, always show it

      if (!currentLane) return false; // if !currentLane the user is on main, don't show it.

      return Boolean(currentLane.getComponent(componentMap.id));
    };

    return listAllResults.filter(listResult => {
      const componentMap = this.bitMap.getComponentIfExist(listResult.id, {
        ignoreVersion: true
      });
      return componentMap && componentMap.origin !== _constants().COMPONENT_ORIGINS.NESTED && isIdOnCurrentLane(componentMap);
    });
  }
  /**
   * get called from a bare-scope, shows only components of that scope
   */


  static async listLocalScope(scope, namespacesUsingWildcards) {
    const components = await scope.listLocal();
    const componentsFilteredByWildcards = namespacesUsingWildcards ? ComponentsList.filterComponentsByWildcard(components, namespacesUsingWildcards) : components;
    const componentsSorted = ComponentsList.sortComponentsByName(componentsFilteredByWildcards);
    return Promise.all(componentsSorted.map(async component => ({
      id: component.toBitIdWithLatestVersion(),
      deprecated: await component.isDeprecated(scope.objects)
    })));
  } // components can be one of the following: Component[] | ModelComponent[] | string[] | BitId[]


  static sortComponentsByName(components) {
    const getName = component => {
      let name;
      if ((0, _is2().default)(_modelComponent().default, component)) name = component.id();else if ((0, _is2().default)(_component().default, component)) name = component.id.toString();else if ((0, _is2().default)(_bitId().BitId, component)) name = component.toString();else name = component;
      return name.toUpperCase(); // ignore upper and lowercase
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return components.sort((a, b) => {
      const nameA = getName(a);
      const nameB = getName(b);

      if (nameA < nameB) {
        return -1;
      }

      if (nameA > nameB) {
        return 1;
      } // names must be equal


      return 0;
    });
  }

  static filterComponentsByWildcard(components, idsWithWildcard) {
    const getBitId = component => {
      if ((0, _is2().default)(_modelComponent().default, component)) return component.toBitId();
      if ((0, _is2().default)(_component().default, component)) return component.id;
      if ((0, _is2().default)(_bitId().BitId, component)) return component;
      throw new TypeError(`filterComponentsByWildcard got component with the wrong type: ${typeof component}`);
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return components.filter(component => {
      const bitId = getBitId(component);
      return (0, _isBitIdMatchByWildcards().default)(bitId, idsWithWildcard);
    });
  }

  static getUniqueComponents(components) {
    return (0, _uniqBy2().default)(component => JSON.stringify(component.id), components);
  }

  listComponentsByIdsWithWildcard(idsWithWildcard) {
    const allIds = this.bitMap.getAuthoredAndImportedBitIds();
    const matchedIds = ComponentsList.filterComponentsByWildcard(allIds, idsWithWildcard);
    if (!matchedIds.length) throw new (_noIdMatchWildcard().default)(idsWithWildcard); // $FlowFixMe filterComponentsByWildcard got BitId so it returns BitId

    return matchedIds;
  }

}

exports.default = ComponentsList;