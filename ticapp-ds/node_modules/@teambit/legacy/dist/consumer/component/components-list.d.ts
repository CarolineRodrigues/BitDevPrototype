import { BitId, BitIds } from '../../bit-id';
import { DivergeData } from '../../scope/component-ops/diverge-data';
import { Lane } from '../../scope/models';
import ModelComponent from '../../scope/models/model-component';
import Version from '../../scope/models/version';
import Scope from '../../scope/scope';
import BitMap from '../bit-map/bit-map';
import { ComponentOrigin } from '../bit-map/component-map';
import Component from '../component';
import { InvalidComponent } from '../component/consumer-component';
import Consumer from '../consumer';
export declare type ObjectsList = Promise<{
    [componentId: string]: Version;
}>;
export declare type ListScopeResult = {
    id: BitId;
    currentlyUsedVersion?: string | null | undefined;
    remoteVersion?: string;
    deprecated?: boolean;
};
export declare type DivergedComponent = {
    id: BitId;
    diverge: DivergeData;
};
export default class ComponentsList {
    consumer: Consumer;
    scope: Scope;
    bitMap: BitMap;
    _fromFileSystem: {
        [cacheKey: string]: Component[];
    };
    _fromObjectsIds: BitId[];
    _modelComponents: ModelComponent[];
    _invalidComponents: InvalidComponent[];
    _modifiedComponents: Component[];
    private _mergePendingComponents;
    constructor(consumer: Consumer);
    getModelComponents(): Promise<ModelComponent[]>;
    /**
     * List all bit ids stored in the model
     */
    getFromObjects(): Promise<BitId[]>;
    getAuthoredAndImportedFromFS(): Promise<Component[]>;
    /**
     * Components that are in the model (either, tagged from a local scope or imported), and were
     * changed in the file system
     *
     * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
     * @return {Promise<string[]>}
     */
    listModifiedComponents(load?: boolean): Promise<Array<BitId | Component>>;
    listOutdatedComponents(): Promise<Component[]>;
    /**
     * list components that their head is a snap, not a tag.
     * this is relevant only when the lane is the default (main), otherwise, the head is always a snap.
     * components that are during-merge are filtered out, we don't want them during tag and don't want
     * to show them in the "snapped" section in bit-status.
     */
    listSnappedComponentsOnMain(): Promise<ModelComponent[]>;
    listMergePendingComponents(): Promise<DivergedComponent[]>;
    listComponentsWithUnresolvedConflicts(): BitIds;
    listDuringMergeStateComponents(): BitIds;
    listSoftTaggedComponents(): BitId[];
    newModifiedAndAutoTaggedComponents(): Promise<Component[]>;
    authoredAndImportedComponents(): Promise<Component[]>;
    idsFromObjects(): Promise<BitIds>;
    /**
     * Components that are registered in bit.map but have never been tagged
     *
     * @param {boolean} [load=false] - Whether to load the component (false will return only the id)
     * @return {Promise.<string[] | Component[]>}
     * @memberof ComponentsList
     */
    listNewComponents(load?: boolean): Promise<BitIds | Component[]>;
    listTagPendingOfAllScope(includeImported?: boolean): Promise<BitId[]>;
    /**
     * New and modified components are tag pending
     *
     * @return {Promise<string[]>}
     */
    listTagPendingComponents(): Promise<BitIds>;
    listExportPendingComponentsIds(lane?: Lane | null): Promise<BitIds>;
    listNonNewComponentsIds(): Promise<BitIds>;
    updateIdsFromModelIfTheyOutOfSync(ids: BitIds): Promise<BitIds>;
    listExportPendingComponents(laneObj: Lane | null): Promise<ModelComponent[]>;
    listAutoTagPendingComponents(): Promise<Component[]>;
    idsFromBitMap(origin?: ComponentOrigin): BitIds;
    listAllIdsFromWorkspaceAndScope(): Promise<BitIds>;
    /**
     * Finds all components that are saved in the file system.
     * Components might be stored in the default component directory and also might be outside
     * of that directory. The bit.map is used to find them all
     * If they are on bit.map but not on the file-system, populate them to _invalidComponents property
     */
    getFromFileSystem(origin?: ComponentOrigin): Promise<Component[]>;
    /**
     * components that are on bit.map but not on the file-system
     */
    listInvalidComponents(): Promise<InvalidComponent[]>;
    /**
     * valid on legacy only. Harmony requires components to have their own directories
     */
    listComponentsWithIndividualFiles(): Promise<Component[]>;
    /**
     * valid on legacy only. Harmony creates `rootDir` instead of the `trackDir`.
     */
    listComponentsWithTrackDir(): Promise<Component[]>;
    getFromBitMap(origin?: ComponentOrigin): BitIds;
    getPathsForAllFilesOfAllComponents(origin?: ComponentOrigin, absolute?: boolean): string[];
    /**
     * get called when the Consumer is available, shows also components from remote scopes
     */
    listAll(showRemoteVersion: boolean, listScope: boolean, namespacesUsingWildcards?: string): Promise<ListScopeResult[]>;
    /**
     * get called from a bare-scope, shows only components of that scope
     */
    static listLocalScope(scope: Scope, namespacesUsingWildcards?: string): Promise<ListScopeResult[]>;
    static sortComponentsByName<T>(components: T): T;
    static filterComponentsByWildcard<T>(components: T, idsWithWildcard: string[] | string): T;
    static getUniqueComponents(components: Component[]): Component[];
    listComponentsByIdsWithWildcard(idsWithWildcard: string[]): BitId[];
}
