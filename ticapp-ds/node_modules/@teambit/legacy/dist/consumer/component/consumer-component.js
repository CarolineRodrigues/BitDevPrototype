"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = _interopRequireDefault(require("../../bit-id/bit-id"));

  _bitId = function () {
    return data;
  };

  return data;
}

function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));

  _bitIds = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _environment() {
  const data = _interopRequireDefault(require("../../environment/environment"));

  _environment = function () {
    return data;
  };

  return data;
}

function _isolator() {
  const data = _interopRequireDefault(require("../../environment/isolator"));

  _isolator = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _parser() {
  const data = _interopRequireDefault(require("../../jsdoc/parser"));

  _parser = function () {
    return data;
  };

  return data;
}

function _compilerExtension() {
  const data = _interopRequireDefault(require("../../legacy-extensions/compiler-extension"));

  _compilerExtension = function () {
    return data;
  };

  return data;
}

function _envExtension() {
  const data = _interopRequireDefault(require("../../legacy-extensions/env-extension"));

  _envExtension = function () {
    return data;
  };

  return data;
}

function _envFactory() {
  const data = _interopRequireDefault(require("../../legacy-extensions/env-factory"));

  _envFactory = function () {
    return data;
  };

  return data;
}

function _extensionFileNotFound() {
  const data = _interopRequireDefault(require("../../legacy-extensions/exceptions/extension-file-not-found"));

  _extensionFileNotFound = function () {
    return data;
  };

  return data;
}

function _extensionIsolateResult() {
  const data = _interopRequireDefault(require("../../legacy-extensions/extension-isolate-result"));

  _extensionIsolateResult = function () {
    return data;
  };

  return data;
}

function _testerExtension() {
  const data = _interopRequireDefault(require("../../legacy-extensions/tester-extension"));

  _testerExtension = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _componentDependencies() {
  const data = _interopRequireDefault(require("../../scope/component-dependencies"));

  _componentDependencies = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _createSymlinkOrCopy() {
  const data = _interopRequireDefault(require("../../utils/fs/create-symlink-or-copy"));

  _createSymlinkOrCopy = function () {
    return data;
  };

  return data;
}

function _ignoredDirectory() {
  const data = require("../component-ops/add-components/exceptions/ignored-directory");

  _ignoredDirectory = function () {
    return data;
  };

  return data;
}

function _buildComponent() {
  const data = _interopRequireDefault(require("../component-ops/build-component"));

  _buildComponent = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _injectConf() {
  const data = _interopRequireDefault(require("../component-ops/inject-conf"));

  _injectConf = function () {
    return data;
  };

  return data;
}

function _manipulateDir() {
  const data = require("../component-ops/manipulate-dir");

  _manipulateDir = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = _interopRequireDefault(require("../config"));

  _config = function () {
    return data;
  };

  return data;
}

function _componentOverrides() {
  const data = _interopRequireDefault(require("../config/component-overrides"));

  _componentOverrides = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("../config/extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _componentOutOfSync() {
  const data = _interopRequireDefault(require("../exceptions/component-out-of-sync"));

  _componentOutOfSync = function () {
    return data;
  };

  return data;
}

function _componentSpecsFailed() {
  const data = _interopRequireDefault(require("../exceptions/component-specs-failed"));

  _componentSpecsFailed = function () {
    return data;
  };

  return data;
}

function _specsResults() {
  const data = _interopRequireDefault(require("../specs-results"));

  _specsResults = function () {
    return data;
  };

  return data;
}

function _componentSchema() {
  const data = require("./component-schema");

  _componentSchema = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = require("./dependencies");

  _dependencies = function () {
    return data;
  };

  return data;
}

function _componentNotFoundInPath() {
  const data = _interopRequireDefault(require("./exceptions/component-not-found-in-path"));

  _componentNotFoundInPath = function () {
    return data;
  };

  return data;
}

function _externalTestErrors() {
  const data = _interopRequireDefault(require("./exceptions/external-test-errors"));

  _externalTestErrors = function () {
    return data;
  };

  return data;
}

function _fileSourceNotFound() {
  const data = _interopRequireDefault(require("./exceptions/file-source-not-found"));

  _fileSourceNotFound = function () {
    return data;
  };

  return data;
}

function _mainFileRemoved() {
  const data = _interopRequireDefault(require("./exceptions/main-file-removed"));

  _mainFileRemoved = function () {
    return data;
  };

  return data;
}

function _missingFilesFromComponent() {
  const data = _interopRequireDefault(require("./exceptions/missing-files-from-component"));

  _missingFilesFromComponent = function () {
    return data;
  };

  return data;
}

function _noComponentDir() {
  const data = require("./exceptions/no-component-dir");

  _noComponentDir = function () {
    return data;
  };

  return data;
}

function _dists() {
  const data = _interopRequireDefault(require("./sources/dists"));

  _dists = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Component {
  static registerOnComponentConfigLoading(extId, func) {
    _config().default.registerOnComponentConfigLoading(extId, func);
  }

  static registerOnComponentConfigLegacyLoading(extId, func) {
    _config().default.registerOnComponentConfigLegacyLoading(extId, func);
  }

  static registerOnComponentOverridesLoading(extId, func) {
    _componentOverrides().default.registerOnComponentOverridesLoading(extId, func);
  }

  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  get id() {
    return new (_bitId().default)({
      scope: this.scope,
      name: this.name,
      version: this.version
    });
  }

  constructor({
    name,
    version,
    scope,
    files,
    lang,
    bindingPrefix,
    mainFile,
    compiler,
    tester,
    bitJson,
    dependencies,
    devDependencies,
    flattenedDependencies,
    packageDependencies,
    devPackageDependencies,
    peerPackageDependencies,
    compilerPackageDependencies,
    testerPackageDependencies,
    componentFromModel,
    overrides,
    schema,
    defaultScope,
    packageJsonFile,
    packageJsonChangedProps,
    docs,
    dists,
    mainDistFile,
    specsResults,
    license,
    log,
    deprecated,
    origin,
    customResolvedPaths,
    scopesList,
    extensions,
    buildStatus
  }) {
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "version", void 0);
    (0, _defineProperty2().default)(this, "previouslyUsedVersion", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "lang", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "mainFile", void 0);
    (0, _defineProperty2().default)(this, "compiler", void 0);
    (0, _defineProperty2().default)(this, "tester", void 0);
    (0, _defineProperty2().default)(this, "bitJson", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "flattenedDependencies", void 0);
    (0, _defineProperty2().default)(this, "packageDependencies", void 0);
    (0, _defineProperty2().default)(this, "devPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "peerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "compilerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "testerPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "manuallyRemovedDependencies", {});
    (0, _defineProperty2().default)(this, "manuallyAddedDependencies", {});
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "docs", void 0);
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "dists", void 0);
    (0, _defineProperty2().default)(this, "specsResults", void 0);
    (0, _defineProperty2().default)(this, "license", void 0);
    (0, _defineProperty2().default)(this, "log", void 0);
    (0, _defineProperty2().default)(this, "writtenPath", void 0);
    (0, _defineProperty2().default)(this, "dependenciesSavedAsComponents", true);
    (0, _defineProperty2().default)(this, "originallySharedDir", void 0);
    (0, _defineProperty2().default)(this, "_wasOriginallySharedDirStripped", void 0);
    (0, _defineProperty2().default)(this, "wrapDir", void 0);
    (0, _defineProperty2().default)(this, "loadedFromFileSystem", false);
    (0, _defineProperty2().default)(this, "schema", void 0);
    (0, _defineProperty2().default)(this, "componentMap", void 0);
    (0, _defineProperty2().default)(this, "componentFromModel", void 0);
    (0, _defineProperty2().default)(this, "isolatedEnvironment", void 0);
    (0, _defineProperty2().default)(this, "issues", void 0);
    (0, _defineProperty2().default)(this, "deprecated", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    (0, _defineProperty2().default)(this, "origin", void 0);
    (0, _defineProperty2().default)(this, "customResolvedPaths", void 0);
    (0, _defineProperty2().default)(this, "_isModified", void 0);
    (0, _defineProperty2().default)(this, "packageJsonFile", void 0);
    (0, _defineProperty2().default)(this, "packageJsonChangedProps", void 0);
    (0, _defineProperty2().default)(this, "_currentlyUsedVersion", void 0);
    (0, _defineProperty2().default)(this, "pendingVersion", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    (0, _defineProperty2().default)(this, "scopesList", void 0);
    (0, _defineProperty2().default)(this, "extensions", new (_extensionData().ExtensionDataList)());
    (0, _defineProperty2().default)(this, "_capsuleDir", void 0);
    (0, _defineProperty2().default)(this, "buildStatus", void 0);
    this.name = name;
    this.version = version;
    this.scope = scope;
    this.files = files;
    this.lang = lang || _constants().DEFAULT_LANGUAGE;
    this.bindingPrefix = bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;
    this.mainFile = path().normalize(mainFile);
    this.compiler = compiler;
    this.tester = tester;
    this.bitJson = bitJson;
    this.setDependencies(dependencies);
    this.setDevDependencies(devDependencies);
    this.flattenedDependencies = flattenedDependencies || new (_bitIds().default)();
    this.packageDependencies = packageDependencies || {};
    this.devPackageDependencies = devPackageDependencies || {};
    this.peerPackageDependencies = peerPackageDependencies || {};
    this.compilerPackageDependencies = compilerPackageDependencies || {};
    this.testerPackageDependencies = testerPackageDependencies || {};
    this.overrides = overrides;
    this.defaultScope = defaultScope;
    this.packageJsonFile = packageJsonFile;
    this.packageJsonChangedProps = packageJsonChangedProps;
    this.docs = docs || [];
    this.setDists(dists, mainDistFile ? path().normalize(mainDistFile) : undefined); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.specsResults = specsResults;
    this.license = license;
    this.log = log;
    this.deprecated = deprecated || false;
    this.origin = origin;
    this.customResolvedPaths = customResolvedPaths || [];
    this.scopesList = scopesList;
    this.extensions = extensions || [];
    this.componentFromModel = componentFromModel;
    this.schema = schema;
    this.buildStatus = buildStatus;
    this.issues = new (_componentIssues().IssuesList)();
  }

  validateComponent() {
    const nonEmptyFields = ['name', 'mainFile'];
    nonEmptyFields.forEach(field => {
      if (!this[field]) {
        throw new (_generalError().default)(`failed loading a component ${this.id}, the field "${field}" can't be empty`);
      }
    });
  }
  /**
   * Warning: this method does not return a deep copy for all objects in this class, only for the
   * ones you see in the implementation below.
   * Implement deep copy of other properties if needed
   */


  clone() {
    const newInstance = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    newInstance.setDependencies(this.dependencies.getClone());
    newInstance.setDevDependencies(this.devDependencies.getClone());
    newInstance.overrides = this.overrides.clone();
    newInstance.files = this.files.map(file => file.clone());
    newInstance.dists = this.dists.clone();
    return newInstance;
  }

  getTmpFolder(workspacePrefix = '') {
    let folder = path().join(workspacePrefix, _constants().BIT_WORKSPACE_TMP_DIRNAME, this.id.name);

    if (this.componentMap) {
      const componentDir = this.componentMap.getComponentDir();

      if (componentDir) {
        folder = path().join(workspacePrefix, componentDir, _constants().BIT_WORKSPACE_TMP_DIRNAME);
      }
    } // Isolated components (for ci-update for example)


    if (this.isolatedEnvironment && this.writtenPath) {
      // Do not join the workspacePrefix since the written path is already a full path
      folder = path().join(this.writtenPath, _constants().BIT_WORKSPACE_TMP_DIRNAME);
    }

    return folder;
  }

  setDependencies(dependencies) {
    this.dependencies = new (_dependencies().Dependencies)(dependencies);
  }

  setDevDependencies(devDependencies) {
    this.devDependencies = new (_dependencies().Dependencies)(devDependencies);
  }

  setDists(dists, mainDistFile) {
    this.dists = new (_dists().default)(dists, mainDistFile);
  }

  getFileExtension() {
    switch (this.lang) {
      case _constants().DEFAULT_LANGUAGE:
      default:
        return 'js';
    }
  }

  async getDetachedCompiler(consumer) {
    return this._isEnvDetach(consumer, _constants().COMPILER_ENV_TYPE);
  }

  async getDetachedTester(consumer) {
    return this._isEnvDetach(consumer, _constants().TESTER_ENV_TYPE);
  }

  async _isEnvDetach(consumer, envType) {
    if (this.origin !== _constants().COMPONENT_ORIGINS.AUTHORED || !consumer) return true;
    const context = {
      workspaceDir: consumer.getPath()
    };
    const fromConsumer = await consumer.getEnv(envType, context); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const fromComponent = this[envType] ? this[envType].toModelObject() : null;
    return _envExtension().default.areEnvsDifferent(fromConsumer ? fromConsumer.toModelObject() : null, fromComponent);
  }

  _getHomepage() {
    // TODO: Validate somehow that this scope is really on bitsrc (maybe check if it contains . ?)
    const homepage = this.scope ? `https://${_constants().BASE_WEB_DOMAIN}/${this.scope.replace('.', '/')}/${this.name}` : undefined;
    return homepage;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  async injectConfig(consumerPath, bitMap, force = false) {
    this.componentMap = this.componentMap || bitMap.getComponentIfExist(this.id);
    const componentMap = this.componentMap;

    if (!componentMap) {
      throw new (_generalError().default)('could not find component in the .bitmap file');
    }

    const res = await (0, _injectConf().default)(this, consumerPath, force); // @ts-ignore

    return res;
  }

  get extensionDependencies() {
    return new (_dependencies().Dependencies)(this.extensions.extensionsBitIds.map(id => new (_dependencies().Dependency)(id, [])));
  }

  getAllDependencies() {
    return [...this.dependencies.dependencies, ...this.devDependencies.dependencies, ...this.extensionDependencies.dependencies];
  }

  getAllDependenciesCloned() {
    const dependencies = [...this.dependencies.getClone(), ...this.devDependencies.getClone(), ...this.extensionDependencies.getClone()];
    return new (_dependencies().Dependencies)(dependencies);
  }

  getAllNonEnvsDependencies() {
    return [...this.dependencies.dependencies, ...this.devDependencies.dependencies];
  }

  getAllDependenciesIds() {
    const allDependencies = (0, _flatten2().default)(Object.values(this.depsIdsGroupedByType));
    return _bitIds().default.fromArray(allDependencies);
  }

  get depsIdsGroupedByType() {
    return {
      dependencies: this.dependencies.getAllIds(),
      devDependencies: this.devDependencies.getAllIds(),
      extensionDependencies: this.extensions.extensionsBitIds
    };
  }

  hasDependencies() {
    const allDependencies = this.getAllDependenciesIds();
    return Boolean(allDependencies.length);
  }

  getAllFlattenedDependencies() {
    return [...this.flattenedDependencies];
  }
  /**
   * Before writing the files into the file-system, remove the path-prefix that is shared among the main component files
   * and its dependencies. It helps to avoid large file-system paths.
   *
   * This is relevant for IMPORTED and NESTED components only as the author may have long paths
   * that are not needed for whoever imports it. AUTHORED components are written as is.
   *
   * @see sources.consumerComponentToVersion() for the opposite action. meaning, adding back the sharedDir.
   */


  stripOriginallySharedDir(manipulateDirData) {
    if (this._wasOriginallySharedDirStripped) return;
    this.setOriginallySharedDir(manipulateDirData);
    const originallySharedDir = this.originallySharedDir;

    if (originallySharedDir) {
      _logger().default.debug(`stripping originallySharedDir "${originallySharedDir}" from ${this.id}`);
    }

    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newRelative = (0, _manipulateDir().stripSharedDirFromPath)(file.relative, originallySharedDir); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      file.updatePaths({
        newBase: file.base,
        newRelative
      });
    });
    this.dists.stripOriginallySharedDir(originallySharedDir);
    this.mainFile = (0, _manipulateDir().stripSharedDirFromPath)(this.mainFile, originallySharedDir); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.dependencies.stripOriginallySharedDir(manipulateDirData, originallySharedDir); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.devDependencies.stripOriginallySharedDir(manipulateDirData, originallySharedDir);
    this.customResolvedPaths.forEach(customPath => {
      customPath.destinationPath = (0, _utils().pathNormalizeToLinux)((0, _manipulateDir().stripSharedDirFromPath)(path().normalize(customPath.destinationPath), originallySharedDir));
    });
    this.overrides.stripOriginallySharedDir(originallySharedDir);
    this._wasOriginallySharedDirStripped = true;
  }
  /**
   * components added since v14.8.0 have "rootDir" in .bitmap, which is mostly the same as the
   * sharedDir. so, if rootDir is found, no need to strip/add the sharedDir as the files are
   * already relative to the sharedDir rather than the author workspace.
   */


  get ignoreSharedDir() {
    return !(0, _componentSchema().isSchemaSupport)(_componentSchema().SchemaFeature.sharedDir, this.schema);
  }

  get isLegacy() {
    return !this.schema || this.schema === _componentSchema().SchemaName.Legacy;
  }

  addWrapperDir(manipulateDirData) {
    const manipulateDirItem = manipulateDirData.find(m => m.id.isEqual(this.id));
    if (!manipulateDirItem || !manipulateDirItem.wrapDir) return;
    this.wrapDir = manipulateDirItem.wrapDir;

    const pathWithWrapDir = pathStr => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return path().join(this.wrapDir, pathStr);
    };

    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newRelative = pathWithWrapDir(file.relative); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      file.updatePaths({
        newBase: file.base,
        newRelative
      });
    }); // @todo: for dist also.

    this.mainFile = pathWithWrapDir(this.mainFile);
    const allDependencies = new (_dependencies().Dependencies)(this.getAllDependencies());
    allDependencies.addWrapDir(manipulateDirData, this.wrapDir);
    this.customResolvedPaths.forEach(customPath => {
      customPath.destinationPath = (0, _utils().pathNormalizeToLinux)(pathWithWrapDir(path().normalize(customPath.destinationPath)));
    });
  }

  addSharedDir(pathStr) {
    const withSharedDir = this.originallySharedDir ? path().join(this.originallySharedDir, pathStr) : pathStr;
    return (0, _utils().pathNormalizeToLinux)(withSharedDir);
  }

  cloneFilesWithSharedDir() {
    return this.files.map(file => {
      const newFile = file.clone();
      const newRelative = this.addSharedDir(file.relative);
      newFile.updatePaths({
        newRelative
      });
      return newFile;
    });
  }

  async build({
    scope,
    save,
    consumer,
    noCache,
    verbose,
    dontPrintEnvMsg,
    directory,
    keep
  }) {
    return (0, _buildComponent().default)({
      component: this,
      scope,
      save,
      consumer,
      noCache,
      directory,
      verbose,
      dontPrintEnvMsg,
      keep
    });
  }

  async runSpecs({
    scope,
    rejectOnFailure = false,
    // reject when some (or all) of the tests were failed. relevant when running tests during 'bit tag'
    consumer,
    save,
    verbose,
    dontPrintEnvMsg,
    isolated,
    directory,
    keep
  }) {
    const testFiles = this.files.filter(file => file.test);
    const consumerPath = consumer ? consumer.getPath() : '';
    if (!this.tester || !testFiles || (0, _isEmpty2().default)(testFiles)) return undefined;

    _logger().default.debug('tester found, start running tests');

    _analytics().Analytics.addBreadCrumb('runSpecs', 'tester found, start running tests');

    const tester = this.tester;

    if (!tester.loaded) {
      const componentDir = this.componentMap ? this.componentMap.getComponentDir() : undefined;
      const context = {
        dependentId: this.id,
        workspaceDir: consumerPath,
        componentDir
      };

      _analytics().Analytics.addBreadCrumb('runSpecs', 'installing missing tester'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      await tester.install(scope, {
        verbose,
        dontPrintEnvMsg
      }, context);

      _logger().default.debug('Environment components are installed');
    }

    const testerFilePath = tester.filePath; // eslint-disable-next-line complexity

    const run = async (component, cwd) => {
      cwd = component._capsuleDir || cwd;

      if (cwd) {
        _logger().default.debug(`changing process cwd to ${cwd}`);

        _analytics().Analytics.addBreadCrumb('runSpecs.run', 'changing process cwd');

        process.chdir(cwd);
      }

      _loader().default.start(_loaderMessages().BEFORE_RUNNING_SPECS);

      const srcTestFilesList = component.files.filter(file => file.test);

      if ((0, _isEmpty2().default)(srcTestFilesList)) {
        return undefined;
      }

      let distTestFilesList;

      if (!component.dists.isEmpty()) {
        distTestFilesList = component.dists.get().filter(dist => dist.test);

        if ((0, _isEmpty2().default)(distTestFilesList)) {
          // We return here an empty array and not undefined to distinct between 2 cases:
          // 1. there are no tests defined at all during the add command
          // 2. there are test in the source files but not in the dist. this is usually a compiler bug that didn't return
          // the test=true flag on the dist vinyl.
          // It's a temp workaround, the real solution will be when running the build before and check it on a higher level
          return [];
        }
      }

      const testFilesList = distTestFilesList || srcTestFilesList;
      let specsResults;
      let tmpFolderFullPath;
      let contextPaths = {};

      if (this.tester && this.tester.context) {
        contextPaths = this.tester.context;
      } else if (consumer && consumer.bitMap) {
        contextPaths = {
          workspaceDir: consumer.bitMap.projectRoot
        };
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      if (!contextPaths.componentDir && component.writtenPath) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        contextPaths.componentDir = component.writtenPath;
      }

      try {
        // TODO: merge with the same function in build component file
        const isolateFunc = async ({
          targetDir,
          shouldBuildDependencies,
          installNpmPackages,
          keepExistingCapsule
        }) => {
          shouldBuildDependencies;
          const isolator = await _isolator().default.getInstance('fs', scope, consumer, targetDir);
          const componentWithDependencies = await isolator.isolate(component.id, {
            shouldBuildDependencies,
            writeDists: false,
            installNpmPackages,
            keepExistingCapsule
          });
          return new (_extensionIsolateResult().default)(isolator, componentWithDependencies);
        };

        if (tester && tester.action) {
          _logger().default.debug('running tests using new format');

          _analytics().Analytics.addBreadCrumb('runSpecs.run', 'running tests using new format');

          const context = {
            componentObject: component.toObject(),
            isolate: isolateFunc
          };
          contextPaths && Object.assign(context, contextPaths);
          const actionParams = {
            testFiles: testFilesList,
            rawConfig: tester.rawConfig,
            dynamicConfig: tester.dynamicConfig,
            api: tester.api,
            context
          };
          specsResults = await tester.action(actionParams);

          if (tmpFolderFullPath) {
            if (verbose) {
              console.log(`deleting tmp directory ${tmpFolderFullPath}`); // eslint-disable-line no-console
            }

            _logger().default.info(`consumer-component.runSpecs, deleting ${tmpFolderFullPath}`);

            await _fsExtra().default.remove(tmpFolderFullPath);
          }
        } else {
          _logger().default.debug('running tests using old format');

          _analytics().Analytics.addBreadCrumb('runSpecs.run', 'running tests using old format');

          const oneFileSpecResult = async testFile => {
            const testFilePath = testFile.path;

            try {
              var _component$componentM;

              const componentRootDir = (_component$componentM = component.componentMap) === null || _component$componentM === void 0 ? void 0 : _component$componentM.getTrackDir();
              let testFileRelative = testFile.relative;

              if (this.origin === _constants().COMPONENT_ORIGINS.AUTHORED && componentRootDir && testFileRelative.startsWith(componentRootDir)) {
                testFileRelative = path().relative(componentRootDir, testFileRelative);
              }

              const context = {
                /**
                 * @deprecated
                 * this is not the component dir, it's the workspace dir
                 */
                componentDir: cwd,

                /**
                 * absolute path of the component in the workspace.
                 * available only when is running inside the workspace and the component has either trackDir or rootDir
                 */
                componentRootDir: componentRootDir && cwd ? path().join(cwd, componentRootDir) : null,
                specFileRelativePath: testFileRelative,
                isolate: isolateFunc
              }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

              const results = await tester.oldAction(testFilePath, context);
              results.specPath = testFile.relative;
              return results;
            } catch (err) {
              const failures = [{
                title: err.message,
                err
              }];
              const results = {
                specPath: testFile.relative,
                pass: false,
                tests: [],
                failures
              };
              return results;
            }
          };

          const specsResultsP = testFilesList.map(oneFileSpecResult);
          specsResults = await Promise.all(specsResultsP);
        }
      } catch (e) {
        if (tmpFolderFullPath) {
          _logger().default.info(`consumer-component.runSpecs, deleting ${tmpFolderFullPath}`);

          _fsExtra().default.removeSync(tmpFolderFullPath);
        }

        const errors = e.errors || [e];
        const err = new (_externalTestErrors().default)(component.id.toString(), errors);
        throw err;
      }

      this.specsResults = specsResults.map(specRes => _specsResults().default.createFromRaw(specRes));

      if (rejectOnFailure && !this.specsResults.every(element => element.pass)) {
        // some or all the tests were failed.
        _loader().default.stop();

        if (verbose) {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          return Promise.reject(new (_componentSpecsFailed().default)(this.id.toString(), this.specsResults));
        } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        return Promise.reject(new (_componentSpecsFailed().default)());
      }

      if (save) {
        await scope.sources.modifySpecsResults({
          source: this,
          specsResults: this.specsResults
        });
      }

      return this.specsResults;
    };

    if (!isolated && consumer) {
      // we got here from either bit-tag or bit-test. either way we executed already the build process
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return run(this, consumer.getPath());
    }

    const isolatedEnvironment = new (_environment().default)(scope, directory);

    try {
      await isolatedEnvironment.create();
      const isolateOpts = {
        verbose,
        writeDists: true,
        installNpmPackages: true,
        installPeerDependencies: true,
        writePackageJson: true
      };
      const localTesterPath = path().join(isolatedEnvironment.getPath(), 'tester'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const componentWithDependencies = await isolatedEnvironment.isolateComponent(this.id, isolateOpts);
      (0, _createSymlinkOrCopy().default)(testerFilePath, localTesterPath);
      const component = componentWithDependencies.component;
      component.isolatedEnvironment = isolatedEnvironment;

      _logger().default.debug(`the component ${this.id.toString()} has been imported successfully into an isolated environment`);

      await component.build({
        scope,
        verbose
      });

      if (!component.dists.isEmpty()) {
        const specDistWrite = component.dists.get().map(file => file.write());
        await Promise.all(specDistWrite);
      }

      const results = await run(component);
      if (!keep) await isolatedEnvironment.destroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return results;
    } catch (e) {
      if (!keep) await isolatedEnvironment.destroy();
      return Promise.reject(e);
    }
  }

  async isolate(scope, opts) {
    const isolatedEnvironment = new (_environment().default)(scope, opts.writeToPath);

    try {
      await isolatedEnvironment.create();
      await isolatedEnvironment.isolateComponent(this.id, opts);
      return isolatedEnvironment.path;
    } catch (err) {
      await isolatedEnvironment.destroy();
      throw new (_generalError().default)(err);
    }
  }

  toObject() {
    return {
      name: this.name,
      version: this.version,
      mainFile: this.mainFile,
      scope: this.scope,
      lang: this.lang,
      bindingPrefix: this.bindingPrefix,
      compiler: this.compiler ? this.compiler.toObject() : null,
      tester: this.tester ? this.tester.toObject() : null,
      dependencies: this.dependencies.serialize(),
      devDependencies: this.devDependencies.serialize(),
      extensions: this.extensions.map(ext => {
        const res = Object.assign({}, ext.toComponentObject());
        return res;
      }),
      packageDependencies: this.packageDependencies,
      devPackageDependencies: this.devPackageDependencies,
      peerPackageDependencies: this.peerPackageDependencies,
      compilerPackageDependencies: this.compilerPackageDependencies,
      testerPackageDependencies: this.testerPackageDependencies,
      manuallyRemovedDependencies: this.manuallyRemovedDependencies,
      manuallyAddedDependencies: this.manuallyAddedDependencies,
      overrides: this.overrides.componentOverridesData,
      files: this.files,
      docs: this.docs,
      schema: this.schema,
      dists: this.dists,
      specsResults: this.specsResults ? this.specsResults.map(res => res.serialize()) : null,
      license: this.license ? this.license.serialize() : null,
      log: this.log,
      deprecated: this.deprecated
    };
  }

  toString() {
    return JSON.stringify(this.toObject());
  }

  copyFilesIntoDists() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const dists = this.files.map(file => new (_sources().Dist)({
      base: file.base,
      path: file.path,
      contents: file.contents
    }));
    this.setDists(dists);
  }

  setOriginallySharedDir(manipulateDirData) {
    const manipulateDirItem = manipulateDirData.find(m => m.id.isEqual(this.id));

    if (manipulateDirItem) {
      this.originallySharedDir = manipulateDirItem.originallySharedDir;
    }
  }

  static isComponentInvalidByErrorType(err) {
    const invalidComponentErrors = [_mainFileRemoved().default, _missingFilesFromComponent().default, _componentNotFoundInPath().default, _componentOutOfSync().default, _componentsPendingImport().default, _extensionFileNotFound().default, _noComponentDir().NoComponentDir, _ignoredDirectory().IgnoredDirectory];
    return invalidComponentErrors.some(errorType => err instanceof errorType);
  }

  async toComponentWithDependencies(consumer) {
    const getFlatten = field => {
      // when loaded from filesystem, it doesn't have the flatten, fetch them from model.
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.loadedFromFileSystem ? this.componentFromModel[field] : this[field];
    };

    const getDependenciesComponents = ids => {
      return Promise.all(ids.map(dependencyId => {
        if (consumer.bitMap.isExistWithSameVersion(dependencyId)) {
          return consumer.loadComponent(dependencyId);
        } // when dependencies are imported as npm packages, they are not in bit.map


        this.dependenciesSavedAsComponents = false;
        return consumer.loadComponentFromModel(dependencyId);
      }));
    };

    const dependencies = await getDependenciesComponents(getFlatten('flattenedDependencies'));
    return new (_componentDependencies().default)({
      component: this,
      dependencies,
      devDependencies: [],
      extensionDependencies: []
    });
  }

  copyAllDependenciesFromModel() {
    const componentFromModel = this.componentFromModel;
    if (!componentFromModel) throw new Error('copyDependenciesFromModel: component is missing from the model');
    this.setDependencies(componentFromModel.dependencies.get());
    this.setDevDependencies(componentFromModel.devDependencies.get());
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  static async fromObject(object) {
    const {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      name,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      box,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      version,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      scope,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      lang,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      compiler,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      tester,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      devDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      devPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      peerPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      compilerPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      testerPackageDependencies,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      docs,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      mainFile,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dists,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      files,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      specsResults,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      license,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      deprecated,
      schema
    } = object;
    const compilerProps = compiler ? await _compilerExtension().default.loadFromSerializedModelObject(compiler) : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const compilerInstance = compilerProps ? await (0, _envFactory().default)(_constants().COMPILER_ENV_TYPE, compilerProps) : null;
    const testerProps = tester ? await _testerExtension().default.loadFromSerializedModelObject(tester) : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const testerInstance = testerProps ? await (0, _envFactory().default)(_constants().TESTER_ENV_TYPE, testerProps) : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return new Component({
      name: box ? `${box}/${name}` : name,
      version,
      scope,
      lang,
      bindingPrefix,
      // @ts-ignore
      compiler: compilerInstance,
      // @ts-ignore
      tester: testerInstance,
      dependencies,
      devDependencies,
      packageDependencies,
      devPackageDependencies,
      peerPackageDependencies,
      compilerPackageDependencies,
      testerPackageDependencies,
      mainFile,
      files,
      docs,
      dists,
      specsResults: specsResults ? _specsResults().default.deserialize(specsResults) : undefined,
      license: license ? _sources().License.deserialize(license) : undefined,
      overrides: new (_componentOverrides().default)(overrides),
      deprecated: deprecated || false,
      schema
    });
  }

  static async fromString(str) {
    const object = JSON.parse(str);
    object.files = _sources().SourceFile.loadFromParsedStringArray(object.files); // added if statement to support new and old version of remote ls
    // old version of bit returns from server array of dists  and new version return object

    if (object.dists && Array.isArray(object.dists)) {
      object.dists = _sources().Dist.loadFromParsedStringArray(object.dists);
    } else if (object.dists && object.dists.dists) {
      object.dists = _sources().Dist.loadFromParsedStringArray(object.dists.dists);
    }

    return this.fromObject(object);
  } // eslint-disable-next-line complexity


  static async loadFromFileSystem({
    bitDir,
    componentMap,
    id,
    consumer
  }) {
    const consumerPath = consumer.getPath();
    const workspaceConfig = consumer.config;
    const componentFromModel = await consumer.loadComponentFromModelIfExist(id);

    if (!componentFromModel && id.scope) {
      const inScopeWithAnyVersion = await consumer.scope.getModelComponentIfExist(id.changeVersion(undefined)); // if it's in scope with another version, the component will be synced in _handleOutOfSyncScenarios()

      if (!inScopeWithAnyVersion) throw new (_componentsPendingImport().default)();
    }

    const deprecated = componentFromModel ? componentFromModel.deprecated : false;
    const componentDir = componentMap.getComponentDir();
    let dists = componentFromModel ? componentFromModel.dists.get() : undefined;
    const mainDistFile = componentFromModel ? componentFromModel.dists.getMainDistFile() : undefined;
    if (!_fsExtra().default.existsSync(bitDir)) throw new (_componentNotFoundInPath().default)(bitDir); // Load the base entry from the root dir in map file in case it was imported using -path
    // Or created using bit create so we don't want all the path but only the relative one
    // Check that bitDir isn't the same as consumer path to make sure we are not loading global stuff into component
    // (like dependencies)

    _logger().default.trace(`consumer-component.loadFromFileSystem, start loading config ${id.toString()}`);

    const componentConfig = await _config().default.load({
      consumer,
      componentId: id,
      componentDir,
      workspaceDir: consumerPath,
      workspaceConfig
    });

    _logger().default.trace(`consumer-component.loadFromFileSystem, finish loading config ${id.toString()}`); // by default, imported components are not written with bit.json file.
    // use the component from the model to get their bit.json values


    if (componentFromModel) {
      componentConfig.mergeWithComponentData(componentFromModel);
    }

    const extensions = componentConfig.extensions;
    const envsContext = {
      componentDir: bitDir,
      workspaceDir: consumerPath
    }; // TODO: change this once we want to support change export by changing the default scope
    // TODO: when we do this, we need to think how we distinct if this is the purpose of the user, or he just didn't changed it

    const bindingPrefix = (componentFromModel === null || componentFromModel === void 0 ? void 0 : componentFromModel.bindingPrefix) || componentConfig.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;

    const overridesFromModel = componentFromModel ? componentFromModel.overrides.componentOverridesData : undefined;
    const overrides = await _componentOverrides().default.loadFromConsumer(id, workspaceConfig, overridesFromModel, componentConfig, componentMap.origin, consumer.isLegacy);
    const propsToLoadEnvs = {
      consumerPath,
      envType: _constants().COMPILER_ENV_TYPE,
      scopePath: consumer.scope.getPath(),
      componentOrigin: componentMap.origin,
      componentFromModel,
      overrides,
      workspaceConfig,
      componentConfig,
      context: envsContext
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const compilerP = _envExtension().default.loadFromCorrectSource(propsToLoadEnvs);

    propsToLoadEnvs.envType = _constants().TESTER_ENV_TYPE; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const testerP = _envExtension().default.loadFromCorrectSource(propsToLoadEnvs);

    const [compiler, tester] = await Promise.all([compilerP, testerP]); // load the compilerPackageDependencies/testerPackageDependencies from the actual compiler/tester
    // if they're not installed, load them from the model

    const compilerDynamicPackageDependencies = compiler && compiler.loaded ? compiler.dynamicPackageDependencies : {};
    const modelCompilerPackageDependencies = componentFromModel ? componentFromModel.compilerPackageDependencies || {} : {};
    const compilerPackageDependencies = (0, _isEmpty2().default)(compilerDynamicPackageDependencies) ? modelCompilerPackageDependencies : compilerDynamicPackageDependencies;
    const testerDynamicPackageDependencies = tester && tester.loaded ? tester.dynamicPackageDependencies : {};
    const modelTesterPackageDependencies = componentFromModel ? componentFromModel.testerPackageDependencies || {} : {};
    const testerPackageDependencies = (0, _isEmpty2().default)(testerDynamicPackageDependencies) ? modelTesterPackageDependencies : testerDynamicPackageDependencies;
    const packageJsonFile = componentConfig && componentConfig.packageJsonFile || undefined;
    const packageJsonChangedProps = componentFromModel ? componentFromModel.packageJsonChangedProps : undefined;
    const files = consumer.isLegacy ? await getLoadedFilesLegacy(consumer, componentMap, id, bitDir) : await getLoadedFilesHarmony(consumer, componentMap, id, bitDir);

    const docsP = _getDocsForFiles(files, consumer.componentFsCache);

    const docs = await Promise.all(docsP);
    const flattenedDocs = docs ? (0, _flatten2().default)(docs) : []; // remove dists if compiler has been deleted

    if (dists && !compiler) {
      dists = undefined;
    }

    const defaultScope = componentConfig.defaultScope || null;

    const getSchema = () => {
      if (componentFromModel) return componentFromModel.schema;
      return consumer.isLegacy ? undefined : _componentSchema().CURRENT_SCHEMA;
    };

    return new Component({
      name: id.name,
      scope: id.scope,
      version: id.version,
      lang: componentConfig.lang,
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      compiler,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      tester,
      bitJson: componentConfig,
      mainFile: componentMap.mainFile,
      files,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      loadedFromFileSystem: true,
      componentFromModel,
      componentMap,
      dists,
      docs: flattenedDocs,
      mainDistFile: mainDistFile ? path().normalize(mainDistFile) : undefined,
      compilerPackageDependencies,
      testerPackageDependencies,
      deprecated,
      origin: componentMap.origin,
      overrides,
      schema: getSchema(),
      defaultScope,
      packageJsonFile,
      packageJsonChangedProps,
      extensions,
      buildStatus: componentFromModel ? componentFromModel.buildStatus : undefined
    });
  }

}

exports.default = Component;

async function getLoadedFilesLegacy(consumer, componentMap, id, bitDir) {
  const bitMap = consumer.bitMap;
  const sourceFiles = [];
  await componentMap.trackDirectoryChangesLegacy(consumer, id);
  const filesToDelete = [];
  componentMap.files.forEach(file => {
    const filePath = path().join(bitDir, file.relativePath);

    try {
      const sourceFile = _sources().SourceFile.load(filePath, bitDir, consumer.getPath(), {
        test: file.test
      }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      sourceFiles.push(sourceFile);
    } catch (err) {
      if (!(err instanceof _fileSourceNotFound().default)) throw err;

      _logger().default.warn(`a file ${filePath} will be deleted from bit.map as it does not exist on the file system`); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      filesToDelete.push(file);
    }
  });

  if (filesToDelete.length) {
    if (!sourceFiles.length) throw new (_missingFilesFromComponent().default)(id.toString());
    filesToDelete.forEach(fileToDelete => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (fileToDelete.relativePath === componentMap.mainFile) {
        throw new (_mainFileRemoved().default)(componentMap.mainFile, id.toString());
      }
    });
    componentMap.removeFiles(filesToDelete);
    bitMap.hasChanged = true;
  }

  const filePaths = componentMap.getAllFilesPaths();

  if (!filePaths.includes(componentMap.mainFile)) {
    throw new (_mainFileRemoved().default)(componentMap.mainFile, id.toString());
  }

  return sourceFiles;
}

async function getLoadedFilesHarmony(consumer, componentMap, id, bitDir) {
  if (componentMap.noFilesError) {
    throw componentMap.noFilesError;
  }

  await componentMap.trackDirectoryChangesHarmony(consumer, id);
  const sourceFiles = componentMap.files.map(file => {
    const filePath = path().join(bitDir, file.relativePath);

    const sourceFile = _sources().SourceFile.load(filePath, bitDir, consumer.getPath(), {
      test: file.test
    });

    return sourceFile;
  });
  const filePaths = componentMap.getAllFilesPaths();

  if (!filePaths.includes(componentMap.mainFile)) {
    throw new (_mainFileRemoved().default)(componentMap.mainFile, id.toString());
  }

  return sourceFiles;
}

function _getDocsForFiles(files, componentFsCache) {
  return files.map(file => file.test ? Promise.resolve([]) : (0, _parser().default)(file, componentFsCache));
}