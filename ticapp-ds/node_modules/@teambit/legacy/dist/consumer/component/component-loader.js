"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _cacheFactory() {
  const data = require("../../cache/cache-factory");

  _cacheFactory = function () {
    return data;
  };

  return data;
}

function _inMemoryCache() {
  const data = require("../../cache/in-memory-cache");

  _inMemoryCache = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../scope/component-ops/scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _lastModified() {
  const data = require("../../utils/fs/last-modified");

  _lastModified = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("../component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _consumerComponent() {
  const data = _interopRequireDefault(require("../component/consumer-component"));

  _consumerComponent = function () {
    return data;
  };

  return data;
}

function _componentFsCache() {
  const data = require("./component-fs-cache");

  _componentFsCache = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("./dependencies/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _dependenciesLoader() {
  const data = require("./dependencies/dependency-resolver/dependencies-loader");

  _dependenciesLoader = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class ComponentLoader {
  // cache loaded components
  // cache loaded components for capsule, must not use the cache for the workspace
  // specific platforms may need to parse the entire project. (was used for Angular, currently not in use)
  constructor(consumer) {
    (0, _defineProperty2().default)(this, "componentsCache", void 0);
    (0, _defineProperty2().default)(this, "componentsCacheForCapsule", void 0);
    (0, _defineProperty2().default)(this, "_shouldCheckForClearingDependenciesCache", true);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "cacheResolvedDependencies", void 0);
    (0, _defineProperty2().default)(this, "cacheProjectAst", void 0);
    (0, _defineProperty2().default)(this, "componentFsCache", void 0);
    this.consumer = consumer;
    this.cacheResolvedDependencies = {};
    this.componentFsCache = new (_componentFsCache().ComponentFsCache)(consumer.scope.getPath());
    this.componentsCache = (0, _cacheFactory().createInMemoryCache)({
      maxSize: (0, _inMemoryCache().getMaxSizeForComponents)()
    });
    this.componentsCacheForCapsule = (0, _cacheFactory().createInMemoryCache)({
      maxSize: (0, _inMemoryCache().getMaxSizeForComponents)()
    });
  }

  static registerOnComponentLoadSubscriber(func) {
    this.onComponentLoadSubscribers.push(func);
  }

  clearComponentsCache() {
    this.componentsCache.deleteAll();
    this.componentsCacheForCapsule.deleteAll();
    this.cacheResolvedDependencies = {};
    this._shouldCheckForClearingDependenciesCache = true;
  }

  clearOneComponentCache(id) {
    const idStr = id.toString();
    this.componentsCache.delete(idStr);
    this.componentsCacheForCapsule.delete(idStr);
    this.cacheResolvedDependencies = {};
  }

  async invalidateDependenciesCacheIfNeeded() {
    if (this._shouldCheckForClearingDependenciesCache) {
      const pathsToCheck = [path().join(this.consumer.getPath(), 'node_modules'), path().join(this.consumer.getPath(), 'package.json'), path().join(this.consumer.getPath(), _constants().BIT_MAP), this.consumer.config.path];
      const lastModified = await (0, _lastModified().getLastModifiedPathsTimestampMs)(pathsToCheck);
      const dependenciesCacheList = await this.componentFsCache.listDependenciesDataCache();
      const lastUpdateAllComps = Object.keys(dependenciesCacheList).map(key => dependenciesCacheList[key].time);
      const firstCacheEntered = Math.min(...lastUpdateAllComps); // if lastUpdateAllComps is empty, firstCacheEntered is Infinity so shouldInvalidate is
      // always false, which is good. no need to invalidate the cache if nothing there.

      const shouldInvalidate = lastModified > firstCacheEntered;

      if (shouldInvalidate) {
        // at least one component inserted to the cache before workspace-config/node-modules
        // modification, invalidate the entire deps-cache.
        _logger().default.debug('component-loader, invalidating dependencies cache because either node-modules or workspace config had been changed');

        await this.componentFsCache.deleteAllDependenciesDataCache();
      }
    }

    this._shouldCheckForClearingDependenciesCache = false;
  }

  async loadForCapsule(id) {
    _logger().default.debugAndAddBreadCrumb('ComponentLoader', 'loadForCapsule, id: {id}', {
      id: id.toString()
    });

    const idWithVersion = (0, _utils().getLatestVersionNumber)(this.consumer.bitmapIdsFromCurrentLane, id);
    const idStr = idWithVersion.toString();

    if (!this.componentsCacheForCapsule.has(idStr)) {
      const {
        components
      } = await this.loadMany(_bitId().BitIds.fromArray([id]));
      const component = components[0].clone();
      this.componentsCacheForCapsule.set(idStr, component);
    }

    _logger().default.debugAndAddBreadCrumb('ComponentLoader', 'loadForCapsule finished loading the component "{id}"', {
      id: id.toString()
    });

    return this.componentsCacheForCapsule.get(idStr);
  }

  async loadMany(ids, throwOnFailure = true) {
    _logger().default.debugAndAddBreadCrumb('ComponentLoader', 'loading consumer-components from the file-system, ids: {ids}', {
      ids: ids.toString()
    });

    const alreadyLoadedComponents = [];
    const idsToProcess = [];
    const invalidComponents = [];
    ids.forEach(id => {
      if (id.constructor.name !== _bitId().BitId.name) {
        throw new TypeError(`consumer.loadComponents expects to get BitId instances, instead, got "${typeof id}"`);
      }

      const idWithVersion = (0, _utils().getLatestVersionNumber)(this.consumer.bitmapIdsFromCurrentLane, id);
      const idStr = idWithVersion.toString();
      const fromCache = this.componentsCache.get(idStr);

      if (fromCache) {
        alreadyLoadedComponents.push(fromCache);
      } else {
        idsToProcess.push(idWithVersion);
      }
    });

    _logger().default.debugAndAddBreadCrumb('ComponentLoader', `the following ${alreadyLoadedComponents.length} components have been already loaded, get them from the cache. {idsStr}`, {
      idsStr: alreadyLoadedComponents.map(c => c.id.toString()).join(', ')
    });

    if (!idsToProcess.length) return {
      components: alreadyLoadedComponents,
      invalidComponents
    };
    const allComponents = [];
    await (0, _pMapSeries().default)(idsToProcess, async id => {
      const component = await this.loadOne(id, throwOnFailure, invalidComponents);

      if (component) {
        this.componentsCache.set(component.id.toString(), component);

        _logger().default.debugAndAddBreadCrumb('ComponentLoader', 'Finished loading the component "{id}"', {
          id: component.id.toString()
        });

        allComponents.push(component);
      }
    });
    return {
      components: allComponents.concat(alreadyLoadedComponents),
      invalidComponents
    };
  }

  async loadOne(id, throwOnFailure, invalidComponents) {
    const componentMap = this.consumer.bitMap.getComponent(id);
    let bitDir = this.consumer.getPath();

    if (componentMap.rootDir) {
      bitDir = path().join(bitDir, componentMap.rootDir);
    }

    let component;

    const handleError = error => {
      if (throwOnFailure) throw error;

      _logger().default.errorAndAddBreadCrumb('component-loader.loadOne', 'failed loading {id} from the file-system', {
        id: id.toString()
      });

      if (_consumerComponent().default.isComponentInvalidByErrorType(error)) {
        invalidComponents.push({
          id,
          error,
          component
        });
        return null;
      }

      throw error;
    };

    try {
      component = await _consumerComponent().default.loadFromFileSystem({
        bitDir,
        componentMap,
        id,
        consumer: this.consumer
      });
    } catch (err) {
      return handleError(err);
    }

    component.loadedFromFileSystem = true;
    component.originallySharedDir = componentMap.originallySharedDir || undefined;
    component.wrapDir = componentMap.wrapDir || undefined; // reload component map as it may be changed after calling Component.loadFromFileSystem()

    component.componentMap = this.consumer.bitMap.getComponent(id);
    await this._handleOutOfSyncScenarios(component);
    await this.addComponentIssues(component);

    const loadDependencies = async () => {
      await this.invalidateDependenciesCacheIfNeeded();
      const dependenciesLoader = new (_dependenciesLoader().DependenciesLoader)(component, this.consumer, {
        cacheResolvedDependencies: this.cacheResolvedDependencies,
        cacheProjectAst: this.cacheProjectAst,
        useDependenciesCache: component.issues.isEmpty()
      });
      await dependenciesLoader.load();
      (0, _dependencyResolver().updateDependenciesVersions)(this.consumer, component);
    };

    const runOnComponentLoadEvent = async () => {
      return (0, _pMapSeries().default)(ComponentLoader.onComponentLoadSubscribers, async subscriber => {
        component = await subscriber(component);
      });
    };

    try {
      await loadDependencies();
      await runOnComponentLoadEvent();
    } catch (err) {
      return handleError(err);
    }

    return component;
  }

  async addComponentIssues(component) {
    if (this.consumer.isLegacy) return;
    const pkgName = (0, _componentIdToPackageName().default)(component);
    const pkgDir = path().join(this.consumer.getPath(), 'node_modules', pkgName);
    const distDir = path().join(pkgDir, _constants().DEFAULT_DIST_DIRNAME);
    const distExists = await _fsExtra().default.pathExists(distDir);
    if (distExists) return;
    component.issues.getOrCreate(_componentIssues().IssuesClasses.MissingDists).data = true;
    const pkgDirExist = await _fsExtra().default.pathExists(pkgDir);

    if (!pkgDirExist) {
      component.issues.getOrCreate(_componentIssues().IssuesClasses.MissingLinksFromNodeModulesToSrc).data = true;
    }
  }

  async _handleOutOfSyncScenarios(component) {
    const {
      componentFromModel,
      componentMap
    } = component; // $FlowFixMe componentMap is set here
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const currentId = componentMap.id;
    let newId;

    if (componentFromModel && !currentId.hasVersion()) {
      // component is in the scope but .bitmap doesn't have version, sync .bitmap with the scope data
      newId = currentId.changeVersion(componentFromModel.version);
      if (componentFromModel.scope) newId = newId.changeScope(componentFromModel.scope);
    }

    if (componentFromModel && componentFromModel.scope && currentId.hasVersion() && !currentId.hasScope()) {
      // component is not exported in .bitmap but exported in the scope, sync .bitmap with the scope data
      newId = currentId.changeScope(componentFromModel.scope);
    }

    if (!componentFromModel && currentId.hasVersion()) {
      // the version used in .bitmap doesn't exist in the scope
      const modelComponent = await this.consumer.scope.getModelComponentIfExist(currentId.changeVersion(undefined));

      if (modelComponent) {
        // the scope has this component but not the version used in .bitmap, sync .bitmap with
        // latest version from the scope
        await this._throwPendingImportIfNeeded(currentId);
        newId = currentId.changeVersion(modelComponent.latest());
        component.componentFromModel = await this.consumer.loadComponentFromModelIfExist(newId);
      } else if (!currentId.hasScope()) {
        // the scope doesn't have this component and .bitmap doesn't have scope, assume it's new
        newId = currentId.changeVersion(undefined);
      }
    }

    if (!componentFromModel && !currentId.hasVersion() && component.defaultScope) {
      // for Harmony, we know ahead the defaultScope, so even then .bitmap shows it as new and
      // there is nothing in the scope, we can check if there is a component with the same
      // default-scope in the objects
      const modelComponent = await this.consumer.scope.getModelComponentIfExist(currentId.changeScope(component.defaultScope));

      if (modelComponent) {
        newId = currentId.changeVersion(modelComponent.latest()).changeScope(modelComponent.scope);
        component.componentFromModel = await this.consumer.loadComponentFromModelIfExist(newId);
      }
    }

    if (newId) {
      component.version = newId.version;
      component.scope = newId.scope;
      this.consumer.bitMap.updateComponentId(newId);
      component.componentMap = this.consumer.bitMap.getComponent(newId);
    }
  }

  async _throwPendingImportIfNeeded(currentId) {
    if (currentId.hasScope()) {
      const remoteComponent = await this._getRemoteComponent(currentId); // @todo-lanes: make it work with lanes. It needs to go through the objects one by one and check
      // whether one of the hashes exist.
      // @ts-ignore version is set here

      if (remoteComponent && remoteComponent.hasTag(currentId.version)) {
        throw new (_componentsPendingImport().default)();
      }
    }
  }

  async _getRemoteComponent(id) {
    const scopeComponentsImporter = new (_scopeComponentsImporter().default)(this.consumer.scope);
    const objectList = await scopeComponentsImporter.getRemoteComponent(id);
    if (!objectList) return null;
    const components = objectList.getComponents();
    if (!components.length) return null; // probably doesn't exist

    return components[0];
  }

  _isAngularProject() {
    return Boolean(this.consumer.packageJson && // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.consumer.packageJson.dependencies && // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.consumer.packageJson.dependencies[_constants().ANGULAR_PACKAGE_IDENTIFIER]);
  }

  static getInstance(consumer) {
    return new ComponentLoader(consumer);
  }

}

exports.default = ComponentLoader;
(0, _defineProperty2().default)(ComponentLoader, "onComponentLoadSubscribers", []);