"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addComponentsToRoot = addComponentsToRoot;
exports.addComponentsWithVersionToRoot = addComponentsWithVersionToRoot;
exports.addWorkspacesToPackageJson = addWorkspacesToPackageJson;
exports.changeDependenciesToRelativeSyntax = changeDependenciesToRelativeSyntax;
exports.convertToValidPathForPackageManager = convertToValidPathForPackageManager;
exports.preparePackageJsonToWrite = preparePackageJsonToWrite;
exports.removeComponentsFromNodeModules = removeComponentsFromNodeModules;
exports.removeComponentsFromWorkspacesAndDependencies = removeComponentsFromWorkspacesAndDependencies;
exports.updateAttribute = updateAttribute;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fromPairs2() {
  const data = _interopRequireDefault(require("ramda/src/fromPairs"));

  _fromPairs2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _searchFilesIgnoreExt() {
  const data = _interopRequireDefault(require("../../utils/fs/search-files-ignore-ext"));

  _searchFilesIgnoreExt = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("../../utils/path");

  _path = function () {
    return data;
  };

  return data;
}

function _packageJson() {
  const data = _interopRequireDefault(require("./package-json"));

  _packageJson = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("./package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Add components as dependencies to root package.json
 */
async function addComponentsToRoot(consumer, components) {
  const componentsToAdd = components.reduce((acc, component) => {
    const componentMap = consumer.bitMap.getComponent(component.id);
    if (componentMap.origin !== _constants().COMPONENT_ORIGINS.IMPORTED) return acc;

    if (!componentMap.rootDir) {
      throw new (_showDoctorError().default)(`rootDir is missing from an imported component ${component.id.toString()}`);
    }

    const locationAsUnixFormat = convertToValidPathForPackageManager(componentMap.rootDir);
    const packageName = (0, _componentIdToPackageName().default)(component);
    acc[packageName] = locationAsUnixFormat;
    return acc;
  }, {});
  if ((0, _isEmpty2().default)(componentsToAdd)) return;
  await _addDependenciesPackagesIntoPackageJson(consumer.getPath(), componentsToAdd);
}

async function addComponentsWithVersionToRoot(consumer, components) {
  const componentsToAdd = (0, _fromPairs2().default)(components.map(component => {
    const packageName = (0, _componentIdToPackageName().default)(component);
    return [packageName, component.version];
  }));
  await _addDependenciesPackagesIntoPackageJson(consumer.getPath(), componentsToAdd);
}

async function changeDependenciesToRelativeSyntax(consumer, components, dependencies) {
  const dependenciesIds = _bitId().BitIds.fromArray(dependencies.map(dependency => dependency.id));

  const updateComponentPackageJson = async component => {
    const componentMap = consumer.bitMap.getComponent(component.id);
    const componentRootDir = componentMap.rootDir;
    if (!componentRootDir) return null;
    const packageJsonFile = await _packageJsonFile().default.load(consumer.getPath(), componentRootDir);
    if (!packageJsonFile.fileExist) return null; // if package.json doesn't exist no need to update anything

    const devDeps = getPackages(component.devDependencies.getAllIds(), componentMap);
    const extensionDeps = getPackages(component.extensions.extensionsBitIds, componentMap);
    packageJsonFile.addDependencies(getPackages(component.dependencies.getAllIds(), componentMap));
    packageJsonFile.addDevDependencies(_objectSpread(_objectSpread({}, devDeps), extensionDeps));
    return packageJsonFile.toVinylFile();
  };

  const packageJsonFiles = await Promise.all(components.map(component => updateComponentPackageJson(component))); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  return packageJsonFiles.filter(file => file);

  function getPackages(deps, componentMap) {
    return deps.reduce((acc, dependencyId) => {
      const dependencyIdStr = dependencyId.toStringWithoutVersion();

      if (dependenciesIds.searchWithoutVersion(dependencyId)) {
        const dependencyComponent = dependencies.find(d => d.id.isEqualWithoutVersion(dependencyId));

        if (!dependencyComponent) {
          throw new Error('getDependenciesAsPackages, dependencyComponent is missing');
        }

        const dependencyComponentMap = consumer.bitMap.getComponentIfExist(dependencyComponent.id); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        const dependencyPackageValue = getPackageDependencyValue(dependencyIdStr, componentMap, dependencyComponentMap);

        if (dependencyPackageValue) {
          const packageName = (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({}, dependencyComponent), {}, {
            id: dependencyId
          }));
          acc[packageName] = dependencyPackageValue;
        }
      }

      return acc;
    }, {});
  }
}

function preparePackageJsonToWrite(bitMap, component, bitDir, override = true, ignoreBitDependencies = true, excludeRegistryPrefix, packageManager, isIsolated) {
  _logger().default.debug(`package-json.preparePackageJsonToWrite. bitDir ${bitDir}. override ${override.toString()}`);

  const getBitDependencies = dependencies => {
    if (ignoreBitDependencies === true) return {};
    return dependencies.reduce((acc, depId) => {
      if (Array.isArray(ignoreBitDependencies) && ignoreBitDependencies.searchWithoutVersion(depId)) return acc;
      const packageDependency = getPackageDependency(bitMap, depId, component.id);
      const packageName = (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({}, component), {}, {
        id: depId,
        isDependency: true
      }));
      acc[packageName] = packageDependency;
      return acc;
    }, {});
  };

  const bitDependencies = getBitDependencies(component.dependencies.getAllIds());
  const bitDevDependencies = getBitDependencies(component.devDependencies.getAllIds());
  const bitExtensionDependencies = getBitDependencies(component.extensions.extensionsBitIds);

  const packageJson = _packageJsonFile().default.createFromComponent(bitDir, component, excludeRegistryPrefix, isIsolated);

  const main = (0, _path().pathNormalizeToLinux)(component.dists.calculateMainDistFile(component.mainFile));
  packageJson.addOrUpdateProperty('main', main);

  const addDependencies = packageJsonFile => {
    packageJsonFile.addDependencies(bitDependencies);
    packageJsonFile.addDevDependencies(_objectSpread(_objectSpread({}, bitDevDependencies), bitExtensionDependencies));
  };

  packageJson.setPackageManager(packageManager);
  addDependencies(packageJson);
  let distPackageJson;

  if (!component.dists.isEmpty() && !component.dists.areDistsInsideComponentDir) {
    const distRootDir = component.dists.distsRootDir;
    if (!distRootDir) throw new Error('component.dists.distsRootDir is not defined yet');
    distPackageJson = _packageJsonFile().default.createFromComponent(distRootDir, component, excludeRegistryPrefix, isIsolated);
    const distMainFile = (0, _searchFilesIgnoreExt().default)(component.dists.get(), component.mainFile, 'relative');
    distPackageJson.addOrUpdateProperty('main', component.dists.getMainDistFile() || distMainFile);
    addDependencies(distPackageJson);
  }

  return {
    packageJson,
    distPackageJson
  };
}

async function updateAttribute(consumer, componentDir, attributeName, attributeValue) {
  const packageJsonFile = await _packageJsonFile().default.load(consumer.getPath(), componentDir);
  if (!packageJsonFile.fileExist) return; // package.json doesn't exist, that's fine, no need to update anything

  packageJsonFile.addOrUpdateProperty(attributeName, attributeValue);
  await packageJsonFile.write();
}
/**
 * Adds workspace array to package.json - only if user wants to work with yarn workspaces
 */


async function addWorkspacesToPackageJson(consumer, customImportPath) {
  if (consumer.config._manageWorkspaces && consumer.config.packageManager === 'yarn' && consumer.config._useWorkspaces) {
    const rootDir = consumer.getPath();
    const dependenciesDirectory = consumer.config._dependenciesDirectory;
    const {
      componentsDefaultDirectory
    } = consumer.dirStructure;
    await _packageJson().default.addWorkspacesToPackageJson(rootDir, componentsDefaultDirectory + _constants().SUB_DIRECTORIES_GLOB_PATTERN, dependenciesDirectory + _constants().SUB_DIRECTORIES_GLOB_PATTERN, customImportPath ? consumer.getPathRelativeToConsumer(customImportPath) : customImportPath);
  }
}

async function removeComponentsFromWorkspacesAndDependencies(consumer, components, invalidComponents = []) {
  const bitIds = [...components.map(c => c.id), ...invalidComponents];
  const rootDir = consumer.getPath();

  if (consumer.config._manageWorkspaces && consumer.config.packageManager === 'yarn' && consumer.config._useWorkspaces) {
    const dirsToRemove = bitIds.map(id => consumer.bitMap.getComponent(id, {
      ignoreVersion: true
    }).rootDir);

    if (dirsToRemove && dirsToRemove.length) {
      const dirsToRemoveWithoutEmpty = (0, _lodash().compact)(dirsToRemove);
      await _packageJson().default.removeComponentsFromWorkspaces(rootDir, dirsToRemoveWithoutEmpty);
    }
  }

  await _packageJson().default.removeComponentsFromDependencies(rootDir, components);
  await removeComponentsFromNodeModules(consumer, components);
}

async function _addDependenciesPackagesIntoPackageJson(dir, dependencies) {
  const packageJsonFile = await _packageJsonFile().default.load(dir);
  packageJsonFile.addDependencies(dependencies);
  await packageJsonFile.write();
}

async function removeComponentsFromNodeModules(consumer, components) {
  _logger().default.debug(`removeComponentsFromNodeModules: ${components.map(c => c.id.toString()).join(', ')}`);

  const pathsToRemoveWithNulls = components.map(c => {
    // for legacy, paths without scope name, don't have a symlink in node-modules
    if (consumer.isLegacy) return c.id.scope ? (0, _componentNodeModulesPath().default)(c) : null;
    return (0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, c), {}, {
      id: c.id,
      allowNonScope: true
    }));
  });
  const pathsToRemove = (0, _lodash().compact)(pathsToRemoveWithNulls);

  _logger().default.debug(`deleting the following paths: ${pathsToRemove.join('\n')}`);

  return Promise.all(pathsToRemove.map(componentPath => _fsExtra().default.remove(consumer.toAbsolutePath(componentPath))));
}

function convertToValidPathForPackageManager(pathStr) {
  const prefix = 'file:'; // it works for both, Yarn and NPM

  return prefix + (pathStr.startsWith('.') ? pathStr : `./${pathStr}`);
}
/**
 * Only imported components should be saved with relative path in package.json
 * If a component is nested or imported as a package dependency, it should be saved with the version
 * If a component is authored, no need to save it as a dependency of the imported component because
 * the root package.json takes care of it already.
 */


function getPackageDependencyValue(dependencyId, parentComponentMap, dependencyComponentMap) {
  if (!dependencyComponentMap || dependencyComponentMap.origin === _constants().COMPONENT_ORIGINS.NESTED) {
    return dependencyId.version;
  }

  if (dependencyComponentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
    return null;
  }

  const dependencyRootDir = dependencyComponentMap.rootDir;

  if (!dependencyRootDir) {
    throw new Error(`rootDir is missing from an imported component ${dependencyId.toString()}`);
  }

  if (!parentComponentMap.rootDir) throw new Error('rootDir is missing from an imported component');
  const rootDirRelative = (0, _utils().pathRelativeLinux)(parentComponentMap.rootDir, dependencyRootDir);
  return convertToValidPathForPackageManager(rootDirRelative);
}

function getPackageDependency(bitMap, dependencyId, parentId) {
  const parentComponentMap = bitMap.getComponent(parentId);
  const dependencyComponentMap = bitMap.getComponentIfExist(dependencyId);
  return getPackageDependencyValue(dependencyId, parentComponentMap, dependencyComponentMap);
}