import { BitId } from '../../../bit-id';
import { ComponentWithDependencies } from '../../../scope';
import { DistFileModel } from '../../../scope/models/version';
import { PathLinux, PathOsBased, PathOsBasedRelative } from '../../../utils/path';
import BitMap from '../../bit-map';
import ComponentMap from '../../bit-map/component-map';
import { ILegacyWorkspaceConfig } from '../../config';
import Consumer from '../../consumer';
import Component from '../consumer-component';
import DataToPersist from './data-to-persist';
import Dist from './dist';
/**
 * Dist paths are by default saved into the component's root-dir/dist. However, when dist is set in bit.json, the paths
 * are in the consumer-root/dist.target dir. If dist.entry is set, the dist.entry part is stripped from the dists paths.
 * (according to some additional conditions. See shouldDistEntryBeStripped()).
 * If there is originallySharedDir and the component is IMPORTED, it is stripped as well.
 *
 * These modifications of the paths are taken care in different stages depends on the scenario.
 * 1) using 'bit build'.
 * First, the sharedOriginallyDir is stripped (happens in consumer-component.build()). There are two scenarios here:
 *   a) the component wasn't change since the last build. It loads the dists from the model and strip the
 *      sharedOriginallyDir. (see the !needToRebuild case of build()).
 *   b) the component was changed. It re-builds it. The dists path are cloned from the files, since the files are
 *      sharedOriginallyDir stripped (because they loaded from the filesystem), so will be the dists files.
 * Next, the dist.entry is stripped. This is done when the dists are written into the file-system,  (see writeDists()).
 *
 * 2) using 'bit import'.
 * When converting the component from model to consumer-component, the sharedOriginallyDir is stripped. (see
 * stripOriginallySharedDir() ).
 * Then, Before writing the dists to the file-system, the dist-entry is taken care of. (see writeDists() ).
 *
 * 3) using 'bit link'.
 * When linking authored components, we generate an index file from node_modules/component-name to the main dist file.
 * It might happen during the import, when updateDistsPerWorkspaceConfig() was running already, and it might happen
 * during the 'bit link' command. Therefore, before linking, the updateDistsPerWorkspaceConfig() is running while making
 * sure it doesn't run twice.
 * (see node-modules-linker.linkToMainFile() and calculateMainDistFileForAuthored()).
 *
 * The opposite action is taken when a component is tagged. We load the component from the file-system while the dist
 * paths might be stripped from consumer dist.entry and originallySharedDir.
 * Then, before writing them to the model, we first add the originallySharedDir and then the dist.entry. We make sure
 * there were stripped before adding them. (See this.toDistFilesModel() function and the comment there)
 */
export default class Dists {
    dists: Dist[];
    writeDistsFiles: boolean;
    areDistsInsideComponentDir: boolean | null | undefined;
    distEntryShouldBeStripped: boolean | null | undefined;
    _mainDistFile: PathOsBasedRelative | null | undefined;
    distsRootDir: PathOsBasedRelative | null | undefined;
    constructor(dists: Dist[] | null | undefined, mainDistFile: PathOsBased | null | undefined);
    isEmpty(): boolean;
    get(): Dist[];
    getAsReadable(): string[];
    getMainDistFile(): string | null | undefined;
    /**
     * When dists are written by a consumer (as opposed to isolated-environment for example), the dist-entry and
     * dist-target are taken into account for calculating the path.
     * By default, the dists path is inside the component. If dist attribute is populated in bit.json, the path is
     * relative to consumer root.
     */
    getDistDirForConsumer(consumer: Consumer, componentRootDir: PathLinux): PathOsBasedRelative;
    hasFileParallelToSrcFile(srcFile: PathLinux): boolean;
    static getDistDirWhenDistIsOutsideCompDir(workspaceConfig: ILegacyWorkspaceConfig, componentRootDir: PathLinux): PathOsBasedRelative;
    getDistDir(consumer: Consumer | null | undefined, componentRootDir: PathLinux): PathOsBasedRelative;
    updateDistsPerWorkspaceConfig(id: BitId, consumer: Consumer | null | undefined, componentMap: ComponentMap): void;
    stripDistEntryIfNeeded(id: BitId, consumer: Consumer, componentMap: ComponentMap): void;
    stripOriginallySharedDir(originallySharedDir: string | undefined): void;
    /**
     * write dists files to the filesystem
     */
    writeDists(component: Component, consumer: Consumer, writeLinks?: boolean | undefined): Promise<string[] | null | undefined>;
    /**
     * write dist link files to the filesystem
     */
    writeDistsLinks(component: Component, consumer: Consumer): Promise<void>;
    /**
     * In case there is a consumer and dist.entry should be stripped, it will be done before writing the files.
     * The originallySharedDir should be already stripped before accessing this method.
     */
    getDistsToWrite(component: Component, bitMap: BitMap, consumer: Consumer | null | undefined, writeLinks?: boolean | undefined, componentWithDependencies?: ComponentWithDependencies): Promise<DataToPersist | null | undefined>;
    calculateMainDistFile(mainSourceFile: PathOsBased): PathOsBased;
    /**
     * authored components have the dists outside the components dir and they don't have rootDir.
     * it returns the file or dist file relative to consumer-root.
     */
    calculateDistFileForAuthored(componentFile: PathOsBased, consumer: Consumer, isMain: boolean): PathOsBased;
    toDistFilesModel(consumer: Consumer, originallySharedDir: PathLinux | null | undefined, isCompileSet: boolean): {
        dists?: DistFileModel[];
        mainDistFile?: PathOsBasedRelative | null | undefined;
    };
    /**
     * the formula is distTarget + (customModuleDir - distEntry).
     * e.g. distTarget = 'dist', customDir = 'src', distEntry = 'src'.
     * node_path will be 'dist' + 'src' - 'src' = 'dist'.
     * another example, distTarget = 'dist', customDir = 'src/custom', distEntry = 'src'. result: "dist/custom"
     */
    static getNodePathDir(consumer: Consumer): string | undefined;
    clone(): Dists;
}
