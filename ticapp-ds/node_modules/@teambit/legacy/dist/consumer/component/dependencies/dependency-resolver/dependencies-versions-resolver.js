"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = updateDependenciesVersions;

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../../../../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _packages() {
  const data = require("../../../../utils/packages");

  _packages = function () {
    return data;
  };

  return data;
}

function _componentSchema() {
  const data = require("../../component-schema");

  _componentSchema = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * The dependency version is determined by the following strategies by this order.
 * 1) if the component bit.json or package.json has "overrides" property, check whether the dependency version is overridden
 * 2) if workspace-config overrides this component, use it. (technically this is done via #1 because we merge the two before)
 * 3) if package.json is different than the model, use package.json. to find the package.json follow this steps:
 * 3 a) search in the component directory for package.json and look for dependencies or devDependencies with the name of the dependency
 * 3 b) if not found there, propagate until you reach the consumer root directory.
 * 3 c) if not found, go directly to the dependency directory and find the version in its package.json
 * 4) if bitmap has a version, use it.
 * 5) use the model if it has a version.
 * 6) use the package.json regardless the model.
 *
 * cases where dependency version may be different than the model:
 * 1) user added the component to `overrides` of the workspace config. (workspace bit.json or package.json)
 * 2) user changed package.json, either, manually or by npm-install —save.
 * 3) user updated a dependency with npm without —save.
 * 4) user imported the dependency with different version causing the bitmap to change.
 *
 * keep in mind that since v14.0.5 bit.json doesn't have the dependencies, so it's impossible
 * to change a dependency version from the component bit.json.
 */
function updateDependenciesVersions(consumer, component, debugDependencies) {
  updateDependencies(component.dependencies);
  updateDependencies(component.devDependencies);
  updateExtensions(component.extensions);

  function resolveVersion(id) {
    // @ts-ignore component.componentFromModel is set
    const idFromModel = getIdFromModelDeps(component.componentFromModel, id);
    const idFromBitMap = getIdFromBitMap(id);
    const idFromComponentConfig = getIdFromComponentConfig(id);

    const getFromComponentConfig = () => idFromComponentConfig;

    const getFromBitMap = () => idFromBitMap || null;

    const getFromModel = () => idFromModel || null;

    const debugDep = debugDependencies === null || debugDependencies === void 0 ? void 0 : debugDependencies.find(dep => dep.id.isEqualWithoutVersion(id));
    let strategies;

    if (consumer.isLegacy) {
      const idFromPackageJson = getIdFromPackageJson(id);
      const idFromDependentPackageJson = getIdFromDependentPackageJson(id); // get from packageJson when it was changed from the model or when there is no model.

      const getFromPackageJsonIfChanged = () => {
        if (!idFromPackageJson) return null;
        if (!idFromModel) return idFromPackageJson;
        if (!idFromPackageJson.isEqual(idFromModel)) return idFromPackageJson;
        return null;
      };

      const getFromPackageJson = () => idFromPackageJson || null;

      const getFromDependentPackageJson = () => idFromDependentPackageJson || null;

      strategies = [getFromComponentConfig, getFromDependentPackageJson, getFromPackageJsonIfChanged, getFromBitMap, getFromModel, getFromPackageJson];
    } else {
      // @todo: change this once vendors feature is in.
      const getCurrentVersion = () => id.hasVersion() ? id : null;

      strategies = [getFromComponentConfig, getCurrentVersion, getFromBitMap, getFromModel];
    }

    for (const strategy of strategies) {
      const strategyId = strategy();

      if (strategyId) {
        _logger().default.debug(`found dependency version ${strategyId.version} for ${id.toString()} in strategy ${strategy.name}`);

        if (debugDep) {
          debugDep.versionResolvedFrom = strategy.name === 'getCurrentVersion' ? debugDep.versionResolvedFrom : strategy.name.replace('getFrom', '');
          debugDep.version = strategyId.version;
        }

        return strategyId.version;
      }
    }

    return undefined;
  }

  function updateDependency(dependency) {
    const resolvedVersion = resolveVersion(dependency.id);

    if (resolvedVersion) {
      dependency.id = dependency.id.changeVersion(resolvedVersion);
    }
  }

  function updateDependencies(dependencies) {
    dependencies.get().forEach(updateDependency);
  }

  function updateExtension(extension) {
    if (extension.extensionId) {
      const resolvedVersion = resolveVersion(extension.extensionId);

      if (resolvedVersion) {
        extension.extensionId = extension.extensionId.changeVersion(resolvedVersion);
      }
    }
  }

  function updateExtensions(extensions) {
    extensions.forEach(updateExtension);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  function getIdFromModelDeps(componentFromModel, componentId) {
    if (!componentFromModel) return null;
    const dependency = componentFromModel.getAllDependenciesIds().searchWithoutVersion(componentId);
    if (!dependency) return null;
    return dependency;
  }
  /**
   * the logic of finding the dependency version in the package.json is mostly done in
   * resolvePackageData function.
   * it first searches in the dependent package.json and propagate up to the consumer root, if not
   * found it goes to the dependency package.json.
   */


  function getIdFromPackageJson(componentId) {
    (0, _componentSchema().throwForNonLegacy)(component.isLegacy, getIdFromPackageJson.name);
    if (!componentId.scope) return null; // $FlowFixMe component.componentMap is set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const rootDir = component.componentMap.rootDir;
    const consumerPath = consumer.getPath();
    const basePath = rootDir ? path().join(consumerPath, rootDir) : consumerPath;
    const packagePath = (0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, component), {}, {
      id: componentId
    }));
    const packageName = packagePath.replace(`node_modules${path().sep}`, ''); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const modulePath = (0, _packages().resolvePackagePath)(packageName, basePath, consumerPath);
    if (!modulePath) return null; // e.g. it's author and wasn't exported yet, so there's no node_modules of that component

    const packageObject = (0, _packages().resolvePackageData)(basePath, modulePath);
    if (!packageObject || (0, _isEmpty2().default)(packageObject)) return null;
    const version = getValidVersion(packageObject.concreteVersion) || getValidVersion(packageObject.versionUsedByDependent);
    if (!version) return null;
    return componentId.changeVersion(version);
  }

  function getValidVersion(version) {
    if (!version) return null;
    if (!_semver().default.valid(version) && !_semver().default.validRange(version)) return null; // it's probably a relative path to the component

    return version.replace(/[^0-9.]/g, '');
  }

  function getIdFromDependentPackageJson(componentId) {
    (0, _componentSchema().throwForNonLegacy)(component.isLegacy, getIdFromDependentPackageJson.name); // for author, there is not package.json of a component
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (!component.packageJsonFile || !component.packageJsonFile.packageJsonObject.dependencies) {
      return null;
    }

    const dependencyIdAsPackage = (0, _componentIdToPackageName().default)(_objectSpread(_objectSpread({}, component), {}, {
      id: componentId,
      // this componentId is actually the dependencyId
      isDependency: true
    })); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const version = component.packageJsonFile.packageJsonObject.dependencies[dependencyIdAsPackage];
    if (!_semver().default.valid(version) && !_semver().default.validRange(version)) return null; // it's probably a relative path to the component

    const validVersion = version.replace(/[^0-9.]/g, ''); // allow only numbers and dots to get an exact version

    return componentId.changeVersion(validVersion);
  }

  function getIdFromBitMap(componentId) {
    return consumer.bitMap.getBitIdIfExist(componentId, {
      ignoreVersion: true
    });
  }

  function getIdFromComponentConfig(componentId) {
    const dependencies = component.overrides.getComponentDependenciesWithVersion();
    if ((0, _isEmpty2().default)(dependencies)) return undefined;
    const dependency = Object.keys(dependencies).find(idStr => componentId.toStringWithoutVersion() === idStr || componentId.toStringWithoutScopeAndVersion() === idStr);
    if (!dependency) return undefined;
    return componentId.changeVersion(dependencies[dependency]);
  }
}