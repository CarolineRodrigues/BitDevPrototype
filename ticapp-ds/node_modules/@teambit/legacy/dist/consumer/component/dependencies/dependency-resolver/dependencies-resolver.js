"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _forEachObjIndexed2() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));

  _forEachObjIndexed2 = function () {
    return data;
  };

  return data;
}

function _differenceWith2() {
  const data = _interopRequireDefault(require("ramda/src/differenceWith"));

  _differenceWith2 = function () {
    return data;
  };

  return data;
}

function _pick2() {
  const data = _interopRequireDefault(require("ramda/src/pick"));

  _pick2 = function () {
    return data;
  };

  return data;
}

function _keys2() {
  const data = _interopRequireDefault(require("ramda/src/keys"));

  _keys2 = function () {
    return data;
  };

  return data;
}

function _difference2() {
  const data = _interopRequireDefault(require("ramda/src/difference"));

  _difference2 = function () {
    return data;
  };

  return data;
}

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _pickBy2() {
  const data = _interopRequireDefault(require("ramda/src/pickBy"));

  _pickBy2 = function () {
    return data;
  };

  return data;
}

function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));

  _uniq2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ramdaAdjunct() {
  const data = require("ramda-adjunct");

  _ramdaAdjunct = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _linkContent() {
  const data = require("../../../../links/link-content");

  _linkContent = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _packageNameToComponentId() {
  const data = require("../../../../utils/bit/package-name-to-component-id");

  _packageNameToComponentId = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../../package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = _interopRequireDefault(require("../dependencies"));

  _dependencies = function () {
    return data;
  };

  return data;
}

function _filesDependencyBuilder() {
  const data = require("../files-dependency-builder");

  _filesDependencyBuilder = function () {
    return data;
  };

  return data;
}

function _overridesDependencies() {
  const data = _interopRequireDefault(require("./overrides-dependencies"));

  _overridesDependencies = function () {
    return data;
  };

  return data;
}

function _dependenciesData() {
  const data = require("./dependencies-data");

  _dependenciesData = function () {
    return data;
  };

  return data;
}

function _packageToDefinetlyTyped() {
  const data = require("./package-to-definetly-typed");

  _packageToDefinetlyTyped = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class DependencyResolver {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  static registerWorkspacePolicyGetter(func) {
    this.getWorkspacePolicy = func;
  }

  static registerHarmonyEnvPeersPolicyGetter(func) {
    this.getHarmonyEnvPeersPolicy = func;
  }

  constructor(component, consumer) {
    (0, _defineProperty2().default)(this, "component", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "componentId", void 0);
    (0, _defineProperty2().default)(this, "componentMap", void 0);
    (0, _defineProperty2().default)(this, "componentFromModel", void 0);
    (0, _defineProperty2().default)(this, "consumerPath", void 0);
    (0, _defineProperty2().default)(this, "tree", void 0);
    (0, _defineProperty2().default)(this, "allDependencies", void 0);
    (0, _defineProperty2().default)(this, "allPackagesDependencies", void 0);
    (0, _defineProperty2().default)(this, "issues", void 0);
    (0, _defineProperty2().default)(this, "coreAspects", []);
    (0, _defineProperty2().default)(this, "processedFiles", void 0);
    (0, _defineProperty2().default)(this, "compilerFiles", void 0);
    (0, _defineProperty2().default)(this, "testerFiles", void 0);
    (0, _defineProperty2().default)(this, "overridesDependencies", void 0);
    (0, _defineProperty2().default)(this, "debugDependenciesData", void 0);
    this.component = component;
    this.consumer = consumer;
    this.componentId = component.id; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.componentMap = this.component.componentMap; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.componentFromModel = this.component.componentFromModel;
    this.consumerPath = this.consumer.getPath();
    this.allDependencies = {
      dependencies: [],
      devDependencies: []
    };
    this.allPackagesDependencies = {
      packageDependencies: {},
      devPackageDependencies: {},
      compilerPackageDependencies: {},
      testerPackageDependencies: {},
      peerPackageDependencies: {}
    };
    this.processedFiles = [];
    this.issues = component.issues;
    this.setLegacyInsideHarmonyIssue();
    this.overridesDependencies = new (_overridesDependencies().default)(component, consumer);
    this.debugDependenciesData = {
      components: []
    };
  }

  setTree(tree) {
    this.tree = tree; // console.log(JSON.stringify(tree, null, 4)); // uncomment to easily watch the tree received from bit-javascript
  }
  /**
   * Resolve components and packages dependencies for a component.
   * This method should NOT have any side-effect on the component. the DependenciesLoader class is
   * responsible for saving this data on the component object.
   *
   * The process is as follows:
   * 1) Use the language driver to parse the component files and find for each file its dependencies.
   * 2) The results we get from the driver per file tells us what are the files and packages that depend on our file.
   * and also whether there are missing packages and files.
   * 3) Using the information from the driver, we go over each one of the dependencies files and find its counterpart
   * component. The way how we find it, is by using the bit.map file which has a mapping between the component name and
   * the file paths.
   * 4) If we find a component to the file dependency, we add it to component.dependencies. Otherwise, it's added to
   * component.issues.untrackedDependencies
   * 5) Similarly, when we find the packages dependencies, they are added to component.packageDependencies. Otherwise,
   * they're added to component.issues.missingPackagesDependenciesOnFs
   * 6) In case the driver found a file dependency that is not on the file-system, we add that file to
   * component.issues.missingDependenciesOnFs
   */


  async getDependenciesData(cacheResolvedDependencies, cacheProjectAst) {
    var _this$componentMap, _this$componentMap2;

    const componentDir = (_this$componentMap = this.componentMap) !== null && _this$componentMap !== void 0 && _this$componentMap.rootDir ? path().join(this.consumerPath, (_this$componentMap2 = this.componentMap) === null || _this$componentMap2 === void 0 ? void 0 : _this$componentMap2.rootDir) : this.consumerPath;
    const {
      nonTestsFiles,
      testsFiles
    } = this.componentMap.getFilesGroupedByBeingTests();
    const allFiles = [...nonTestsFiles, ...testsFiles]; // find the dependencies (internal files and packages) through automatic dependency resolution

    const dependenciesTree = await (0, _filesDependencyBuilder().getDependencyTree)({
      componentDir,
      workspacePath: this.consumerPath,
      filePaths: allFiles,
      bindingPrefix: this.component.bindingPrefix,
      isLegacyProject: this.consumer.isLegacy,
      resolveModulesConfig: this.consumer.config._resolveModules,
      visited: cacheResolvedDependencies,
      cacheProjectAst
    }); // we have the files dependencies, these files should be components that are registered in bit.map. Otherwise,
    // they are referred as "untracked components" and the user should add them later on in order to tag

    this.setTree(dependenciesTree.tree);
    const devFiles = this.consumer.isLegacy ? testsFiles : await DependencyResolver.getDevFiles(this.component);
    await this.populateDependencies(allFiles, devFiles);
    return new (_dependenciesData().DependenciesData)(this.allDependencies, this.allPackagesDependencies, this.issues, this.coreAspects, {
      manuallyRemovedDependencies: this.overridesDependencies.manuallyRemovedDependencies,
      manuallyAddedDependencies: this.overridesDependencies.manuallyAddedDependencies,
      missingPackageDependencies: this.overridesDependencies.missingPackageDependencies
    });
  }
  /**
   * Given the tree of file dependencies from the driver, find the components of these files.
   * Each dependency file has a path, use bit.map to search for the component name by that path.
   * If the component is found, add it to "this.allDependencies.dependencies". Otherwise, add it to "this.issues.untrackedDependencies".
   *
   * For the found components, add their sourceRelativePath and destinationRelativePath, they are being used for
   * generating links upon import:
   * sourceRelativePath - location of the link file.
   * destinationRelativePath - destination written inside the link file.
   *
   * When a dependency is found in a regular (implementation) file, it goes to `dependencies`. If
   * it found on a test file, it goes to `devDependencies`.
   * Similarly, when a package is found in a regular file, it goes to `packageDependencies`. When
   * if found in a test file, it goes to `devPackageDependencies`.
   * An exception for the above is when a package is required in a regular or test file but is also
   * mentioned in the `package.json` file as a peerDependency, in that case, the package is added
   * to `peerPackageDependencies` and removed from other places. Unless this package is overridden
   * and marked as ignored in the consumer or component config file.
   */


  async populateDependencies(files, testsFiles) {
    files.forEach(file => {
      const fileType = {
        isTestFile: testsFiles.includes(file)
      };
      this.throwForNonExistFile(file);

      if (this.overridesDependencies.shouldIgnoreFile(file, fileType)) {
        return;
      }

      this.processCoreAspects(file);
      this.processMissing(file, fileType);
      this.processErrors(file);
      this.processPackages(file, fileType);
      this.processComponents(file, fileType);
      this.processDepFiles(file, fileType);
      this.processUnidentifiedPackages(file, fileType);
    });
    this.removeIgnoredPackagesByOverrides();
    this.removeDevAndEnvDepsIfTheyAlsoRegulars();
    this.addCustomResolvedIssues();
    this.populatePeerPackageDependencies();

    if (!this.consumer.isLegacy) {
      this.applyWorkspacePolicy();
      await this.applyAutoDetectedPeersFromEnv();
    }

    this.manuallyAddDependencies();
    this.applyOverridesOnEnvPackages();
    this.coreAspects = (0, _uniq2().default)(this.coreAspects);
  }

  addCustomResolvedIssues() {
    if (this.consumer.isLegacy) return;
    const deps = [...this.allDependencies.dependencies, ...this.allDependencies.devDependencies];
    const customModulesDeps = deps.filter(dep => dep.relativePaths.some(r => r.isCustomResolveUsed));

    if (customModulesDeps.length) {
      const importSources = customModulesDeps.reduce((acc, current) => {
        current.relativePaths.forEach(relativePath => {
          if (relativePath.isCustomResolveUsed) {
            // @ts-ignore
            acc[relativePath.importSource] = current.id.toStringWithoutVersion();
          }
        });
        return acc;
      }, {});
      this.issues.getOrCreate(_componentIssues().IssuesClasses.CustomModuleResolutionUsed).data = importSources;
    }
  }

  removeIgnoredPackagesByOverrides() {
    const shouldBeIncluded = (pkgVersion, pkgName) => !this.overridesDependencies.shouldIgnorePackageByType(pkgName, 'dependencies');

    const shouldBeIncludedDev = (pkgVersion, pkgName) => !this.overridesDependencies.shouldIgnorePackageByType(pkgName, 'devDependencies');

    this.allPackagesDependencies.packageDependencies = (0, _pickBy2().default)(shouldBeIncluded, this.allPackagesDependencies.packageDependencies);
    this.allPackagesDependencies.devPackageDependencies = (0, _pickBy2().default)(shouldBeIncludedDev, this.allPackagesDependencies.devPackageDependencies);
    this.allPackagesDependencies.compilerPackageDependencies = (0, _pickBy2().default)(shouldBeIncludedDev, this.allPackagesDependencies.compilerPackageDependencies);
    this.allPackagesDependencies.testerPackageDependencies = (0, _pickBy2().default)(shouldBeIncludedDev, this.allPackagesDependencies.testerPackageDependencies);
  }

  throwForNonExistFile(file) {
    if (!this.tree[file]) {
      throw new Error(`DependencyResolver: a file "${file}" was not returned from the driver, its dependencies are unknown`);
    }
  }

  manuallyAddDependencies() {
    const packageJson = this._getPackageJson();

    const dependencies = this.overridesDependencies.getDependenciesToAddManually(packageJson, this.allDependencies);
    if (!dependencies) return;
    const {
      components,
      packages
    } = dependencies;

    _constants().DEPENDENCIES_FIELDS.forEach(depField => {
      if (components[depField] && components[depField].length) {
        components[depField].forEach(depData => this.allDependencies[depField].push({
          id: depData.componentId,
          relativePaths: [],
          packageName: depData.packageName
        }));
      }

      if (packages[depField] && !(0, _isEmpty2().default)(packages[depField])) {
        Object.assign(this.allPackagesDependencies[this._pkgFieldMapping(depField)], packages[depField]);
      }
    });
  }

  applyOverridesOnEnvPackages() {
    [this.component.compilerPackageDependencies, this.component.testerPackageDependencies].forEach(packages => {
      _constants().DEPENDENCIES_FIELDS.forEach(fieldType => {
        if (!packages[fieldType]) return;

        const shouldBeIncluded = (pkgVersion, pkgName) => {
          return !this.overridesDependencies.shouldIgnorePackageByType(pkgName, fieldType);
        };

        packages[fieldType] = (0, _pickBy2().default)(shouldBeIncluded, packages[fieldType]);
      });
    });
  }

  traverseTreeForComponentId(depFile) {
    if (!this.tree[depFile] || !this.tree[depFile].files && !this.tree[depFile].components) return undefined;

    if (!this.componentMap.rootDir) {
      throw Error('traverseTreeForComponentId should get called only when rootDir is set');
    }

    const rootDirFullPath = path().join(this.consumerPath, this.componentMap.rootDir);
    const files = this.tree[depFile].files || [];

    if (files && !(0, _isEmpty2().default)(files)) {
      for (const file of files) {
        const fullDepFile = path().resolve(rootDirFullPath, file.file);
        const depRelativeToConsumer = (0, _utils().pathNormalizeToLinux)(path().relative(this.consumerPath, fullDepFile));
        const componentId = this.consumer.bitMap.getComponentIdByPath(depRelativeToConsumer);
        if (componentId) return componentId;
      }
    }

    if (this.tree[depFile].components && !(0, _isEmpty2().default)(this.tree[depFile].components)) {
      const components = this.tree[depFile].components || [];

      for (const comp of components) {
        return this.getComponentIdByResolvedPackageData(comp);
      }
    }

    if (files && !(0, _isEmpty2().default)(files)) {
      for (const file of files) {
        if (file.file !== depFile) {
          const componentId = this.traverseTreeForComponentId(file.file);
          if (componentId) return componentId;
        } else {
          _logger().default.warn(`traverseTreeForComponentId found a cyclic dependency. ${file.file} depends on itself`);
        }
      }
    }

    return undefined;
  }

  getComponentIdByResolvedPackageData(bit) {
    if (bit.componentId) {
      return bit.componentId;
    }

    if (!this.consumer.isLegacy) {
      throw new Error(`on Harmony resolved Bit component must have componentId prop in the package.json file`);
    }

    if (bit.fullPath) {
      return this.consumer.getComponentIdFromNodeModulesPath(bit.fullPath, this.component.bindingPrefix);
    }

    return (0, _packageNameToComponentId().packageNameToComponentId)(this.consumer, bit.name, this.component.bindingPrefix);
  }
  /**
   * this happens when using relative paths between components, which is allowed on Legacy only.
   * on Harmony, during the execution of this function, it recognizes the use of relative-paths, enter
   * it to the "issues", then, later, it shows a warning on bit-status and block tagging.
   */


  getComponentIdByDepFile(depFile) {
    let depFileRelative = depFile; // dependency file path relative to consumer root

    let componentId;
    let destination;
    const rootDir = this.componentMap.rootDir;

    if (rootDir) {
      // The depFileRelative is relative to rootDir, change it to be relative to current consumer.
      // We can't use path.resolve(rootDir, fileDep) because this might not work when running
      // bit commands not from root, because resolve take by default the process.cwd
      const rootDirFullPath = path().join(this.consumerPath, rootDir);
      const fullDepFile = path().resolve(rootDirFullPath, depFile);
      depFileRelative = (0, _utils().pathNormalizeToLinux)(path().relative(this.consumerPath, fullDepFile));
    }

    componentId = this.consumer.bitMap.getComponentIdByPath(depFileRelative);
    if (!componentId) componentId = this._getComponentIdFromCustomResolveToPackageWithDist(depFileRelative); // if not found here, the file is not a component file. It might be a bit-auto-generated file.
    // find the component file by the auto-generated file.
    // We make sure also that it's not an AUTHORED component, which shouldn't have auto-generated files.

    if (!componentId && this.componentMap.origin !== _constants().COMPONENT_ORIGINS.AUTHORED) {
      componentId = this.traverseTreeForComponentId(depFile);
      if (!rootDir) throw new Error('rootDir must be set for non authored components');

      if (componentId) {
        // it is verified now that this depFile is an auto-generated file, therefore the sourceRelativePath and the
        // destinationRelativePath should be a partial-path and not full-relative-to-consumer path.
        // since the dep-file is a generated file, it is safe to assume that the componentFromModel has in its
        // dependencies array this component with the relativePaths array. Find the relativePath of this dep-file
        // to get the correct destinationRelativePath. There is no other way to obtain this info.
        ({
          componentId,
          destination,
          depFileRelative
        } = this.getDependencyPathsFromModel(componentId, depFile, rootDir));
      } else if (!(0, _linkContent().isSupportedExtension)(depFile) && this.componentFromModel) {
        // unsupported files, such as binary files, don't have link files. instead, they have a
        // symlink (or sometimes a copy on Windows) of the dependency inside the component. to
        // check whether a file is a symlink to a dependency we loop through the
        // sourceRelativePaths of the dependency, if there is match, we use the data from the model
        const dependenciesFromModel = this.componentFromModel.getAllDependenciesCloned();
        const sourcePaths = dependenciesFromModel.getSourcesPaths();

        if (sourcePaths.includes(depFile)) {
          const dependencyFromModel = dependenciesFromModel.getBySourcePath(depFile); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

          componentId = dependencyFromModel.id;
          ({
            componentId,
            destination,
            depFileRelative
          } = this.getDependencyPathsFromModel(componentId, depFile, rootDir));
        }
      }
    }

    return {
      componentId,
      depFileRelative,
      destination
    };
  }
  /**
   * this is a workaround for cases where an alias points to a package with dist.
   * normally, aliases are created for local directories.
   * they can be however useful when a source code can't be touched and `require` to one package
   * needs to be replaced with a `require` to a component. in that case, our options are:
   * 1) point the alias to the package name.
   * 2) point the alias to the relative directory of the imported component
   * the ideal solution is #1, however, it requires changes in the Tree structure, which should
   * allow "components" to have more data, such as importSource.
   * here, we go option #2, the alias is a relative path to the component. however, when there is
   * dist directory, the resolved path contains the "dist", which doesn't exist in the ComponentMap,
   * the solution we take is to identify such cases, strip the dist, then try to find them again.
   */


  _getComponentIdFromCustomResolveToPackageWithDist(depFile) {
    if (!depFile.includes('dist')) return null;
    const resolveModules = this.consumer.config._resolveModules;
    if (!resolveModules || !resolveModules.aliases) return null;
    const aliases = resolveModules.aliases;
    const foundAlias = Object.keys(aliases).find(alias => depFile.startsWith(aliases[alias]));
    if (!foundAlias) return null;
    const newDepFile = depFile.replace(`${resolveModules.aliases[foundAlias]}/dist`, resolveModules.aliases[foundAlias]);
    return this.consumer.bitMap.getComponentIdByPath(newDepFile);
  } // eslint-disable-next-line @typescript-eslint/no-unused-vars


  getDependencyPathsFromModel(componentId, depFile, rootDir) {
    const dependency = this.componentFromModel.getAllDependencies().find(dep => dep.id.isEqualWithoutVersion(componentId));

    if (!dependency) {
      throw new (_showDoctorError().default)( // $FlowFixMe
      `the auto-generated file ${depFile} should be connected to ${componentId}, however, it's not part of the model dependencies of ${this.componentFromModel.id}`);
    }

    const relativePath = dependency.relativePaths.find(r => r.sourceRelativePath === depFile);

    if (!relativePath) {
      throw new (_showDoctorError().default)(`unable to find ${relativePath} path in the dependencies relativePaths of ${this.componentFromModel.id}`);
    }

    return {
      componentId: dependency.id,
      destination: relativePath.destinationRelativePath,
      depFileRelative: depFile
    };
  }

  processDepFiles(originFile, fileType, nested = false) {
    // We don't just return because different files of the component might import different things from the depFile
    // See more info here: https://github.com/teambit/bit/issues/1796
    if (!this.processedFiles.includes(originFile)) {
      this.processedFiles.push(originFile); // We don't want to calculate nested files again after they calculated as direct files
    } else if (nested) {
      return;
    }

    const allDepsFiles = this.tree[originFile].files;
    if (!allDepsFiles || (0, _isEmpty2().default)(allDepsFiles)) return;
    allDepsFiles.forEach(depFile => {
      if (!nested && this.overridesDependencies.shouldIgnoreFile(depFile.file, fileType)) return;
      if (depFile.isLink) this.processLinkFile(originFile, depFile, fileType);else {
        const isDepFileUntracked = this.processOneDepFile(originFile, depFile.file, depFile.importSpecifiers, undefined, fileType, depFile, nested); // Only continue recursively if the dep file is untracked
        // for tracked deps if they have untracked deps they will be shown under their own components

        if (isDepFileUntracked) {
          // Recursively check for untracked files (to show them all in bit status)
          // for nested files we don't really care about the file types since we won't do all the checking
          const dummyFileType = {
            isTestFile: false
          };
          this.processDepFiles(depFile.file, dummyFileType, true);
        }
      }
    });
  } // return true if the dep file is untracked
  // eslint-disable-next-line complexity


  processOneDepFile(originFile, depFile, importSpecifiers, linkFile, fileType, depFileObject, nested = false) {
    const {
      componentId,
      depFileRelative,
      destination
    } = this.getComponentIdByDepFile(depFile);
    const importSource = depFileObject.importSource; // the file dependency doesn't have any counterpart component. Add it to this.issues.untrackedDependencies

    if (!componentId) {
      var _this$tree$depFile, _this$tree$depFile$mi;

      const missingComponents = (_this$tree$depFile = this.tree[depFile]) === null || _this$tree$depFile === void 0 ? void 0 : (_this$tree$depFile$mi = _this$tree$depFile.missing) === null || _this$tree$depFile$mi === void 0 ? void 0 : _this$tree$depFile$mi.components;

      if (missingComponents) {
        // this depFile is a dependency link and this dependency is missing.
        // it can't happen on Harmony, as Harmony doesn't have the generated dependencies files.
        this._addToMissingComponentsIfNeeded(missingComponents, originFile, fileType);

        return false;
      }

      this._pushToUntrackDependenciesIssues(originFile, depFileRelative, nested);

      return true;
    }

    if (this.overridesDependencies.shouldIgnoreComponent(componentId, fileType)) {
      // we can't support it because on the imported side, we don't know to convert the relative path
      // to the component name, as it won't have the component installed
      throw new (_generalError().default)(`unable to ignore "${componentId.toString()}" dependency of "${this.componentId.toString()}" by using ignore components syntax because the component is required with relative path.
either, use the ignore file syntax or change the require statement to have a module path`);
    } // happens when in the same component one file requires another one. In this case, there is
    // noting to do regarding the dependencies


    if (componentId.isEqualWithoutVersion(this.componentId)) {
      if (depFileObject.isCustomResolveUsed) {
        this.component.customResolvedPaths.push({
          destinationPath: depFileObject.file,
          importSource
        });
      }

      return false;
    }

    const depComponentMap = this.consumer.bitMap.getComponentIfExist(componentId); // found a dependency component. Add it to this.allDependencies.dependencies

    const depRootDir = depComponentMap ? depComponentMap.rootDir : undefined;
    const destinationRelativePath = destination || (depRootDir && depFileRelative.startsWith(depRootDir) ? (0, _utils().pathRelativeLinux)(depRootDir, depFileRelative) : depFileRelative);
    let sourceRelativePath;

    if (linkFile) {
      sourceRelativePath = linkFile;
    } else {
      // when there is no rootDir for the current dependency (it happens when it's AUTHORED), keep the original path
      sourceRelativePath = depRootDir ? depFileRelative : depFile;
    }

    const depsPaths = {
      sourceRelativePath,
      destinationRelativePath
    };

    if (importSpecifiers) {
      importSpecifiers.forEach(importSpecifier => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        if (importSpecifier.linkFile) delete importSpecifier.linkFile.exported; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        if (importSpecifier.mainFile) delete importSpecifier.mainFile.exported;
      });
      depsPaths.importSpecifiers = importSpecifiers;
    }

    if (depFileObject.isCustomResolveUsed) {
      depsPaths.isCustomResolveUsed = depFileObject.isCustomResolveUsed;
      depsPaths.importSource = importSource;
    }

    const currentComponentsDeps = {
      id: componentId,
      relativePaths: [depsPaths]
    };

    if (depComponentMap && !depFileObject.isCustomResolveUsed && ( // for custom resolve, the link is written in node_modules, so it doesn't matter
    depComponentMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED && this.componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED || depComponentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && this.componentMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED)) {
      // prevent author using relative paths for IMPORTED component (to avoid long paths)
      // also prevent adding AUTHORED component to an IMPORTED component using relative syntax. The reason is that when
      // this component is imported somewhere else, a link-file between the IMPORTED and the AUTHORED must be written
      // outside the component directory, which might override user files.
      this._pushToRelativeComponentsIssues(originFile, componentId);

      return false;
    }

    this._pushToRelativeComponentsAuthoredIssues(originFile, componentId, importSource, depsPaths);

    const allDependencies = [...this.allDependencies.dependencies, ...this.allDependencies.devDependencies];
    const existingDependency = this.getExistingDependency(allDependencies, componentId);

    if (existingDependency) {
      const existingDepRelativePaths = this.getExistingDepRelativePaths(existingDependency, depsPaths);

      if (!existingDepRelativePaths) {
        // it is another file of an already existing component. Just add the new path
        existingDependency.relativePaths.push(depsPaths);
        return false;
      } // The dep path already exists but maybe this dep-file has more importSpecifiers


      if (depsPaths.importSpecifiers) {
        // add them to the existing dep
        if (!existingDepRelativePaths.importSpecifiers) {
          existingDepRelativePaths.importSpecifiers = [...depsPaths.importSpecifiers];
        } else {
          // both have importSpecifiers
          const nonExistingImportSpecifiers = this.getDiffSpecifiers(existingDepRelativePaths.importSpecifiers, depsPaths.importSpecifiers);
          existingDepRelativePaths.importSpecifiers.push(...nonExistingImportSpecifiers);
        }
      } // Handle cases when the first dep paths are not custom resolved and the new one is


      if (depsPaths.isCustomResolveUsed && !existingDepRelativePaths.isCustomResolveUsed) {
        existingDepRelativePaths.isCustomResolveUsed = depsPaths.isCustomResolveUsed;
      }

      if (depsPaths.importSource && !existingDepRelativePaths.importSource) {
        existingDepRelativePaths.importSource = depsPaths.importSource;
      }
    } else {
      const depDebug = {
        id: currentComponentsDeps.id,
        importSource
      };
      this.pushToDependenciesArray(currentComponentsDeps, fileType, depDebug);
    }

    return false;
  }

  processLinkFile(originFile, linkFile, fileType) {
    if (!linkFile.linkDependencies || (0, _isEmpty2().default)(linkFile.linkDependencies)) return;
    const nonLinkImportSpecifiers = [];
    linkFile.linkDependencies.forEach(dependency => {
      const component = this.getComponentIdByDepFile(linkFile.file);

      if (component.componentId) {
        // the linkFile is already a component, no need to treat it differently than other depFile
        // aggregate all dependencies using the same linkFile and ultimately run processDepFile
        // with all importSpecifiers of that linkFile.
        // also, delete the linkFile attribute of importSpecifiers so then once the component is
        // imported and the link is generated, it won't be treated as a linkFile.
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependency.importSpecifiers.map(a => delete a.linkFile); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        nonLinkImportSpecifiers.push(dependency.importSpecifiers);
      } else {
        this.processOneDepFile(originFile, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependency.file, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependency.importSpecifiers, linkFile.file, fileType, linkFile);
      }
    });

    if (nonLinkImportSpecifiers.length) {
      this.processOneDepFile(originFile, linkFile.file, (0, _flatten2().default)(nonLinkImportSpecifiers), undefined, fileType, linkFile);
    }
  }
  /**
   * process require/import of Bit components where the require statement is not a relative path
   * but a module path, such as `require('@bit/bit.envs/compiler/babel');`
   */


  processComponents(originFile, fileType) {
    const components = this.tree[originFile].components;
    if (!components || (0, _isEmpty2().default)(components)) return;
    components.forEach(compDep => {
      let componentId = this.getComponentIdByResolvedPackageData(compDep);
      const depDebug = {
        id: componentId,
        dependencyPackageJsonPath: compDep.packageJsonPath,
        dependentPackageJsonPath: compDep.dependentPackageJsonPath,
        componentIdResolvedFrom: this.consumer.isLegacy ? 'LegacyUnknown' : 'DependencyPkgJson',
        packageName: compDep.name
      };

      const getVersionFromPkgJson = () => {
        const versionFromDependencyPkgJson = this.getValidVersion(compDep.concreteVersion);

        if (versionFromDependencyPkgJson) {
          depDebug.versionResolvedFrom = 'DependencyPkgJson';
          return versionFromDependencyPkgJson;
        }

        const versionFromDependentPkgJson = this.getValidVersion(compDep.versionUsedByDependent);

        if (versionFromDependentPkgJson) {
          depDebug.versionResolvedFrom = 'DependentPkgJson';
          return versionFromDependentPkgJson;
        }

        return null;
      };

      const version = getVersionFromPkgJson();

      if (version) {
        componentId = componentId.changeVersion(version);
      }

      if (this.overridesDependencies.shouldIgnoreComponent(componentId, fileType)) {
        return;
      }

      const getExistingId = () => {
        const existingIds = this.consumer.bitmapIdsFromCurrentLane.filterWithoutVersion(componentId);

        if (existingIds.length === 1) {
          depDebug.versionResolvedFrom = 'BitMap';
          return existingIds[0];
        }

        if (this.componentFromModel) {
          const modelDep = this.componentFromModel.getAllDependenciesIds().searchWithoutVersion(componentId);

          if (modelDep) {
            depDebug.versionResolvedFrom = 'Model';
            return modelDep;
          }
        }

        return undefined;
      };

      const existingId = version ? componentId : getExistingId();

      if (existingId) {
        if (existingId.isEqual(this.componentId)) {
          // happens when one of the component files requires another using module path
          // no need to enter anything to the dependencies
          return;
        }

        this.addImportNonMainIssueIfNeeded(originFile, compDep);
        const currentComponentsDeps = {
          id: existingId,
          relativePaths: [],
          packageName: compDep.name
        };

        this._pushToDependenciesIfNotExist(currentComponentsDeps, fileType, depDebug);
      } else {
        this._pushToMissingComponentsIssues(originFile, componentId);
      }
    });
  }

  addImportNonMainIssueIfNeeded(filePath, dependencyPkgData) {
    var _dependencyPkgData$pa, _dependencyPkgData$pa2, _this$issues$getOrCre;

    if (this.consumer.isLegacy) {
      return; // this is relevant for Harmony only
    }

    const depMain = (_dependencyPkgData$pa = dependencyPkgData.packageJsonContent) === null || _dependencyPkgData$pa === void 0 ? void 0 : _dependencyPkgData$pa.main;

    if (!depMain) {
      return;
    }

    const depFullPath = (0, _utils().pathNormalizeToLinux)(dependencyPkgData.fullPath);

    if (depFullPath.endsWith(depMain)) {
      // it requires the main-file. all is good.
      return;
    }

    const extDisallowNonMain = ['.ts', '.tsx', '.js', '.jsx'];

    if (!extDisallowNonMain.includes(path().extname(depFullPath))) {
      // some files such as scss/json are needed to be imported as non-main
      return;
    }

    const pkgRootDir = (_dependencyPkgData$pa2 = dependencyPkgData.packageJsonContent) === null || _dependencyPkgData$pa2 === void 0 ? void 0 : _dependencyPkgData$pa2.componentRootFolder;

    if (pkgRootDir && !_fsExtra().default.existsSync(path().join(pkgRootDir, _constants().DEFAULT_DIST_DIRNAME))) {
      // the dependency wasn't compiled yet. the issue is probably because depMain points to the dist
      // and depFullPath is in the source.
      return;
    }

    const nonMainFileSplit = depFullPath.split(`node_modules/`);
    const nonMainFileShort = nonMainFileSplit[1] || nonMainFileSplit[0];
    ((_this$issues$getOrCre = this.issues.getOrCreate(_componentIssues().IssuesClasses.ImportNonMainFiles).data)[filePath] || (_this$issues$getOrCre[filePath] = [])).push(nonMainFileShort);
  }

  getValidVersion(version) {
    if (!version) return null;
    if (!_semver().default.valid(version) && !_semver().default.validRange(version)) return null; // it's probably a relative path to the component

    return version.replace(/[^0-9.]/g, '');
  }

  processPackages(originFile, fileType) {
    const packages = this.tree[originFile].packages;
    if (!packages || (0, _isEmpty2().default)(packages)) return;

    if (fileType.isTestFile) {
      Object.assign(this.allPackagesDependencies.devPackageDependencies, packages);
    } else {
      Object.assign(this.allPackagesDependencies.packageDependencies, packages);
    }

    this._addTypesPackagesForTypeScript(packages, originFile);
  }

  processMissing(originFile, fileType) {
    const missing = this.tree[originFile].missing;
    if (!missing) return;

    const processMissingFiles = () => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if ((0, _ramdaAdjunct().isNilOrEmpty)(missing.files)) return;
      const absOriginFile = this.consumer.toAbsolutePath(originFile); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const missingFiles = missing.files.filter(missingFile => {
        // convert from importSource (the string inside the require/import call) to the path relative to consumer
        const resolvedPath = path().resolve(path().dirname(absOriginFile), missingFile);
        const relativeToConsumer = this.consumer.getPathRelativeToConsumer(resolvedPath);
        return !this.overridesDependencies.shouldIgnoreFile(relativeToConsumer, fileType);
      });
      if ((0, _isEmpty2().default)(missingFiles)) return;

      this._pushToMissingDependenciesOnFs(originFile, missingFiles);
    };

    const processMissingPackages = () => {
      if ((0, _ramdaAdjunct().isNilOrEmpty)(missing.packages)) return;
      const missingPackages = missing.packages.filter(pkg => !this.overridesDependencies.shouldIgnorePackage(pkg, fileType));
      if ((0, _isEmpty2().default)(missingPackages)) return;
      const customResolvedDependencies = this.findOriginallyCustomModuleResolvedDependencies(missingPackages);

      if (customResolvedDependencies) {
        Object.keys(customResolvedDependencies).forEach(missingPackage => {
          const componentId = customResolvedDependencies[missingPackage].toString();

          this._pushToMissingCustomModuleIssues(originFile, componentId);
        });
      }

      const missingPackagesWithoutCustomResolved = customResolvedDependencies ? (0, _difference2().default)(missingPackages, Object.keys(customResolvedDependencies)) : missingPackages;

      if (!(0, _isEmpty2().default)(missingPackagesWithoutCustomResolved)) {
        this._pushToMissingPackagesDependenciesIssues(originFile, missingPackages);
      }
    };

    const processMissingComponents = () => {
      if ((0, _ramdaAdjunct().isNilOrEmpty)(missing.components)) return;

      this._addToMissingComponentsIfNeeded(missing.components, originFile, fileType);
    };

    processMissingFiles();
    processMissingPackages();
    processMissingComponents();
  }

  _addToMissingComponentsIfNeeded(missingComponents, originFile, fileType) {
    if (!this.consumer.isLegacy) {
      // on Harmony we don't guess whether a path is a component or a package based on the path only,
      // see missing-handler.groupMissingByType() for more info.
      throw new Error(`Harmony should not have "missing.components" (only "missing.packages"). got ${missingComponents.join(',')}`);
    }

    missingComponents.forEach(missingBit => {
      const componentId = this.consumer.getComponentIdFromNodeModulesPath(missingBit, this.component.bindingPrefix);
      if (this.overridesDependencies.shouldIgnoreComponent(componentId, fileType)) return; // In case the component it missing, it might consider as a package sometime, check if we should ignore it by the package name

      if (this.overridesDependencies.shouldIgnorePackage(missingBit, fileType)) return; // todo: a component might be on bit.map but not on the FS, yet, it's not about missing links.

      if (this.consumer.bitMap.getBitIdIfExist(componentId, {
        ignoreVersion: true
      })) {
        this._pushToMissingLinksIssues(originFile, componentId);
      } else {
        this._pushToMissingComponentsIssues(originFile, componentId);
      }
    });
  }

  processErrors(originFile) {
    const error = this.tree[originFile].error;
    if (!error) return;

    _logger().default.errorAndAddBreadCrumb('dependency-resolver.processErrors', 'got an error from the driver while resolving dependencies');

    _logger().default.error('dependency-resolver.processErrors', error); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (error.code === 'PARSING_ERROR') this.issues.getOrCreate(_componentIssues().IssuesClasses.ParseErrors).data[originFile] = error.message;else this.issues.getOrCreate(_componentIssues().IssuesClasses.ResolveErrors).data[originFile] = error.message;
  }
  /**
   * when a user uses core-extensions these core-extensions should not be dependencies.
   * here, we filter them out from all places they could entered as dependencies.
   * an exception is when running this method on bit-core-extensions themselves (dogfooding), in
   * which case we recognizes that the current originFile is a core-extension and avoid filtering.
   */


  processCoreAspects(originFile) {
    var _DependencyResolver$g, _this$tree$originFile, _this$tree$originFile2;

    const coreAspects = (_DependencyResolver$g = DependencyResolver.getCoreAspectsPackagesAndIds) === null || _DependencyResolver$g === void 0 ? void 0 : _DependencyResolver$g.call(DependencyResolver);

    if (!coreAspects) {
      return;
    } // const scopes = coreAspects.map((id) => {
    //   const id = id.split()
    // });


    const coreAspectIds = Object.values(coreAspects);
    const defaultScope = this.component.defaultScope;
    let id;

    if (this.component.id.scope) {
      id = this.component.id;
    } else {
      id = this.component.id.changeScope(defaultScope);
    }

    if (coreAspectIds.includes(id.toStringWithoutVersion())) {
      return;
    }

    const coreAspectsPackages = Object.keys(coreAspects);
    const components = this.tree[originFile].components;
    const unidentifiedPackages = this.tree[originFile].unidentifiedPackages;
    const missingComponents = (_this$tree$originFile = this.tree[originFile]) === null || _this$tree$originFile === void 0 ? void 0 : (_this$tree$originFile2 = _this$tree$originFile.missing) === null || _this$tree$originFile2 === void 0 ? void 0 : _this$tree$originFile2.components;
    const usedCoreAspects = [];

    const findMatchingCoreAspect = packageName => {
      return coreAspectsPackages.find(coreAspectName => packageName === coreAspectName);
    };

    const unidentifiedPackagesFiltered = unidentifiedPackages === null || unidentifiedPackages === void 0 ? void 0 : unidentifiedPackages.filter(packageName => {
      const matchingCoreAspectPackageName = findMatchingCoreAspect(packageName);

      if (matchingCoreAspectPackageName) {
        usedCoreAspects.push(coreAspects[matchingCoreAspectPackageName]);
      }

      return !matchingCoreAspectPackageName;
    });
    const bitsFiltered = components === null || components === void 0 ? void 0 : components.filter(packageInfo => {
      const matchingCoreAspectPackageName = findMatchingCoreAspect(packageInfo.name);

      if (matchingCoreAspectPackageName) {
        usedCoreAspects.push(coreAspects[matchingCoreAspectPackageName]);
      }

      return !matchingCoreAspectPackageName;
    });
    const missingBitsFiltered = missingComponents === null || missingComponents === void 0 ? void 0 : missingComponents.filter(packageName => {
      const matchingCoreAspectPackageName = findMatchingCoreAspect(packageName);

      if (matchingCoreAspectPackageName) {
        usedCoreAspects.push(coreAspects[matchingCoreAspectPackageName]);
      }

      return !matchingCoreAspectPackageName;
    });

    if (missingComponents) {
      // @ts-ignore not clear why this error happens, it is verified that missing.components exist
      this.tree[originFile].missing.components = missingBitsFiltered;
    }

    this.tree[originFile].unidentifiedPackages = unidentifiedPackagesFiltered;
    this.tree[originFile].components = bitsFiltered;
    this.coreAspects.push(...(0, _uniq2().default)(usedCoreAspects));
  }
  /**
   * currently the only unidentified packages being process are the ones coming from custom-modules-resolution.
   * assuming the author used custom-resolution, which enable using non-relative import syntax,
   * for example, requiring the file 'src/utils/is-string' from anywhere as require('utils/is-string');
   * now, when the component is imported, the driver recognizes 'utils/is-string' as a package,
   * because it's not relative.
   * the goal here is to use the 'package' the driver found and match it with one of the
   * dependencies from the model. In the example above, we might find in the model, a dependency
   * is-string with importSource of 'utils/is-string'.
   * Once a match is found, copy the relativePaths from the model.
   *
   * keep in mind that this custom-modules-resolution supported on legacy components only.
   * as such, no need to find the packageName to pass to _pushToDependenciesIfNotExist method.
   */


  processUnidentifiedPackages(originFile, fileType) {
    const unidentifiedPackages = this.tree[originFile].unidentifiedPackages;
    if (!unidentifiedPackages || !unidentifiedPackages.length) return;
    this.debugDependenciesData.unidentifiedPackages = unidentifiedPackages;
    if (!this.componentFromModel) return; // not relevant, the component is not imported

    const getDependencies = () => {
      if (fileType.isTestFile) return this.componentFromModel.devDependencies;
      return this.componentFromModel.dependencies;
    };

    const dependencies = getDependencies();
    if (dependencies.isEmpty()) return;
    const importSourceMap = dependencies.getCustomResolvedData();
    if ((0, _isEmpty2().default)(importSourceMap)) return;
    const clonedDependencies = new (_dependencies().default)(dependencies.getClone());
    unidentifiedPackages.forEach(unidentifiedPackage => {
      const packageLinuxFormat = (0, _utils().pathNormalizeToLinux)(unidentifiedPackage);
      const packageWithNoNodeModules = packageLinuxFormat.replace('node_modules/', '');
      const foundImportSource = Object.keys(importSourceMap).find(importSource => packageWithNoNodeModules.startsWith(importSource));

      if (foundImportSource) {
        const dependencyId = importSourceMap[foundImportSource];
        const currentComponentDeps = {
          id: dependencyId,
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          relativePaths: clonedDependencies.getById(dependencyId).relativePaths
        };
        const depData = {
          id: dependencyId,
          importSource: foundImportSource
        };

        this._pushToDependenciesIfNotExist(currentComponentDeps, fileType, depData);
      }
    });
  }

  _pushToDependenciesIfNotExist(dependency, fileType, depDebug) {
    const existingDependency = this.getExistingDependency(this.allDependencies.dependencies, dependency.id);
    const existingDevDependency = this.getExistingDependency(this.allDependencies.devDependencies, dependency.id); // no need to enter dev dependency to devDependencies if it exists already in dependencies

    if (existingDependency || existingDevDependency && fileType.isTestFile) {
      return;
    } // at this point, either, it doesn't exist at all and should be entered.
    // or it exists in devDependencies but now it comes from non-dev file, which should be entered
    // as non-dev.


    this.pushToDependenciesArray(dependency, fileType, depDebug);
  }

  pushToDependenciesArray(currentComponentsDeps, fileType, depDebug) {
    if (fileType.isTestFile) {
      this.allDependencies.devDependencies.push(currentComponentsDeps);
    } else {
      this.allDependencies.dependencies.push(currentComponentsDeps);
    }

    this.debugDependenciesData.components.push(depDebug);
  }
  /**
   * Remove the dependencies which appear both in dev and regular deps from the dev
   * Because if a dependency is both dev dependency and regular dependency it should be treated as regular one
   * Apply for both packages and components dependencies
   */


  removeDevAndEnvDepsIfTheyAlsoRegulars() {
    // remove dev and env packages that are also regular packages
    const getNotRegularPackages = packages => (0, _difference2().default)((0, _keys2().default)(packages), (0, _keys2().default)(this.allPackagesDependencies.packageDependencies));

    this.allPackagesDependencies.devPackageDependencies = (0, _pick2().default)(getNotRegularPackages(this.allPackagesDependencies.devPackageDependencies), this.allPackagesDependencies.devPackageDependencies);
    this.allPackagesDependencies.compilerPackageDependencies = (0, _pick2().default)(getNotRegularPackages(this.allPackagesDependencies.compilerPackageDependencies), this.allPackagesDependencies.compilerPackageDependencies);
    this.allPackagesDependencies.testerPackageDependencies = (0, _pick2().default)(getNotRegularPackages(this.allPackagesDependencies.testerPackageDependencies), this.allPackagesDependencies.testerPackageDependencies); // remove dev dependencies that are also regular dependencies
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const componentDepsIds = new (_bitId().BitIds)(...this.allDependencies.dependencies.map(c => c.id));
    this.allDependencies.devDependencies = this.allDependencies.devDependencies.filter(d => !componentDepsIds.has(d.id));
  }
  /**
   * given missing packages name, find whether they were dependencies with custom-resolve before.
   */


  findOriginallyCustomModuleResolvedDependencies(packages) {
    if (!packages) return undefined;
    if (!this.componentFromModel) return undefined; // not relevant, the component is not imported

    const dependencies = new (_dependencies().default)(this.componentFromModel.getAllDependencies());
    if (dependencies.isEmpty()) return undefined;
    const importSourceMap = dependencies.getCustomResolvedData();
    if ((0, _isEmpty2().default)(importSourceMap)) return undefined;
    const foundPackages = packages.reduce((acc, value) => {
      const packageLinuxFormat = (0, _utils().pathNormalizeToLinux)(value);
      const foundImportSource = Object.keys(importSourceMap).find(importSource => importSource.startsWith(packageLinuxFormat));

      if (foundImportSource) {
        const dependencyId = importSourceMap[foundImportSource];
        acc[value] = dependencyId;
      }

      return acc;
    }, {});
    return (0, _isEmpty2().default)(foundPackages) ? undefined : foundPackages;
  }

  getExistingDependency(dependencies, id) {
    return dependencies.find(d => d.id.isEqualWithoutVersion(id));
  }

  getExistingDepRelativePaths(dependency, relativePath) {
    if (!dependency.relativePaths || (0, _isEmpty2().default)(dependency.relativePaths)) return null;
    return dependency.relativePaths.find(paths => paths.sourceRelativePath === relativePath.sourceRelativePath && paths.destinationRelativePath === relativePath.destinationRelativePath);
  }

  getDiffSpecifiers(originSpecifiers, targetSpecifiers) {
    const cmp = (specifier1, specifier2) => specifier1.mainFile.name === specifier2.mainFile.name;

    return (0, _differenceWith2().default)(cmp, targetSpecifiers, originSpecifiers);
  }
  /**
   * For author, the peer-dependencies are set in the root package.json
   * For imported components, we don't want to change the peerDependencies of the author, unless
   * we're certain the user intent to do so. Therefore, we ignore the root package.json and look for
   * the package.json in the component's directory.
   */


  populatePeerPackageDependencies() {
    const getPeerDependencies = () => {
      const packageJson = this._getPackageJson(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      if (packageJson && packageJson.peerDependencies) return packageJson.peerDependencies;
      return {};
    };

    const projectPeerDependencies = getPeerDependencies();
    const peerPackages = {};
    if ((0, _isEmpty2().default)(projectPeerDependencies)) return; // check whether the peer-dependencies was actually require in the code. if so, remove it from
    // the packages/dev-packages and add it as a peer-package.
    // if it was not required in the code, don't add it to the peerPackages

    Object.keys(projectPeerDependencies).forEach(pkg => {
      if (this.overridesDependencies.shouldIgnorePeerPackage(pkg)) return;
      ['packageDependencies', 'devPackageDependencies'].forEach(field => {
        if (Object.keys(this.allPackagesDependencies[field]).includes(pkg)) {
          delete this.allPackagesDependencies[field][pkg];
          peerPackages[pkg] = projectPeerDependencies[pkg];
        }
      });
    });
    this.allPackagesDependencies.peerPackageDependencies = peerPackages;
  }

  applyWorkspacePolicy() {
    const wsPolicy = DependencyResolver.getWorkspacePolicy();
    if (!wsPolicy) return;
    const wsPeer = wsPolicy.peerDependencies || {};
    const wsRegular = wsPolicy.dependencies || {};
    const peerDeps = this.allPackagesDependencies.peerPackageDependencies || {}; // we are not iterate component deps since they are resolved from what actually installed
    // the policy used for installation only in that case

    ['packageDependencies', 'devPackageDependencies', 'peerPackageDependencies'].forEach(field => {
      (0, _forEachObjIndexed2().default)((_pkgVal, pkgName) => {
        const peerVersionFromWsPolicy = wsPeer[pkgName];
        const regularVersionFromWsPolicy = wsRegular[pkgName];

        if (peerVersionFromWsPolicy) {
          delete this.allPackagesDependencies[field][pkgName];
          peerDeps[pkgName] = peerVersionFromWsPolicy;
        } else if (regularVersionFromWsPolicy) {
          this.allPackagesDependencies[field][pkgName] = regularVersionFromWsPolicy;
        }
      }, this.allPackagesDependencies[field]);
    });
    this.allPackagesDependencies.peerPackageDependencies = peerDeps;
  }

  async applyAutoDetectedPeersFromEnv() {
    const envPolicy = await DependencyResolver.getHarmonyEnvPeersPolicy(this.component.extensions);

    if (!envPolicy || !Object.keys(envPolicy).length) {
      return;
    }

    const peerDeps = this.allPackagesDependencies.peerPackageDependencies || {}; // we are not iterate component deps since they are resolved from what actually installed
    // the policy used for installation only in that case

    ['packageDependencies', 'devPackageDependencies', 'peerPackageDependencies'].forEach(field => {
      (0, _forEachObjIndexed2().default)((_pkgVal, pkgName) => {
        const peerVersionFromEnvPolicy = envPolicy[pkgName];
        if (this.overridesDependencies.shouldIgnorePeerPackage(pkgName)) return;

        if (peerVersionFromEnvPolicy) {
          delete this.allPackagesDependencies[field][pkgName];
          peerDeps[pkgName] = peerVersionFromEnvPolicy;
        }
      }, this.allPackagesDependencies[field]);
    }); // TODO: handle component deps once we support peers between components

    this.allPackagesDependencies.peerPackageDependencies = peerDeps;
  }
  /**
   * returns `package.json` of the component when it's imported, or `package.json` of the workspace
   * when it's authored.
   */


  _getPackageJson() {
    const componentMap = this.component.componentMap; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const isAuthor = componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED;

    if (isAuthor) {
      return this.consumer.packageJson.packageJsonObject;
    }

    if (this.component.packageJsonFile && this.component.packageJsonFile.fileExist) {
      return this.component.packageJsonFile.packageJsonObject;
    }

    if (this.componentFromModel) {
      // a component is imported but the package.json file is missing or never written
      // read the values from the model
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const packageJson = _packageJsonFile().default.createFromComponent(componentMap.rootDir, this.componentFromModel);

      return packageJson.packageJsonObject;
    }

    return undefined;
  }

  setLegacyInsideHarmonyIssue() {
    if (this.consumer.isLegacy) return;

    if (this.componentFromModel && this.componentFromModel.isLegacy) {
      this.issues.getOrCreate(_componentIssues().IssuesClasses.LegacyInsideHarmony).data = true;
    }
  }
  /**
   * when requiring packages in typescript, sometimes there are the types packages with the same
   * name, which the user probably wants as well. for example, requiring `foo` package, will also
   * add `@types/foo` to the devDependencies if it has been found in the user `package.json` file.
   *
   * ideally this should be in bit-javascript. however, the decision where to put these `@types`
   * packages (dependencies/devDependencies) is done here according to the user `package.json`
   * and can't be done there because the `Tree` we get from bit-javascript doesn't have this
   * distinction.
   */


  _addTypesPackagesForTypeScript(packages, originFile) {
    const isTypeScript = (0, _utils().getExt)(originFile) === 'ts' || (0, _utils().getExt)(originFile) === 'tsx';
    if (!isTypeScript) return;

    let depsHost = this._getPackageJson();

    if (!this.consumer.isLegacy) {
      depsHost = DependencyResolver.getWorkspacePolicy();
    }

    if (!depsHost) return;

    const addIfNeeded = (depField, packageName) => {
      if (!depsHost || !depsHost[depField]) return;
      const typesPackage = (0, _packageToDefinetlyTyped().packageToDefinetlyTyped)(packageName);
      if (!depsHost[depField][typesPackage]) return;
      Object.assign(this.allPackagesDependencies[this._pkgFieldMapping('devDependencies')], {
        [typesPackage]: depsHost[depField][typesPackage]
      });
    };

    Object.keys(packages).forEach(packageName => {
      _constants().DEPENDENCIES_FIELDS.forEach(depField => addIfNeeded(depField, packageName));
    });
  }

  _pkgFieldMapping(field) {
    switch (field) {
      case 'dependencies':
        return 'packageDependencies';

      case 'devDependencies':
        return 'devPackageDependencies';

      case 'peerDependencies':
        return 'peerPackageDependencies';

      default:
        throw new Error(`${field} is not recognized`);
    }
  }

  _pushToUntrackDependenciesIssues(originFile, depFileRelative, nested = false) {
    const findExisting = () => {
      var _this$issues$getIssue;

      let result;
      (0, _forEachObjIndexed2().default)(currentUntracked => {
        const found = currentUntracked.untrackedFiles.find(file => {
          return file.relativePath === depFileRelative;
        });

        if (found) {
          result = found;
        }
      }, ((_this$issues$getIssue = this.issues.getIssue(_componentIssues().IssuesClasses.UntrackedDependencies)) === null || _this$issues$getIssue === void 0 ? void 0 : _this$issues$getIssue.data) || {});
      return result;
    };

    const existing = findExisting();
    const newUntrackedFile = {
      relativePath: depFileRelative,
      existing: false
    }; // If it's already found mark them both as existing

    if (existing) {
      newUntrackedFile.existing = true;
      existing.existing = true;
    }

    const untrackIssue = this.issues.getOrCreate(_componentIssues().IssuesClasses.UntrackedDependencies);
    const untrackedCurrentFile = untrackIssue === null || untrackIssue === void 0 ? void 0 : untrackIssue.data[originFile];

    if (untrackedCurrentFile) {
      untrackedCurrentFile.untrackedFiles.push(newUntrackedFile);
    } else {
      untrackIssue.data[originFile] = {
        nested,
        untrackedFiles: [newUntrackedFile]
      };
    }
  }

  _pushToRelativeComponentsIssues(originFile, componentId) {
    var _this$issues$getOrCre2;

    ((_this$issues$getOrCre2 = this.issues.getOrCreate(_componentIssues().IssuesClasses.RelativeComponents).data)[originFile] || (_this$issues$getOrCre2[originFile] = [])).push(componentId);
  }

  _pushToRelativeComponentsAuthoredIssues(originFile, componentId, importSource, relativePath) {
    var _this$issues$getOrCre3;

    ((_this$issues$getOrCre3 = this.issues.getOrCreate(_componentIssues().IssuesClasses.RelativeComponentsAuthored).data)[originFile] || (_this$issues$getOrCre3[originFile] = [])).push({
      importSource,
      componentId,
      relativePath
    });
  }

  _pushToMissingDependenciesOnFs(originFile, missingFiles) {
    var _this$issues$getOrCre4;

    ((_this$issues$getOrCre4 = this.issues.getOrCreate(_componentIssues().IssuesClasses.MissingDependenciesOnFs).data)[originFile] || (_this$issues$getOrCre4[originFile] = [])).push(...missingFiles);
  }

  _pushToMissingPackagesDependenciesIssues(originFile, missingPackages) {
    var _this$issues$getOrCre5;

    ((_this$issues$getOrCre5 = this.issues.getOrCreate(_componentIssues().IssuesClasses.MissingPackagesDependenciesOnFs).data)[originFile] || (_this$issues$getOrCre5[originFile] = [])).push(...missingPackages);
  }

  _pushToMissingCustomModuleIssues(originFile, componentId) {
    var _this$issues$getOrCre6;

    ((_this$issues$getOrCre6 = this.issues.getOrCreate(_componentIssues().IssuesClasses.MissingCustomModuleResolutionLinks).data)[originFile] || (_this$issues$getOrCre6[originFile] = [])).push(componentId);
  }

  _pushToMissingLinksIssues(originFile, componentId) {
    var _this$issues$getOrCre7;

    ((_this$issues$getOrCre7 = this.issues.getOrCreate(_componentIssues().IssuesClasses.MissingLinks).data)[originFile] || (_this$issues$getOrCre7[originFile] = [])).push(componentId);
  }

  _pushToMissingComponentsIssues(originFile, componentId) {
    var _this$issues$getOrCre8;

    ((_this$issues$getOrCre8 = this.issues.getOrCreate(_componentIssues().IssuesClasses.MissingComponents).data)[originFile] || (_this$issues$getOrCre8[originFile] = [])).push(componentId);
  }

}

exports.default = DependencyResolver;
(0, _defineProperty2().default)(DependencyResolver, "getWorkspacePolicy", void 0);
(0, _defineProperty2().default)(DependencyResolver, "getHarmonyEnvPeersPolicy", void 0);
(0, _defineProperty2().default)(DependencyResolver, "getDepResolverAspectName", void 0);
(0, _defineProperty2().default)(DependencyResolver, "getCoreAspectsPackagesAndIds", void 0);
(0, _defineProperty2().default)(DependencyResolver, "getDevFiles", void 0);