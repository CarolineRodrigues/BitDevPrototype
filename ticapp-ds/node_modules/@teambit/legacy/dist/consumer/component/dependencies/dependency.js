"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _clone2() {
  const data = _interopRequireDefault(require("ramda/src/clone"));

  _clone2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("../../../utils/path");

  _path = function () {
    return data;
  };

  return data;
}

class Dependency {
  constructor(id, relativePaths, packageName) {
    (0, _defineProperty2().default)(this, "id", void 0);
    (0, _defineProperty2().default)(this, "relativePaths", void 0);
    (0, _defineProperty2().default)(this, "packageName", void 0);
    this.id = id;
    this.relativePaths = relativePaths;
    this.packageName = packageName;
  }

  static stripOriginallySharedDir(dependency, manipulateDirData, originallySharedDir) {
    const pathWithoutSharedDir = (pathStr, sharedDir) => {
      if (!sharedDir) return pathStr;
      const partToRemove = `${sharedDir}/`;
      return pathStr.replace(partToRemove, '');
    };

    const depManipulateDir = manipulateDirData.find(manipulateDirItem => manipulateDirItem.id.isEqual(dependency.id));
    dependency.relativePaths.forEach(relativePath => {
      // when custom resolved is used, do not strip the source as it is not used. the actual source
      // is the importSource. strip only the destination as it is relevant when installing
      // dependencies as packages and a link is needed for an internal file
      if (!relativePath.isCustomResolveUsed) {
        relativePath.sourceRelativePath = pathWithoutSharedDir(relativePath.sourceRelativePath, originallySharedDir);
      }

      if (depManipulateDir) {
        relativePath.destinationRelativePath = pathWithoutSharedDir(relativePath.destinationRelativePath, depManipulateDir.originallySharedDir);
      }
    });
  }

  static addWrapDir(dependency, manipulateDirData, componentWrapDir) {
    const pathWithWrapDir = (pathStr, wrapDir) => {
      if (!wrapDir) return pathStr;
      return (0, _path().pathJoinLinux)(wrapDir, pathStr);
    };

    const depManipulateDir = manipulateDirData.find(manipulateDirItem => manipulateDirItem.id.isEqual(dependency.id));
    dependency.relativePaths.forEach(relativePath => {
      if (!relativePath.isCustomResolveUsed) {
        relativePath.sourceRelativePath = pathWithWrapDir(relativePath.sourceRelativePath, componentWrapDir);
      }

      if (depManipulateDir && depManipulateDir.wrapDir) {
        relativePath.destinationRelativePath = pathWithWrapDir(relativePath.destinationRelativePath, depManipulateDir.wrapDir);
      }
    });
  }

  static getClone(dependency) {
    return {
      id: dependency.id,
      relativePaths: (0, _clone2().default)(dependency.relativePaths),
      packageName: dependency.packageName
    };
  }

}

exports.default = Dependency;