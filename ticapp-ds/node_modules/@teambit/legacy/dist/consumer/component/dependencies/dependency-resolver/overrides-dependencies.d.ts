import { BitId, BitIds } from '../../../../bit-id';
import Consumer from '../../../../consumer/consumer';
import { ResolvedPackageData } from '../../../../utils/packages';
import ComponentMap from '../../../bit-map/component-map';
import Component from '../../../component/consumer-component';
import { AllDependencies, FileType } from './dependencies-resolver';
export declare type ManuallyChangedDependencies = {
    dependencies?: string[];
    devDependencies?: string[];
    peerDependencies?: string[];
};
export default class OverridesDependencies {
    component: Component;
    consumer: Consumer;
    componentMap: ComponentMap;
    componentFromModel: Component | null | undefined;
    manuallyRemovedDependencies: ManuallyChangedDependencies;
    manuallyAddedDependencies: ManuallyChangedDependencies;
    missingPackageDependencies: string[];
    constructor(component: Component, consumer: Consumer);
    shouldIgnoreFile(file: string, fileType: FileType): boolean;
    shouldIgnorePackage(packageName: string, fileType: FileType): boolean;
    shouldIgnorePackageByType(packageName: string, field: string): boolean;
    shouldIgnorePeerPackage(packageName: string): boolean;
    shouldIgnoreComponent(componentId: BitId, fileType: FileType): boolean;
    getDependenciesToAddManually(packageJson: Record<string, any> | null | undefined, existingDependencies: AllDependencies): {
        components: Record<string, any>;
        packages: Record<string, any>;
    } | null | undefined;
    _getIgnoredComponentsByField(field: 'devDependencies' | 'dependencies' | 'peerDependencies'): BitId[];
    _getComponentIdToAdd(field: string, dependency: string, dependencyValue: string, idsFromBitmap: BitIds, idsFromModel: BitIds): {
        componentId?: BitId;
        packageName?: string;
    } | undefined;
    _getComponentIdFromPackage(packageName: string, idsFromBitmap: BitIds, idsFromModel: BitIds): BitId | undefined;
    /**
     * This is used to support legacy projects (before harmony were components used @bit as prefix)
     * @param field
     * @param dependency
     * @param dependencyValue
     * @param idsFromBitmap
     * @param idsFromModel
     */
    _getComponentIdToAddForLegacyWs(field: string, dependency: string, dependencyValue: string, idsFromBitmap: BitIds, idsFromModel: BitIds): BitId | undefined;
    /**
     * For legacy use only, do not use it on harmony projects
     * This will parse the package name and look for the parsed result in the bitmap / ids from model and return the matched id if exist
     * @param dependency
     * @param idsFromBitmap
     * @param idsFromModel
     */
    _getExistingComponentIdFromLegacyPackageName(dependency: string, idsFromBitmap: BitIds, idsFromModel: BitIds): BitId | undefined;
    /**
     * it is possible that a user added the component into the overrides as a package.
     * e.g. `@bit/david.utils.is-string` instead of `@bit/david.utils/is-string`
     * or, if not using bit.cloud, `@bit/utils.is-string` instead of `@bit/utils/is-string`
     */
    _getComponentIdFromLegacyPackageName(idStr: string): string[];
    _manuallyAddPackage(field: string, dependency: string, dependencyValue: string, packageJson: Record<string, any> | null | undefined): Record<string, any> | null | undefined;
    _addManuallyRemovedDep(field: string, value: string): void;
    _addManuallyAddedDep(field: string, value: string): void;
    _resolvePackageData(packageName: string): ResolvedPackageData | undefined;
}
