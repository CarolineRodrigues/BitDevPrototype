import { IssuesList } from '@teambit/component-issues';
import BitId from '../../bit-id/bit-id';
import BitIds from '../../bit-id/bit-ids';
import { BuildStatus } from '../../constants';
import IsolatedEnvironment from '../../environment/environment';
import { IsolateOptions } from '../../environment/isolator';
import { Doclet } from '../../jsdoc/types';
import CompilerExtension from '../../legacy-extensions/compiler-extension';
import { EnvType } from '../../legacy-extensions/env-extension-types';
import TesterExtension from '../../legacy-extensions/tester-extension';
import ComponentWithDependencies from '../../scope/component-dependencies';
import { ScopeListItem } from '../../scope/models/model-component';
import Version, { Log } from '../../scope/models/version';
import Scope from '../../scope/scope';
import { PathLinux, PathOsBased, PathOsBasedAbsolute, PathOsBasedRelative } from '../../utils/path';
import BitMap from '../bit-map';
import ComponentMap, { ComponentOrigin } from '../bit-map/component-map';
import { ManipulateDirItem } from '../component-ops/manipulate-dir';
import { Dist, License, SourceFile } from '../component/sources';
import ComponentConfig from '../config';
import ComponentOverrides from '../config/component-overrides';
import { ExtensionDataList } from '../config/extension-data';
import Consumer from '../consumer';
import SpecsResults from '../specs-results';
import { Dependencies, Dependency } from './dependencies';
import { ManuallyChangedDependencies } from './dependencies/dependency-resolver/overrides-dependencies';
import PackageJsonFile from './package-json-file';
import DataToPersist from './sources/data-to-persist';
import Dists from './sources/dists';
export declare type CustomResolvedPath = {
    destinationPath: PathLinux;
    importSource: string;
};
export declare type InvalidComponent = {
    id: BitId;
    error: Error;
    component: Component | undefined;
};
export declare type ComponentProps = {
    name: string;
    version?: string;
    scope?: string | null;
    lang?: string;
    bindingPrefix?: string;
    mainFile: PathOsBased;
    compiler?: CompilerExtension;
    tester: TesterExtension;
    bitJson?: ComponentConfig;
    dependencies?: Dependency[];
    devDependencies?: Dependency[];
    flattenedDependencies?: BitIds;
    packageDependencies?: Record<string, any>;
    devPackageDependencies?: Record<string, any>;
    peerPackageDependencies?: Record<string, any>;
    compilerPackageDependencies?: Record<string, any>;
    testerPackageDependencies?: Record<string, any>;
    customResolvedPaths?: CustomResolvedPath[];
    overrides: ComponentOverrides;
    defaultScope: string | null;
    packageJsonFile?: PackageJsonFile;
    packageJsonChangedProps?: {
        [key: string]: any;
    };
    files: SourceFile[];
    docs?: Doclet[];
    dists?: Dist[];
    mainDistFile?: PathLinux;
    specsResults?: SpecsResults;
    license?: License;
    deprecated?: boolean;
    origin: ComponentOrigin;
    log?: Log;
    schema?: string;
    scopesList?: ScopeListItem[];
    extensions: ExtensionDataList;
    componentFromModel?: Component;
    buildStatus?: BuildStatus;
};
export default class Component {
    static registerOnComponentConfigLoading(extId: any, func: (id: any) => any): void;
    static registerOnComponentConfigLegacyLoading(extId: any, func: (id: any, config: any) => any): void;
    static registerOnComponentOverridesLoading(extId: any, func: (id: any, config: any) => any): void;
    name: string;
    version: string | undefined;
    previouslyUsedVersion: string | undefined;
    scope: string | null | undefined;
    lang: string;
    bindingPrefix: string;
    mainFile: PathOsBased;
    compiler: CompilerExtension | undefined;
    tester: TesterExtension | undefined;
    bitJson: ComponentConfig | undefined;
    dependencies: Dependencies;
    devDependencies: Dependencies;
    flattenedDependencies: BitIds;
    packageDependencies: any;
    devPackageDependencies: any;
    peerPackageDependencies: any;
    compilerPackageDependencies: Record<string, any>;
    testerPackageDependencies: Record<string, any>;
    manuallyRemovedDependencies: ManuallyChangedDependencies;
    manuallyAddedDependencies: ManuallyChangedDependencies;
    overrides: ComponentOverrides;
    docs: Doclet[] | undefined;
    files: SourceFile[];
    dists: Dists;
    specsResults: SpecsResults[] | undefined;
    license: License | undefined;
    log: Log | undefined;
    writtenPath?: PathOsBasedRelative;
    dependenciesSavedAsComponents: boolean | undefined;
    originallySharedDir: PathLinux | undefined;
    _wasOriginallySharedDirStripped: boolean | undefined;
    wrapDir: PathLinux | undefined;
    loadedFromFileSystem: boolean;
    schema?: string;
    componentMap: ComponentMap | undefined;
    componentFromModel: Component | undefined;
    isolatedEnvironment: IsolatedEnvironment;
    issues: IssuesList;
    deprecated: boolean;
    defaultScope: string | null;
    origin: ComponentOrigin;
    customResolvedPaths: CustomResolvedPath[];
    _isModified: boolean;
    packageJsonFile: PackageJsonFile | undefined;
    packageJsonChangedProps: Record<string, any> | undefined;
    _currentlyUsedVersion: BitId;
    pendingVersion: Version;
    dataToPersist: DataToPersist;
    scopesList: ScopeListItem[] | undefined;
    extensions: ExtensionDataList;
    _capsuleDir?: string;
    buildStatus?: BuildStatus;
    get id(): BitId;
    constructor({ name, version, scope, files, lang, bindingPrefix, mainFile, compiler, tester, bitJson, dependencies, devDependencies, flattenedDependencies, packageDependencies, devPackageDependencies, peerPackageDependencies, compilerPackageDependencies, testerPackageDependencies, componentFromModel, overrides, schema, defaultScope, packageJsonFile, packageJsonChangedProps, docs, dists, mainDistFile, specsResults, license, log, deprecated, origin, customResolvedPaths, scopesList, extensions, buildStatus, }: ComponentProps);
    validateComponent(): void;
    /**
     * Warning: this method does not return a deep copy for all objects in this class, only for the
     * ones you see in the implementation below.
     * Implement deep copy of other properties if needed
     */
    clone(): Component;
    getTmpFolder(workspacePrefix?: PathOsBased): PathOsBased;
    setDependencies(dependencies?: Dependency[]): void;
    setDevDependencies(devDependencies?: Dependency[]): void;
    setDists(dists: Dist[] | undefined, mainDistFile?: PathOsBased | undefined): void;
    getFileExtension(): string;
    getDetachedCompiler(consumer: Consumer | undefined): Promise<boolean>;
    getDetachedTester(consumer: Consumer | undefined): Promise<boolean>;
    _isEnvDetach(consumer: Consumer | undefined, envType: EnvType): Promise<boolean>;
    _getHomepage(): string | undefined;
    injectConfig(consumerPath: PathOsBased, bitMap: BitMap, force?: boolean | undefined): Promise<any>;
    get extensionDependencies(): Dependencies;
    getAllDependencies(): Dependency[];
    getAllDependenciesCloned(): Dependencies;
    getAllNonEnvsDependencies(): Dependency[];
    getAllDependenciesIds(): BitIds;
    get depsIdsGroupedByType(): {
        dependencies: BitIds;
        devDependencies: BitIds;
        extensionDependencies: BitIds;
    };
    hasDependencies(): boolean;
    getAllFlattenedDependencies(): BitId[];
    /**
     * Before writing the files into the file-system, remove the path-prefix that is shared among the main component files
     * and its dependencies. It helps to avoid large file-system paths.
     *
     * This is relevant for IMPORTED and NESTED components only as the author may have long paths
     * that are not needed for whoever imports it. AUTHORED components are written as is.
     *
     * @see sources.consumerComponentToVersion() for the opposite action. meaning, adding back the sharedDir.
     */
    stripOriginallySharedDir(manipulateDirData: ManipulateDirItem[]): void;
    /**
     * components added since v14.8.0 have "rootDir" in .bitmap, which is mostly the same as the
     * sharedDir. so, if rootDir is found, no need to strip/add the sharedDir as the files are
     * already relative to the sharedDir rather than the author workspace.
     */
    get ignoreSharedDir(): boolean;
    get isLegacy(): boolean;
    addWrapperDir(manipulateDirData: ManipulateDirItem[]): void;
    addSharedDir(pathStr: string): PathLinux;
    cloneFilesWithSharedDir(): SourceFile[];
    build({ scope, save, consumer, noCache, verbose, dontPrintEnvMsg, directory, keep, }: {
        scope: Scope;
        save?: boolean;
        consumer?: Consumer;
        noCache?: boolean;
        directory?: string;
        verbose?: boolean;
        dontPrintEnvMsg?: boolean;
        keep?: boolean;
    }): Promise<Dists | undefined>;
    runSpecs({ scope, rejectOnFailure, // reject when some (or all) of the tests were failed. relevant when running tests during 'bit tag'
    consumer, save, verbose, dontPrintEnvMsg, isolated, directory, keep, }: {
        scope: Scope;
        rejectOnFailure?: boolean;
        consumer?: Consumer;
        save?: boolean;
        verbose?: boolean;
        dontPrintEnvMsg?: boolean;
        isolated?: boolean;
        directory?: string;
        keep?: boolean;
    }): Promise<SpecsResults | undefined>;
    isolate(scope: Scope, opts: IsolateOptions): Promise<string>;
    toObject(): Record<string, any>;
    toString(): string;
    copyFilesIntoDists(): void;
    setOriginallySharedDir(manipulateDirData: ManipulateDirItem[]): void;
    static isComponentInvalidByErrorType(err: Error): boolean;
    toComponentWithDependencies(consumer: Consumer): Promise<ComponentWithDependencies>;
    copyAllDependenciesFromModel(): void;
    static fromObject(object: Record<string, any>): Component;
    static fromString(str: string): Promise<Component>;
    static loadFromFileSystem({ bitDir, componentMap, id, consumer, }: {
        bitDir: PathOsBasedAbsolute;
        componentMap: ComponentMap;
        id: BitId;
        consumer: Consumer;
    }): Promise<Component>;
}
