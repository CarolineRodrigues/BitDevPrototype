import { ReleaseType } from 'semver';
import { BitId, BitIds } from '../bit-id';
import { BitIdStr } from '../bit-id/bit-id';
import { LocalLaneId } from '../lane-id/lane-id';
import CompilerExtension from '../legacy-extensions/compiler-extension';
import EnvExtension from '../legacy-extensions/env-extension';
import { EnvType } from '../legacy-extensions/env-extension-types';
import TesterExtension from '../legacy-extensions/tester-extension';
import { ComponentWithDependencies, Scope } from '../scope';
import { Lane, ModelComponent, Version } from '../scope/models';
import { PathAbsolute, PathLinuxRelative, PathOsBased, PathOsBasedAbsolute, PathOsBasedRelative, PathRelative } from '../utils/path';
import BitMap from './bit-map/bit-map';
import Component from './component';
import { ComponentStatus, ComponentStatusLoader, ComponentStatusResult } from './component-ops/component-status-loader';
import ComponentLoader from './component/component-loader';
import { InvalidComponent } from './component/consumer-component';
import { ILegacyWorkspaceConfig } from './config';
import { WorkspaceConfigProps } from './config/workspace-config';
import DirStructure from './dir-structure/dir-structure';
declare type ConsumerProps = {
    projectPath: string;
    config: ILegacyWorkspaceConfig;
    scope: Scope;
    created?: boolean;
    isolated?: boolean;
    addedGitHooks?: string[] | undefined;
    existingGitHooks: string[] | undefined;
};
/**
 * @todo: change the class name to Workspace
 */
export default class Consumer {
    projectPath: PathOsBased;
    created: boolean;
    config: ILegacyWorkspaceConfig;
    scope: Scope;
    bitMap: BitMap;
    isolated: boolean;
    addedGitHooks: string[] | undefined;
    existingGitHooks: string[] | undefined;
    _dirStructure: DirStructure;
    _componentsStatusCache: Record<string, any>;
    packageManagerArgs: string[];
    componentLoader: ComponentLoader;
    componentStatusLoader: ComponentStatusLoader;
    packageJson: any;
    onCacheClear: Array<() => void>;
    constructor({ projectPath, config, scope, created, isolated, addedGitHooks, existingGitHooks, }: ConsumerProps);
    setBitMap(): Promise<void>;
    get compiler(): Promise<CompilerExtension | undefined>;
    get tester(): Promise<TesterExtension | undefined>;
    get dirStructure(): DirStructure;
    get componentFsCache(): import("./component/component-fs-cache").ComponentFsCache;
    get bitmapIdsFromCurrentLane(): BitIds;
    get bitMapIdsFromAllLanes(): BitIds;
    clearCache(): void;
    getEnv(envType: EnvType, context: Record<string, any> | undefined): Promise<EnvExtension | undefined>;
    getTmpFolder(fullPath?: boolean): PathOsBased;
    getCurrentLaneId(): LocalLaneId;
    getCurrentLaneObject(): Promise<Lane | null>;
    cleanTmpFolder(): Promise<void>;
    /**
     * Running migration process for consumer to update the stores (.bit.map.json) to the current version
     *
     * @param {any} verbose - print debug logs
     * @returns {Object} - wether the process run and wether it succeeded
     * @memberof Consumer
     */
    migrate(verbose: any): Record<string, any>;
    write(): Promise<Consumer>;
    getPath(): PathOsBased;
    toAbsolutePath(pathStr: PathRelative): PathOsBasedAbsolute;
    getPathRelativeToConsumer(pathToCheck: PathRelative | PathAbsolute): PathOsBasedRelative;
    getParsedId(id: BitIdStr, useVersionFromBitmap?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId;
    getParsedIdIfExist(id: BitIdStr, useVersionFromBitmap?: boolean, searchWithoutScopeInProvidedId?: boolean): BitId | undefined;
    /**
     * throws a ComponentNotFound exception if not found in the model
     */
    loadComponentFromModel(id: BitId): Promise<Component>;
    /**
     * return a component only when it's stored locally.
     * don't go to any remote server and don't throw an exception if the component is not there.
     */
    loadComponentFromModelIfExist(id: BitId): Promise<Component | undefined>;
    loadAllVersionsOfComponentFromModel(id: BitId): Promise<Component[]>;
    loadComponentWithDependenciesFromModel(id: BitId, throwIfNotExist?: boolean): Promise<ComponentWithDependencies>;
    loadComponent(id: BitId): Promise<Component>;
    loadComponentForCapsule(id: BitId): Promise<Component>;
    loadComponents(ids: BitIds, throwOnFailure?: boolean): Promise<{
        components: Component[];
        invalidComponents: InvalidComponent[];
    }>;
    importEnvironment(bitId: BitId, verbose: boolean | undefined, dontPrintEnvMsg: boolean): Promise<ComponentWithDependencies[]>;
    importComponentsLegacy(ids: BitIds, withAllVersions: boolean, saveDependenciesAsComponents?: boolean): Promise<ComponentWithDependencies[]>;
    importComponentsHarmony(ids: BitIds, withAllVersions: boolean, lanes?: Lane[]): Promise<ComponentWithDependencies[]>;
    importComponentsObjectsHarmony(ids: BitIds, fromOriginalScope?: boolean, allHistory?: boolean): Promise<ComponentWithDependencies[]>;
    shouldDependenciesSavedAsComponents(bitIds: BitId[], saveDependenciesAsComponents?: boolean): Promise<{
        id: BitId;
        saveDependenciesAsComponents: boolean;
    }[]>;
    /**
     * By default, the dists paths are inside the component.
     * If dist attribute is populated in bit.json, the paths are in consumer-root/dist-target.
     */
    shouldDistsBeInsideTheComponent(): boolean;
    listComponentsForAutoTagging(modifiedComponents: BitIds): Promise<Component[]>;
    /**
     * Check whether a model representation and file-system representation of the same component is the same.
     * The way how it is done is by converting the file-system representation of the component into
     * a Version object. Once this is done, we have two Version objects, and we can compare their hashes
     */
    isComponentModified(componentFromModel: Version, componentFromFileSystem: Component): Promise<boolean>;
    getManyComponentsStatuses(ids: BitId[]): Promise<ComponentStatusResult[]>;
    getComponentStatusById(id: BitId): Promise<ComponentStatus>;
    updateNextVersionOnBitmap(taggedComponents: Component[], exactVersion?: string | null, releaseType?: ReleaseType, preRelease?: string): void;
    updateComponentsVersions(components: Array<ModelComponent | Component>): Promise<any>;
    getComponentIdFromNodeModulesPath(requirePath: string, bindingPrefix: string): BitId;
    /**
     * e.g.
     * input: @bit/my-scope.my-name/internal-path.js
     * output: { packageName: '@bit/my-scope', internalPath: 'internal-path.js' }
     */
    splitPackagePathToNameAndFile(packagePath: string): {
        packageName: string;
        internalPath: string;
    };
    private stripNodeModulesFromPackagePath;
    composeRelativeComponentPath(bitId: BitId): PathLinuxRelative;
    composeComponentPath(bitId: BitId): PathOsBasedAbsolute;
    composeRelativeDependencyPath(bitId: BitId): PathOsBased;
    composeDependencyPath(bitId: BitId): PathOsBased;
    static create(projectPath: PathOsBasedAbsolute, noGit?: boolean, workspaceConfigProps?: WorkspaceConfigProps): Promise<Consumer>;
    static _getScopePath(projectPath: PathOsBasedAbsolute, noGit: boolean): PathOsBasedAbsolute;
    static ensure(projectPath: PathOsBasedAbsolute, standAlone?: boolean, workspaceConfigProps?: WorkspaceConfigProps): Promise<Consumer>;
    /**
     * if resetHard, delete consumer-files: bitMap and bit.json and also the local scope (.bit dir).
     * otherwise, delete the consumer-files only when they are corrupted
     */
    static reset(projectPath: PathOsBasedAbsolute, resetHard: boolean, noGit?: boolean): Promise<void>;
    resetNew(): Promise<void>;
    static createIsolatedWithExistingScope(consumerPath: PathOsBased, scope: Scope): Promise<Consumer>;
    static locateProjectScope(projectPath: string): string | undefined;
    static load(currentPath: PathOsBasedAbsolute): Promise<Consumer>;
    /**
     * legacy is a workspace uses the old bit.json or "bit" prop of package.json.
     * new workspaces use workspace.jsonc file
     */
    get isLegacy(): boolean;
    /**
     * clean up removed components from bitmap
     * @param {BitIds} componentsToRemoveFromFs - delete component that are used by other components.
     */
    cleanFromBitMap(componentsToRemoveFromFs: BitIds): Promise<void>;
    addRemoteAndLocalVersionsToDependencies(component: Component, loadedFromFileSystem: boolean): Promise<void>;
    getAuthoredAndImportedDependentsIdsOf(components: Component[]): Promise<BitIds>;
    getAuthoredAndImportedDependentsComponentsOf(components: Component[]): Promise<Component[]>;
    injectConf(componentId: BitId, force: boolean): Promise<any>;
    _getEnvProps(envType: EnvType, context: Record<string, any> | undefined): {
        name: string;
        consumerPath: string;
        scopePath: string;
        rawConfig: Record<string, any>;
        files: string[];
        bitJsonPath: string;
        options: import("../legacy-extensions/base-extension").BaseExtensionOptions;
        envType: EnvType;
        context: Record<string, any> | undefined;
    } | undefined;
    writeBitMap(): Promise<void>;
    onDestroy(): Promise<void>;
}
export {};
