"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat-map.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.unscopables.flat-map.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _isNil2() {
  const data = _interopRequireDefault(require("ramda/src/isNil"));

  _isNil2 = function () {
    return data;
  };

  return data;
}

function _reject2() {
  const data = _interopRequireDefault(require("ramda/src/reject"));

  _reject2 = function () {
    return data;
  };

  return data;
}

function _difference2() {
  const data = _interopRequireDefault(require("ramda/src/difference"));

  _difference2 = function () {
    return data;
  };

  return data;
}

function _fromPairs2() {
  const data = _interopRequireDefault(require("ramda/src/fromPairs"));

  _fromPairs2 = function () {
    return data;
  };

  return data;
}

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _componentVersion() {
  const data = require("@teambit/component-version");

  _componentVersion = function () {
    return data;
  };

  return data;
}

function _listScope() {
  const data = require("../../api/consumer/lib/list-scope");

  _listScope = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("../../scope/scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _checkoutVersion() {
  const data = require("../versions-ops/checkout-version");

  _checkoutVersion = function () {
    return data;
  };

  return data;
}

function _mergeVersion() {
  const data = require("../versions-ops/merge-version");

  _mergeVersion = function () {
    return data;
  };

  return data;
}

function _componentsPendingMerge() {
  const data = _interopRequireDefault(require("./exceptions/components-pending-merge"));

  _componentsPendingMerge = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("./many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

class ImportComponents {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore
  constructor(consumer, options) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "options", void 0);
    (0, _defineProperty2().default)(this, "mergeStatus", void 0);
    (0, _defineProperty2().default)(this, "laneObjects", []);
    (0, _defineProperty2().default)(this, "divergeData", []);
    this.consumer = consumer;
    this.scope = consumer.scope;
    this.options = options;
  }

  importComponents() {
    _loader().default.start(_loaderMessages().BEFORE_IMPORT_ACTION);

    this.options.saveDependenciesAsComponents = this.consumer.config._saveDependenciesAsComponents;

    if (this.consumer.isLegacy && !this.options.writePackageJson) {
      // if package.json is not written, it's impossible to install the packages and dependencies as npm packages
      this.options.installNpmPackages = false;
      this.options.saveDependenciesAsComponents = true;
    }

    if (!this.options.lanes && (!this.options.ids || (0, _isEmpty2().default)(this.options.ids))) {
      return this.importAccordingToBitMap();
    }

    return this.importSpecificComponents();
  }

  async importSpecificComponents() {
    _logger().default.debug(`importSpecificComponents, Ids: ${this.options.ids.join(', ')}`);

    const bitIds = await this._getBitIds();
    const beforeImportVersions = await this._getCurrentVersions(bitIds);
    await this._throwForPotentialIssues(bitIds);
    const componentsWithDependencies = this.consumer.isLegacy ? await this.consumer.importComponentsLegacy(bitIds, true, this.options.saveDependenciesAsComponents) : await this.consumer.importComponentsHarmony(bitIds, true, this.laneObjects);
    await this._throwForModifiedOrNewDependencies(componentsWithDependencies);

    if (this.laneObjects && this.options.objectsOnly) {
      // merge the lane objects
      const mergeAllLanesResults = await (0, _pMapSeries().default)(this.laneObjects, laneObject => this.scope.sources.mergeLane(laneObject, true));
      const mergedLanes = mergeAllLanesResults.map(result => result.mergeLane);
      await Promise.all(mergedLanes.map(mergedLane => this.scope.lanes.saveLane(mergedLane)));
    }

    const componentsWithDependenciesFiltered = this._filterComponentsWithLowerVersions(componentsWithDependencies);

    await this._fetchDivergeData(componentsWithDependenciesFiltered);

    this._throwForDivergedHistory();

    await this._writeToFileSystem(componentsWithDependenciesFiltered);
    await this._saveLaneDataIfNeeded(componentsWithDependenciesFiltered);
    const importDetails = await this._getImportDetails(beforeImportVersions, componentsWithDependencies);
    return {
      dependencies: componentsWithDependenciesFiltered,
      importDetails
    };
  }

  async _fetchDivergeData(componentsWithDependencies) {
    await Promise.all(componentsWithDependencies.map(async ({
      component
    }) => {
      const modelComponent = await this.scope.getModelComponent(component.id);
      await modelComponent.setDivergeData(this.scope.objects, undefined, false);
      this.divergeData.push(modelComponent);
    }));
  }

  _throwForDivergedHistory() {
    if (this.options.merge || this.options.objectsOnly) return;
    const divergedComponents = this.divergeData.filter(modelComponent => modelComponent.getDivergeData().isDiverged());

    if (divergedComponents.length) {
      const divergeData = divergedComponents.map(modelComponent => ({
        id: modelComponent.id(),
        snapsLocal: modelComponent.getDivergeData().snapsOnLocalOnly.length,
        snapsRemote: modelComponent.getDivergeData().snapsOnRemoteOnly.length
      }));
      throw new (_componentsPendingMerge().default)(divergeData);
    }
  }
  /**
   * it can happen for example when importing a component with `--dependent` flag and the component has
   * the same dependent with different versions. we only want the one with the higher version
   */


  _filterComponentsWithLowerVersions(componentsWithDependencies) {
    return componentsWithDependencies.filter(comp => {
      const sameIdHigherVersion = componentsWithDependencies.find(c => !c.component.id.isEqual(comp.component.id) && c.component.id.isEqualWithoutVersion(comp.component.id) && (0, _componentVersion().isTag)(c.component.id.version) && (0, _componentVersion().isTag)(comp.component.id.version) && _semver().default.gt(c.component.id.version, comp.component.id.version));
      return !sameIdHigherVersion;
    });
  }

  async _getBitIds() {
    const bitIds = [];

    if (this.options.lanes && !this.options.skipLane) {
      const idsToFilter = [];
      await Promise.all(this.options.ids.map(async idStr => {
        const ids = [];

        if ((0, _hasWildcard().default)(idStr)) {
          const remoteIdsByWildcard = await (0, _listScope().getRemoteBitIdsByWildcards)(idStr);
          ids.push(...remoteIdsByWildcard);
        } else {
          ids.push(_bitId().BitId.parse(idStr, true));
        }

        if (ids.some(id => {
          var _this$options$lanes;

          return id.scope === ((_this$options$lanes = this.options.lanes) === null || _this$options$lanes === void 0 ? void 0 : _this$options$lanes.laneIds[0].scope);
        })) {
          idsToFilter.push(...ids);
        }
      }));
      await this.populateBitIdsFromLanes(bitIds, idsToFilter);
    } else {
      await Promise.all(this.options.ids.map(async idStr => {
        if ((0, _hasWildcard().default)(idStr)) {
          const ids = await (0, _listScope().getRemoteBitIdsByWildcards)(idStr);

          _loader().default.start(_loaderMessages().BEFORE_IMPORT_ACTION); // it stops the previous loader of BEFORE_REMOTE_LIST


          bitIds.push(...ids);
        } else {
          bitIds.push(_bitId().BitId.parse(idStr, true)); // we don't support importing without a scope name
        }
      }));
    }

    if (this.options.importDependenciesDirectly || this.options.importDependents) {
      const graphs = await this._getComponentsGraphs(bitIds);

      if (this.options.importDependenciesDirectly) {
        const dependenciesIds = this._getDependenciesFromGraph(bitIds, graphs);

        bitIds.push(...dependenciesIds);
      }

      if (this.options.importDependents) {
        const dependentsIds = this._getDependentsFromGraph(bitIds, graphs);

        bitIds.push(...dependentsIds);
      }
    }

    return _bitId().BitIds.uniqFromArray(bitIds);
  }

  async populateBitIdsFromLanes(bitIds, idsToFilter) {
    if (!this.options.lanes) return;
    this.laneObjects = this.options.lanes.lanes;
    const bitIdsFromLane = this.laneObjects.flatMap(lane => lane.toBitIds());
    const filteredIds = idsToFilter.length > 0 ? bitIdsFromLane.filter(bitId => idsToFilter.find(idToFilter => idToFilter.isEqualWithoutVersion(bitId))) : bitIdsFromLane;
    bitIds.push(...filteredIds);
  }

  _getDependenciesFromGraph(bitIds, graphs) {
    const dependencies = bitIds.map(bitId => {
      const componentGraph = graphs.find(graph => graph.scopeName === bitId.scope);

      if (!componentGraph) {
        throw new Error(`unable to find a graph for ${bitId.toString()}`);
      }

      const dependenciesInfo = componentGraph.getDependenciesInfo(bitId);
      return dependenciesInfo.map(d => d.id);
    });
    return (0, _flatten2().default)(dependencies);
  }

  _getDependentsFromGraph(bitIds, graphs) {
    const dependents = bitIds.map(bitId => {
      const componentGraph = graphs.find(graph => graph.scopeName === bitId.scope);

      if (!componentGraph) {
        throw new Error(`unable to find a graph for ${bitId.toString()}`);
      }

      const dependentsInfo = componentGraph.getDependentsInfo(bitId);
      return dependentsInfo.map(d => d.id);
    });
    return (0, _flatten2().default)(dependents);
  }

  async _getComponentsGraphs(bitIds) {
    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.consumer.scope);
    return remotes.scopeGraphs(bitIds, this.consumer.scope);
  }

  async importAccordingToBitMap() {
    this.options.objectsOnly = !this.options.merge && !this.options.override;
    const authoredExportedComponents = this.consumer.bitMap.getAuthoredExportedComponents(); // this is probably not needed anymore because the build-one-graph already imports all
    // missing objects.
    // const idsOfDepsInstalledAsPackages = await this.getIdsOfDepsInstalledAsPackages();
    // @todo: when .bitmap has a remote-lane, it should import the lane object as well

    const importedComponents = this.consumer.bitMap.getAllIdsAvailableOnLane([_constants().COMPONENT_ORIGINS.IMPORTED]);

    const componentsIdsToImport = _bitId().BitIds.fromArray([...authoredExportedComponents, ...importedComponents // ...idsOfDepsInstalledAsPackages,
    ]);

    let compiler;
    let tester;

    if ((0, _isEmpty2().default)(componentsIdsToImport)) {
      if (!this.options.withEnvironments) {
        throw new (_exceptions().NothingToImport)();
      }

      compiler = await this.consumer.compiler;
      tester = await this.consumer.tester;

      if (!tester && !compiler) {
        throw new (_exceptions().NothingToImport)();
      }
    }

    await this._throwForModifiedOrNewComponents(componentsIdsToImport);
    const beforeImportVersions = await this._getCurrentVersions(componentsIdsToImport);
    let componentsAndDependencies = [];

    if (componentsIdsToImport.length) {
      // change all ids version to 'latest'. otherwise, it tries to import local tags/snaps from a remote
      const idsWithLatestVersion = componentsIdsToImport.toVersionLatest();
      componentsAndDependencies = !this.consumer.isLegacy && this.options.objectsOnly ? await this.consumer.importComponentsObjectsHarmony(componentsIdsToImport, this.options.fromOriginalScope, this.options.allHistory) : await this.consumer.importComponentsLegacy(_bitId().BitIds.fromArray(idsWithLatestVersion), true);
      await this._throwForModifiedOrNewDependencies(componentsAndDependencies);
      await this._writeToFileSystem(componentsAndDependencies);
    }

    const importDetails = await this._getImportDetails(beforeImportVersions, componentsAndDependencies);

    if (this.options.withEnvironments) {
      compiler = compiler || (await this.consumer.compiler);
      tester = tester || (await this.consumer.tester);
      const context = {
        workspaceDir: this.consumer.getPath()
      };
      const envsArgs = [this.consumer.scope, {
        verbose: this.options.verbose
      }, context];
      const envComponents = [];

      if (compiler) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        envComponents.push(await compiler.install(...envsArgs));
      }

      if (tester) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        envComponents.push(await tester.install(...envsArgs));
      }

      return {
        dependencies: componentsAndDependencies,
        envComponents: (0, _flatten2().default)(envComponents),
        importDetails
      };
    }

    return {
      dependencies: componentsAndDependencies,
      importDetails
    };
  }
  /**
   * author might require bit-components that were installed via a package-manager. in that case,
   * the objects are not imported until bit build or bit tag was running. this makes sure to get
   * the objects on 'bit import', so then in the UI, they'll be shown nicely.
   */


  async getIdsOfDepsInstalledAsPackages() {
    if (!this.options.objectsOnly) {
      // this is needed only when importing objects. we don't want these components to be written to the fs
      return [];
    }

    const authoredNonExportedComponentsIds = this.consumer.bitMap.getAuthoredNonExportedComponents();
    const {
      components: authoredNonExportedComponents
    } = await this.consumer.loadComponents(_bitId().BitIds.fromArray(authoredNonExportedComponentsIds), false);
    const dependencies = (0, _flatten2().default)(authoredNonExportedComponents.map(c => c.getAllDependenciesIds()));
    const missingDeps = [];
    await Promise.all(dependencies.map(async dep => {
      if (!dep.hasScope()) return;
      const isInScope = await this.scope.isComponentInScope(dep);
      if (!isInScope) missingDeps.push(dep);
    }));
    return missingDeps;
  }

  async _getCurrentVersions(ids) {
    const versionsP = ids.map(async id => {
      const modelComponent = await this.consumer.scope.getModelComponentIfExist(id.changeVersion(undefined));
      const idStr = id.toStringWithoutVersion();
      if (!modelComponent) return [idStr, []];
      return [idStr, modelComponent.listVersions()];
    });
    const versions = await Promise.all(versionsP);
    return (0, _fromPairs2().default)(versions);
  }
  /**
   * get import details, includes the diff between the versions array before import and after import
   */


  async _getImportDetails(currentVersions, components) {
    const detailsP = components.map(async component => {
      const id = component.component.id;
      const idStr = id.toStringWithoutVersion();
      const beforeImportVersions = currentVersions[idStr];

      if (!beforeImportVersions) {
        throw new Error(`_getImportDetails failed finding ${idStr} in currentVersions, which has ${Object.keys(currentVersions).join(', ')}`);
      }

      const modelComponent = await this.consumer.scope.getModelComponentIfExist(id);
      if (!modelComponent) throw new (_showDoctorError().default)(`imported component ${idStr} was not found in the model`);
      const afterImportVersions = modelComponent.listVersions();
      const versionDifference = (0, _difference2().default)(afterImportVersions, beforeImportVersions);

      const getStatus = () => {
        if (!versionDifference.length) return 'up to date';
        if (!beforeImportVersions.length) return 'added';
        return 'updated';
      };

      const filesStatus = this.mergeStatus && this.mergeStatus[idStr] ? this.mergeStatus[idStr] : null;
      const deprecated = await modelComponent.isDeprecated(this.scope.objects);
      const latestVersion = modelComponent.latest();
      return {
        id: idStr,
        versions: versionDifference,
        latestVersion: versionDifference.includes(latestVersion) ? latestVersion : null,
        status: getStatus(),
        filesStatus,
        missingDeps: component.missingDependencies,
        deprecated
      };
    });
    return Promise.all(detailsP);
  }

  async _throwForPotentialIssues(ids) {
    await this._throwForModifiedOrNewComponents(ids);

    this._throwForDifferentComponentWithSameName(ids);
  }

  async _throwForModifiedOrNewComponents(ids) {
    // the typical objectsOnly option is when a user cloned a project with components tagged to the source code, but
    // doesn't have the model objects. in that case, calling getComponentStatusById() may return an error as it relies
    // on the model objects when there are dependencies
    if (this.options.override || this.options.objectsOnly || this.options.merge) return;
    const componentsStatuses = await this.consumer.getManyComponentsStatuses(ids);
    const modifiedComponents = componentsStatuses.filter(({
      status
    }) => status.modified || status.newlyCreated).map(c => c.id);

    if (modifiedComponents.length) {
      throw new (_generalError().default)(_chalk().default.yellow(`unable to import the following components due to local changes, use --merge flag to merge your local changes or --override to override them\n${modifiedComponents.join('\n')} `));
    }
  }

  async _throwForModifiedOrNewDependencies(componentsAndDependencies) {
    const allDependenciesIds = (0, _flatten2().default)(componentsAndDependencies.map(componentAndDependencies => componentAndDependencies.component.dependencies.getAllIds()));
    await this._throwForModifiedOrNewComponents(allDependenciesIds);
  }
  /**
   * Model Component id() calculation uses id.toString() for the hash.
   * If an imported component has scopereadonly name equals to a local name, both will have the exact same
   * hash and they'll override each other.
   */


  _throwForDifferentComponentWithSameName(ids) {
    ids.forEach(id => {
      const existingId = this.consumer.getParsedIdIfExist(id.toStringWithoutVersion());

      if (existingId && !existingId.hasScope()) {
        throw new (_generalError().default)(`unable to import ${id.toString()}. the component name conflicted with your local component with the same name.
        it's fine to have components with the same name as long as their scope names are different.
        Make sure to export your component first to get a scope and then try importing again`);
      }
    });
  }

  async _getMergeStatus(componentWithDependencies) {
    const component = componentWithDependencies.component;
    const componentStatus = await this.consumer.getComponentStatusById(component.id);
    const mergeStatus = {
      componentWithDependencies,
      mergeResults: null
    };
    if (!componentStatus.modified) return mergeStatus;
    const componentModel = await this.consumer.scope.getModelComponent(component.id);
    const existingBitMapBitId = this.consumer.bitMap.getBitId(component.id, {
      ignoreVersion: true
    });
    const fsComponent = await this.consumer.loadComponent(existingBitMapBitId);
    const currentlyUsedVersion = existingBitMapBitId.version; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const baseComponent = await componentModel.loadVersion(currentlyUsedVersion, this.consumer.scope.objects);
    const otherComponent = await componentModel.loadVersion( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    component.id.version, this.consumer.scope.objects);
    const mergeResults = await (0, _mergeVersion().threeWayMerge)({
      consumer: this.consumer,
      otherComponent,
      otherLabel: component.id.version,
      currentComponent: fsComponent,
      currentLabel: `${currentlyUsedVersion} modified`,
      baseComponent
    });
    mergeStatus.mergeResults = mergeResults;
    return mergeStatus;
  }
  /**
   * 1) when there are conflicts and the strategy is "ours", don't write the imported component to
   * the filesystem, only update bitmap.
   *
   * 2) when there are conflicts and the strategy is "theirs", override the local changes by the
   * imported component. (similar to --override)
   *
   * 3) when there is no conflict or there are conflicts and the strategy is manual, write the files
   * according to the merge result. (done by applyModifiedVersion())
   */


  _updateComponentFilesPerMergeStrategy(componentMergeStatus) {
    const mergeResults = componentMergeStatus.mergeResults;
    if (!mergeResults) return null;
    const component = componentMergeStatus.componentWithDependencies.component;
    const files = component.files;

    if (mergeResults.hasConflicts && this.options.mergeStrategy === _mergeVersion().MergeOptions.ours) {
      const filesStatus = {}; // don't write the files to the filesystem, only bump the bitmap version.

      files.forEach(file => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.unchanged;
      });
      this.consumer.bitMap.updateComponentId(component.id);
      this.consumer.bitMap.hasChanged = true;
      return filesStatus;
    }

    if (mergeResults.hasConflicts && this.options.mergeStrategy === _mergeVersion().MergeOptions.theirs) {
      const filesStatus = {}; // the local changes will be overridden (as if the user entered --override flag for this component)

      files.forEach(file => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.updated;
      });
      return filesStatus;
    }

    const {
      filesStatus,
      modifiedFiles
    } = (0, _checkoutVersion().applyModifiedVersion)(component.files, mergeResults, this.options.mergeStrategy, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    component.originallySharedDir);
    component.files = modifiedFiles;
    return filesStatus;
  }
  /**
   * update the component files if they are modified and there is a merge strategy.
   * returns only the components that need to be written to the filesystem
   */


  async updateAllComponentsAccordingToMergeStrategy(componentsWithDependencies) {
    if (!this.options.merge) return componentsWithDependencies;
    const componentsStatusP = componentsWithDependencies.map(componentWithDependencies => {
      return this._getMergeStatus(componentWithDependencies);
    });
    const componentsStatus = await Promise.all(componentsStatusP);
    const componentWithConflict = componentsStatus.find(component => component.mergeResults && component.mergeResults.hasConflicts);

    if (componentWithConflict && !this.options.mergeStrategy) {
      this.options.mergeStrategy = await (0, _mergeVersion().getMergeStrategyInteractive)();
    }

    this.mergeStatus = {};
    const componentsToWrite = componentsStatus.map(componentStatus => {
      const filesStatus = this._updateComponentFilesPerMergeStrategy(componentStatus);

      const componentWithDependencies = componentStatus.componentWithDependencies;
      if (!filesStatus) return componentWithDependencies;
      this.mergeStatus[componentWithDependencies.component.id.toStringWithoutVersion()] = filesStatus;
      const unchangedFiles = Object.keys(filesStatus).filter(file => filesStatus[file] === _mergeVersion().FileStatus.unchanged);

      if (unchangedFiles.length === Object.keys(filesStatus).length) {
        // all files are unchanged
        return null;
      }

      return componentWithDependencies;
    });
    const removeNulls = (0, _reject2().default)(_isNil2().default);
    return removeNulls(componentsToWrite);
  }

  _shouldSaveLaneData() {
    if (this.options.skipLane || this.options.objectsOnly) {
      return false;
    }

    const currentLaneId = this.consumer.getCurrentLaneId();
    return !currentLaneId.isDefault();
  }

  async _saveLaneDataIfNeeded(componentsWithDependencies) {
    if (!this._shouldSaveLaneData()) {
      return;
    }

    const currentLane = await this.consumer.getCurrentLaneObject();

    if (!currentLane) {
      return; // user on main
    }

    await Promise.all(componentsWithDependencies.map(async compWithDeps => {
      const allComps = [compWithDeps.component, ...compWithDeps.allDependencies];
      const updateAllCompsP = allComps.map(async comp => {
        const modelComponent = await this.scope.getModelComponent(comp.id);
        const ref = modelComponent.getRef(comp.id.version);
        if (!ref) throw new Error(`_saveLaneDataIfNeeded unable to get ref for ${comp.id.toString()}`);
        currentLane.addComponent({
          id: comp.id,
          head: ref
        });
      });
      await Promise.all(updateAllCompsP);
    }));
    await this.scope.lanes.saveLane(currentLane);
  }

  async _writeToFileSystem(componentsWithDependencies) {
    if (this.options.objectsOnly) {
      return;
    }

    const componentsToWrite = await this.updateAllComponentsAccordingToMergeStrategy(componentsWithDependencies);
    const manyComponentsWriter = new (_manyComponentsWriter().default)({
      consumer: this.consumer,
      componentsWithDependencies: componentsToWrite,
      writeToPath: this.options.writeToPath,
      writePackageJson: this.options.writePackageJson,
      addToRootPackageJson: this.options.writePackageJson,
      // no point to add to root if it doesn't have package.json
      writeConfig: this.options.writeConfig,
      writeDists: this.options.writeDists,
      installNpmPackages: this.options.installNpmPackages,
      verbose: this.options.verbose,
      override: this.options.override,
      saveOnLane: this._shouldSaveLaneData()
    });
    await manyComponentsWriter.writeAll();
  }

}

exports.default = ImportComponents;