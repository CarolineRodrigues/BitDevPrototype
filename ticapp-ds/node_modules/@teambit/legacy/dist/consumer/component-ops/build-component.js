"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _environment() {
  const data = _interopRequireDefault(require("../../environment"));

  _environment = function () {
    return data;
  };

  return data;
}

function _isolator() {
  const data = _interopRequireDefault(require("../../environment/isolator"));

  _isolator = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _extensionIsolateResult() {
  const data = _interopRequireDefault(require("../../legacy-extensions/extension-isolate-result"));

  _extensionIsolateResult = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _externalBuildErrors() {
  const data = _interopRequireDefault(require("../component/exceptions/external-build-errors"));

  _externalBuildErrors = function () {
    return data;
  };

  return data;
}

function _invalidCompilerInterface() {
  const data = _interopRequireDefault(require("../component/exceptions/invalid-compiler-interface"));

  _invalidCompilerInterface = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var buildComponent = async function buildComponent({
  component,
  scope,
  save,
  // this is true only when originated from `runAndUpdateCI()`
  consumer,
  noCache,
  directory,
  verbose,
  dontPrintEnvMsg,
  keep
}) {
  _logger().default.debug(`consumer-component.build ${component.id.toString()}`); // @TODO - write SourceMap Type


  if (!component.compiler) {
    if (!consumer || consumer.shouldDistsBeInsideTheComponent()) {
      _logger().default.debug('compiler was not found, nothing to build');

      return undefined;
    }

    _logger().default.debugAndAddBreadCrumb('build-component.buildComponent', 'compiler was not found, however, because the dists are set to be outside the components directory, save the source file as dists');

    component.copyFilesIntoDists();
    return component.dists;
  }

  const bitMap = consumer ? consumer.bitMap : undefined;
  const consumerPath = consumer ? consumer.getPath() : '';
  const componentMap = bitMap && bitMap.getComponentIfExist(component.id);
  let componentDir = consumerPath;

  if (componentMap) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    componentDir = consumerPath && componentMap.rootDir ? path().join(consumerPath, componentMap.rootDir) : undefined;
  }

  const needToRebuild = await _isNeededToReBuild(consumer, component, noCache);

  if (!needToRebuild && !component.dists.isEmpty()) {
    _logger().default.debugAndAddBreadCrumb('build-component.buildComponent', 'skip the build process as the component was not modified, use the dists saved in the model');

    return component.dists;
  }

  _logger().default.debug('compiler found, start building');

  if (component.compiler && !component.compiler.loaded) {
    await component.compiler.install(scope, {
      verbose: !!verbose,
      dontPrintEnvMsg
    }, {
      workspaceDir: consumerPath,
      componentDir,
      dependentId: component.id
    });
  }

  const compilerResults = await _build({
    component,
    consumer,
    componentMap,
    scope,
    keep,
    directory,
    verbose: !!verbose
  });
  const {
    builtFiles,
    mainDist,
    packageJson
  } = compilerResults;
  builtFiles.forEach(file => {
    if (file && (!file.contents || !(0, _utils().isString)(file.contents.toString()))) {
      throw new (_generalError().default)('builder interface has to return object with a code attribute that contains string');
    }
  }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  component.setDists( // @ts-ignore
  builtFiles.map(file => new (_sources().Dist)(file)), mainDist);

  if (save) {
    await scope.sources.updateDist({
      source: component
    });
  }

  if (packageJson && !(0, _isEmpty2().default)(packageJson)) {
    await _updateComponentPackageJson(component, packageJson);
    component.packageJsonChangedProps = Object.assign(component.packageJsonChangedProps || {}, packageJson);
  }

  return component.dists;
};

exports.default = buildComponent;

async function _updateComponentPackageJson(component, packageJsonPropsToAdd) {
  const componentPackageJsonFile = component.packageJsonFile;

  if (!componentPackageJsonFile) {
    _logger().default.debug(`ignore compiler packageJson result as the component ${component.id.toString()} does not have a package.json file`);

    return;
  }

  componentPackageJsonFile.mergePackageJsonObject(packageJsonPropsToAdd); // When running in capsule there is no workspace dir, so no need to update the package.json

  if (componentPackageJsonFile.workspaceDir) {
    await componentPackageJsonFile.write();
  }
}

function _extractAndVerifyCompilerResults(compilerResults) {
  if (Array.isArray(compilerResults)) {
    return {
      builtFiles: compilerResults,
      mainDist: null,
      packageJson: null
    };
  }

  if (typeof compilerResults === 'object') {
    // @ts-ignore yes, it should not contain files, it's only a verification
    if (compilerResults.files && !compilerResults.dists) {
      // previously, the new compiler "action" method expected to get "files", suggest to replace with 'dists'.
      throw new (_generalError().default)('fatal: compiler returned "files" instead of "dists", please change it to "dists"');
    }

    if (!compilerResults.dists) {
      throw new (_generalError().default)('fatal: compiler that returns an object, must include "dists" property');
    }

    if (compilerResults.packageJson) {
      _verifyPackageJsonReturnedByCompiler(compilerResults.packageJson);
    }

    return {
      builtFiles: compilerResults.dists,
      mainDist: compilerResults.mainFile,
      packageJson: compilerResults.packageJson
    };
  }

  throw new (_generalError().default)(`fatal: compiler must return an array or object, instead, got ${typeof compilerResults}`);
}

function _verifyPackageJsonReturnedByCompiler(packageJson) {
  if (typeof packageJson !== 'object') {
    throw new (_generalError().default)(`fatal: compiler must return packageJson as an object, got ${typeof packageJson}`);
  }

  _packageJsonFile().default.propsNonUserChangeable().forEach(prop => {
    if (packageJson[prop]) {
      throw new (_generalError().default)(`fatal: compiler must not return packageJson with "${prop}" property`);
    }
  });
}

async function _build({
  component,
  consumer,
  componentMap,
  scope,
  verbose,
  directory,
  keep
}) {
  const compiler = component.compiler;

  if (!compiler) {
    throw new (_generalError().default)('compiler was not found, nothing to build');
  }

  if (!compiler.action && !compiler.oldAction) {
    throw new (_invalidCompilerInterface().default)(compiler.name);
  }

  const runBuildParams = {
    component,
    consumer,
    scope,
    componentMap,
    verbose
  };

  if (consumer) {
    return _runBuild(_objectSpread(_objectSpread({}, runBuildParams), {}, {
      componentRoot: consumer.getPath()
    }));
  }

  if (component.isolatedEnvironment) {
    return _runBuild(_objectSpread(_objectSpread({}, runBuildParams), {}, {
      componentRoot: component.writtenPath
    }));
  }

  const isolatedEnvironment = new (_environment().default)(scope, directory);

  try {
    await isolatedEnvironment.create();
    const isolateOpts = {
      verbose,
      installNpmPackages: true,
      writePackageJson: true
    };
    const componentWithDependencies = await isolatedEnvironment.isolateComponent(component.id, isolateOpts);
    const isolatedComponent = componentWithDependencies.component;
    const result = await _runBuild(_objectSpread(_objectSpread({}, runBuildParams), {}, {
      componentRoot: isolatedComponent.writtenPath
    }));
    if (!keep) await isolatedEnvironment.destroy();
    return result;
  } catch (err) {
    await isolatedEnvironment.destroy();
    throw err;
  }
} // Ideally it's better to use the dists from the model.
// If there is no consumer, it comes from the scope or isolated environment, which the dists are already saved.
// If there is consumer, check whether the component was modified. If it wasn't, no need to re-build.


async function _isNeededToReBuild(consumer, component, noCache) {
  if (noCache) return true;
  if (!consumer) return false;
  const componentStatus = await consumer.getComponentStatusById(component.id);
  if (componentStatus.modified) return true;
  const areDependenciesChangedP = component.dependencies.getAllIds().map(async dependencyId => {
    const dependencyStatus = await consumer.getComponentStatusById(dependencyId);
    return dependencyStatus.modified;
  });
  const areDependenciesChanged = await Promise.all(areDependenciesChangedP);
  return areDependenciesChanged.some(isDependencyChanged => isDependencyChanged);
}

async function _runBuild({
  component,
  componentRoot,
  consumer,
  scope,
  componentMap,
  verbose
}) {
  const compiler = component.compiler;

  if (!compiler) {
    throw new (_generalError().default)('compiler was not found, nothing to build');
  }

  let rootDistDir = componentRoot ? path().join(componentRoot, _constants().DEFAULT_DIST_DIRNAME) : undefined;
  const consumerPath = consumer ? consumer.getPath() : '';
  const files = component.files.map(file => file.clone());
  let tmpFolderFullPath;
  let componentDir = '';

  if (componentMap) {
    const rootDistDirRelative = component.dists.getDistDir(consumer, componentMap.getRootDir());
    if (consumer) rootDistDir = consumer.toAbsolutePath(rootDistDirRelative);

    if (consumerPath && componentMap.getComponentDir()) {
      componentDir = componentMap.getComponentDir() || '';
    }
  } // TODO: merge with the same function in consumer-component file


  let shouldBuildUponDependenciesChanges;

  const isolateFunc = async ({
    targetDir,
    shouldBuildDependencies,
    installNpmPackages,
    keepExistingCapsule
  }) => {
    shouldBuildUponDependenciesChanges = shouldBuildDependencies;
    const isolator = await _isolator().default.getInstance('fs', scope, consumer, targetDir);
    const componentWithDependencies = await isolator.isolate(component.id, {
      shouldBuildDependencies,
      writeDists: false,
      installNpmPackages,
      keepExistingCapsule
    });
    return new (_extensionIsolateResult().default)(isolator, componentWithDependencies);
  };

  const context = {
    componentObject: component.toObject(),
    rootDistDir,
    componentDir,
    isolate: isolateFunc
  };

  const getBuildResults = async () => {
    try {
      // Change the cwd to make sure we found the needed files
      if (componentRoot) {
        process.chdir(componentRoot);
      }

      if (compiler.action) {
        const actionParams = {
          files,
          rawConfig: compiler.rawConfig,
          dynamicConfig: compiler.dynamicConfig,
          api: compiler.api,
          context
        };
        const result = await Promise.resolve(compiler.action(actionParams));

        if (tmpFolderFullPath) {
          if (verbose) {
            console.log(`\ndeleting tmp directory ${tmpFolderFullPath}`); // eslint-disable-line no-console
          }

          _logger().default.info(`build-components, deleting ${tmpFolderFullPath}`);

          await _fsExtra().default.remove(tmpFolderFullPath);
        }

        return result;
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      return compiler.oldAction(files, rootDistDir, context);
    } catch (e) {
      if (tmpFolderFullPath) {
        _logger().default.info(`build-components, deleting ${tmpFolderFullPath}`);

        _fsExtra().default.removeSync(tmpFolderFullPath);
      } // Some time an external tool might return a complex object or an array of errors
      // See for example this issue: https://github.com/teambit/bit/issues/2023#issuecomment-534952085
      // (The Vue compiler will return an object with different fields such as details, missing, origin, dependencies, module, name, error)


      const errors = e.errors || (e.error ? [e.error] : [e]);
      const err = new (_externalBuildErrors().default)(component.id.toString(), errors);
      throw err;
    }
  };

  const buildResults = await getBuildResults(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  return _objectSpread(_objectSpread({}, _extractAndVerifyCompilerResults(buildResults)), {}, {
    shouldBuildUponDependenciesChanges
  });
}