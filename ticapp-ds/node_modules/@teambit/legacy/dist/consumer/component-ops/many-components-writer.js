"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../links");

  _links = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _installPackages() {
  const data = require("../../npm-client/install-packages");

  _installPackages = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _composeComponentPath() {
  const data = require("../../utils/bit/compose-component-path");

  _composeComponentPath = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = require("../../utils/path");

  _path2 = function () {
    return data;
  };

  return data;
}

function _bitMap() {
  const data = _interopRequireDefault(require("../bit-map"));

  _bitMap = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _componentWriter() {
  const data = _interopRequireDefault(require("./component-writer"));

  _componentWriter = function () {
    return data;
  };

  return data;
}

function _moveComponents() {
  const data = require("./move-components");

  _moveComponents = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * write the components into '/components' dir (or according to the bit.map) and its dependencies in the
 * '/components/.dependencies' dir. Both directories are configurable in bit.json
 * For example: global/a has a dependency my-scope/global/b@1. The directories will be:
 * project/root/components/global/a/impl.js
 * project/root/components/.dependencies/global/b/my-scope/1/impl.js
 *
 * In case there are some same dependencies shared between the components, it makes sure to
 * write them only once.
 */
class ManyComponentsWriter {
  // prints npm results
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // a preparation for the capsule feature
  // whether a component belongs to a lane, needed for populating `onLanesOnly` prop of .bitmap
  // Apply config added by extensions
  constructor(params) {
    var _params$applyPackageJ;

    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "silentPackageManagerResult", void 0);
    (0, _defineProperty2().default)(this, "componentsWithDependencies", void 0);
    (0, _defineProperty2().default)(this, "writeToPath", void 0);
    (0, _defineProperty2().default)(this, "override", void 0);
    (0, _defineProperty2().default)(this, "writePackageJson", void 0);
    (0, _defineProperty2().default)(this, "writeConfig", void 0);
    (0, _defineProperty2().default)(this, "ignoreBitDependencies", void 0);
    (0, _defineProperty2().default)(this, "createNpmLinkFiles", void 0);
    (0, _defineProperty2().default)(this, "writeDists", void 0);
    (0, _defineProperty2().default)(this, "installNpmPackages", void 0);
    (0, _defineProperty2().default)(this, "installPeerDependencies", void 0);
    (0, _defineProperty2().default)(this, "addToRootPackageJson", void 0);
    (0, _defineProperty2().default)(this, "verbose", void 0);
    (0, _defineProperty2().default)(this, "excludeRegistryPrefix", void 0);
    (0, _defineProperty2().default)(this, "installProdPackagesOnly", void 0);
    (0, _defineProperty2().default)(this, "dependenciesIdsCache", void 0);
    (0, _defineProperty2().default)(this, "writtenComponents", void 0);
    (0, _defineProperty2().default)(this, "writtenDependencies", void 0);
    (0, _defineProperty2().default)(this, "isolated", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "basePath", void 0);
    (0, _defineProperty2().default)(this, "saveOnLane", void 0);
    (0, _defineProperty2().default)(this, "packageManager", void 0);
    (0, _defineProperty2().default)(this, "isLegacy", void 0);
    (0, _defineProperty2().default)(this, "applyPackageJsonTransformers", void 0);
    (0, _defineProperty2().default)(this, "resetConfig", void 0);
    this.consumer = params.consumer;
    this.silentPackageManagerResult = params.silentPackageManagerResult;
    this.componentsWithDependencies = params.componentsWithDependencies;
    this.writeToPath = params.writeToPath;
    this.override = this._setBooleanDefault(params.override, true);
    this.isolated = this._setBooleanDefault(params.isolated, false);
    this.writePackageJson = this._setBooleanDefault(params.writePackageJson, true);
    this.writeConfig = this._setBooleanDefault(params.writeConfig, false);
    this.ignoreBitDependencies = params.ignoreBitDependencies;
    this.createNpmLinkFiles = this._setBooleanDefault(params.createNpmLinkFiles, false);
    this.writeDists = this._setBooleanDefault(params.writeDists, true);
    this.installPeerDependencies = this._setBooleanDefault(params.installPeerDependencies, false);
    this.installNpmPackages = this._setBooleanDefault(params.installNpmPackages, true);
    this.addToRootPackageJson = this._setBooleanDefault(params.addToRootPackageJson, true);
    this.verbose = this._setBooleanDefault(params.verbose, false);
    this.installProdPackagesOnly = this._setBooleanDefault(params.installProdPackagesOnly, false);
    this.excludeRegistryPrefix = this._setBooleanDefault(params.excludeRegistryPrefix, false);
    this.dependenciesIdsCache = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.bitMap = this.consumer ? this.consumer.bitMap : new (_bitMap().default)(undefined, undefined, undefined, params.isLegacy);
    this.saveOnLane = params.saveOnLane;
    this.packageManager = params.packageManager;
    this.isLegacy = this.consumer ? this.consumer.isLegacy : params.isLegacy;
    this.applyPackageJsonTransformers = (_params$applyPackageJ = params.applyPackageJsonTransformers) !== null && _params$applyPackageJ !== void 0 ? _params$applyPackageJ : true;
    this.resetConfig = params.resetConfig;
    if (this.consumer && !this.isolated) this.basePath = this.consumer.getPath();
  }

  static registerExternalInstaller(installer) {
    this.externalInstaller = installer;
  }

  _setBooleanDefault(field, defaultValue) {
    return typeof field === 'undefined' ? defaultValue : Boolean(field);
  }

  async writeAll() {
    await this._writeComponentsAndDependencies();
    await this._installPackages();
    await this._writeLinks();

    _logger().default.debug('ManyComponentsWriter, Done!');
  }

  async _writeComponentsAndDependencies() {
    _logger().default.debug('ManyComponentsWriter, _writeComponentsAndDependencies');

    await this._populateComponentsFilesToWrite();
    if (this.isLegacy) await this._populateComponentsDependenciesToWrite();

    this._moveComponentsIfNeeded();

    await this._persistComponentsData();
  }

  async _installPackages() {
    _logger().default.debug('ManyComponentsWriter, _installPackages');

    if (this.consumer && this.consumer.isLegacy) {
      await packageJsonUtils().addWorkspacesToPackageJson(this.consumer, this.writeToPath);

      if (this.addToRootPackageJson && this.consumer) {
        await packageJsonUtils().addComponentsToRoot(this.consumer, this.writtenComponents);
      }
    }

    await this._installPackagesIfNeeded();
  }

  async _writeLinks() {
    _logger().default.debug('ManyComponentsWriter, _writeLinks');

    const links = await this._getAllLinks();

    if (this.basePath) {
      links.addBasePath(this.basePath);
    }

    await links.persistAllToFS();
  }

  async _persistComponentsData() {
    var _this$consumer, _this$consumer$config;

    const dataToPersist = new (_dataToPersist().default)();
    this.componentsWithDependencies.forEach(componentWithDeps => {
      const allComponents = [componentWithDeps.component, ...componentWithDeps.allDependencies];
      allComponents.forEach(component => dataToPersist.merge(component.dataToPersist));
    });
    const componentsConfig = (_this$consumer = this.consumer) === null || _this$consumer === void 0 ? void 0 : (_this$consumer$config = _this$consumer.config) === null || _this$consumer$config === void 0 ? void 0 : _this$consumer$config.componentsConfig;

    if (componentsConfig !== null && componentsConfig !== void 0 && componentsConfig.hasChanged) {
      var _this$consumer2;

      const jsonFiles = await ((_this$consumer2 = this.consumer) === null || _this$consumer2 === void 0 ? void 0 : _this$consumer2.config.toVinyl(this.consumer.getPath()));

      if (jsonFiles) {
        dataToPersist.addManyFiles(jsonFiles);
      }
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    dataToPersist.addBasePath(this.basePath);
    await dataToPersist.persistAllToFS();
  }

  async _populateComponentsFilesToWrite() {
    const writeComponentsParams = this._getWriteComponentsParams();

    const componentWriterInstances = writeComponentsParams.map(writeParams => _componentWriter().default.getInstance(writeParams));
    this.fixDirsIfNested(componentWriterInstances); // add componentMap entries into .bitmap before starting the process because steps like writing package-json
    // rely on .bitmap to determine whether a dependency exists and what's its origin

    componentWriterInstances.forEach(componentWriter => {
      componentWriter.existingComponentMap = componentWriter.existingComponentMap || componentWriter.addComponentToBitMap(componentWriter.writeToPath);
    });

    if (this.resetConfig) {
      componentWriterInstances.forEach(componentWriter => {
        var _componentWriter$exis;

        (_componentWriter$exis = componentWriter.existingComponentMap) === null || _componentWriter$exis === void 0 ? true : delete _componentWriter$exis.config;
      });
    }

    this.writtenComponents = await (0, _pMapSeries().default)(componentWriterInstances, componentWriter => componentWriter.populateComponentsFilesToWrite(this.packageManager));
  }
  /**
   * e.g. [bar, bar/foo] => [bar_1, bar/foo]
   * otherwise, the bar/foo component will be saved inside "bar" component.
   * in case bar_1 is taken, increment to bar_2 until the name is available.
   */


  fixDirsIfNested(componentWriterInstances) {
    const allDirs = componentWriterInstances.map(c => c.writeToPath); // get all components that their root-dir is a parent of other components root-dir.

    const parentsOfOthersComps = componentWriterInstances.filter(({
      writeToPath
    }) => allDirs.find(d => d.startsWith(`${writeToPath}/`)));

    if (!parentsOfOthersComps.length) {
      return;
    }

    const parentsOfOthersCompsDirs = parentsOfOthersComps.map(c => c.writeToPath);

    const incrementPath = (p, number) => `${p}_${number}`;

    const existingRootDirs = Object.keys(this.bitMap.getAllTrackDirs());
    const allPaths = [...existingRootDirs, ...parentsOfOthersCompsDirs];

    const incrementRecursively = p => {
      let num = 1;
      let newPath = incrementPath(p, num);

      while (allPaths.includes(newPath)) {
        newPath = incrementPath(p, num += 1);
      }

      return newPath;
    }; // change the paths of all these parents root-dir to not collide with the children root-dir


    parentsOfOthersComps.forEach(componentWriter => {
      if (existingRootDirs.includes(componentWriter.writeToPath)) return; // component already exists.

      const newPath = incrementRecursively(componentWriter.writeToPath);
      componentWriter.writeToPath = newPath;
    });
  }

  _getWriteComponentsParams() {
    return this.componentsWithDependencies.map(componentWithDeps => this._getWriteParamsOfOneComponent(componentWithDeps));
  }

  _getWriteParamsOfOneComponent(componentWithDeps) {
    // for isolated components, the component files should be on the root. see #1758
    const componentRootDir = this.isolated ? '.' : this._getComponentRootDir(componentWithDeps.component.id);

    const getParams = () => {
      if (!this.consumer) {
        componentWithDeps.component.dists.writeDistsFiles = this.writeDists;
        return {
          origin: _constants().COMPONENT_ORIGINS.IMPORTED
        };
      } // AUTHORED and IMPORTED components can't be saved with multiple versions, so we can ignore the version to
      // find the component in bit.map


      const componentMap = this.bitMap.getComponentPreferNonNested(componentWithDeps.component.id);
      const origin = componentMap && componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED ? _constants().COMPONENT_ORIGINS.AUTHORED : _constants().COMPONENT_ORIGINS.IMPORTED; // $FlowFixMe consumer is set here

      this._throwErrorWhenDirectoryNotEmpty(this.consumer.toAbsolutePath(componentRootDir), componentMap); // don't write dists files for authored components as the author has its own mechanism to generate them
      // also, don't write dists file for imported component when a user used `--ignore-dist` flag


      componentWithDeps.component.dists.writeDistsFiles = this.writeDists && origin === _constants().COMPONENT_ORIGINS.IMPORTED;
      return {
        origin,
        existingComponentMap: componentMap,
        saveOnLane: this.saveOnLane
      };
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return _objectSpread(_objectSpread({}, this._getDefaultWriteParams()), {}, {
      component: componentWithDeps.component,
      writeToPath: componentRootDir,
      writeConfig: this.writeConfig,
      ignoreBitDependencies: typeof this.ignoreBitDependencies === 'boolean' ? this.ignoreBitDependencies : componentWithDeps.component.dependenciesSavedAsComponents
    }, getParams());
  }

  _getDefaultWriteParams() {
    return {
      writePackageJson: this.writePackageJson,
      applyPackageJsonTransformers: this.applyPackageJsonTransformers,
      consumer: this.consumer,
      bitMap: this.bitMap,
      isolated: this.isolated,
      excludeRegistryPrefix: this.excludeRegistryPrefix
    };
  }

  async _populateComponentsDependenciesToWrite() {
    const allDependenciesP = this.componentsWithDependencies.map(componentWithDeps => {
      const writeDependenciesP = componentWithDeps.allDependencies.map(dep => {
        const dependencyId = dep.id.toString();
        const depFromBitMap = this.bitMap.getComponentIfExist(dep.id);
        if (!dep.componentMap) dep.componentMap = depFromBitMap;

        if (!componentWithDeps.component.dependenciesSavedAsComponents && !depFromBitMap) {
          // when depFromBitMap is true, it means that this component was imported as a component already before
          // don't change it now from a component to a package. (a user can do it at any time by using export --eject).
          _logger().default.debugAndAddBreadCrumb('writeToComponentsDir', "ignore dependency {dependencyId}. It'll be installed later using npm-client", {
            dependencyId
          });

          return Promise.resolve(null);
        }

        if (depFromBitMap && depFromBitMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
          dep.writtenPath = '.';

          _logger().default.debugAndAddBreadCrumb('writeToComponentsDir', 'writeToComponentsDir, ignore authored dependency {dependencyId} as it already exists in bit map', {
            dependencyId
          });

          return Promise.resolve(dep);
        }

        if (this.dependenciesIdsCache[dependencyId]) {
          _logger().default.debugAndAddBreadCrumb('writeToComponentsDir', 'writeToComponentsDir, ignore dependency {dependencyId} as it already exists in cache', {
            dependencyId
          });

          dep.writtenPath = this.dependenciesIdsCache[dependencyId];
          return Promise.resolve(dep);
        }

        if (depFromBitMap && depFromBitMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED && (_fsExtra().default.existsSync(depFromBitMap.rootDir) || this.writtenComponents.find(c => c.writtenPath === depFromBitMap.rootDir))) {
          dep.writtenPath = depFromBitMap.rootDir;

          _logger().default.debugAndAddBreadCrumb('writeToComponentsDir', 'writeToComponentsDir, ignore non-authored dependency {dependencyId} as it already exists in bit map and file system', {
            dependencyId
          });

          return Promise.resolve(dep);
        }

        const depRootPath = this._getDependencyRootDir(dep.id);

        dep.writtenPath = depRootPath;
        this.dependenciesIdsCache[dependencyId] = depRootPath; // When a component is NESTED we do interested in the exact version, because multiple
        // components with the same scope and namespace can co-exist with different versions.

        const componentMap = this.bitMap.getComponentIfExist(dep.id); // @ts-ignore

        const componentWriter = _componentWriter().default.getInstance(_objectSpread(_objectSpread({}, this._getDefaultWriteParams()), {}, {
          writeConfig: false,
          component: dep,
          writeToPath: (0, _path2().pathNormalizeToLinux)(depRootPath),
          origin: _constants().COMPONENT_ORIGINS.NESTED,
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          existingComponentMap: componentMap
        }));

        return componentWriter.populateComponentsFilesToWrite();
      });
      return Promise.all(writeDependenciesP).then(deps => deps.filter(dep => dep));
    });
    const writtenDependenciesIncludesNull = await Promise.all(allDependenciesP);
    this.writtenDependencies = (0, _flatten2().default)(writtenDependenciesIncludesNull).filter(dep => dep);
  }

  _moveComponentsIfNeeded() {
    if (this.writeToPath && this.consumer) {
      this.componentsWithDependencies.forEach(componentWithDeps => {
        // @ts-ignore componentWithDeps.component.componentMap is set
        const componentMap = componentWithDeps.component.componentMap;

        if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && !componentMap.trackDir && !componentMap.rootDir) {
          throw new (_generalError().default)(`unable to use "--path" flag.
to move individual files, use bit move.
to move all component files to a different directory, run bit remove and then bit import --path`);
        }

        const relativeWrittenPath = componentMap.trackDir ? componentMap.trackDir : componentWithDeps.component.writtenPath; // @ts-ignore relativeWrittenPath is set at this point

        const absoluteWrittenPath = this.consumer.toAbsolutePath(relativeWrittenPath); // @ts-ignore this.writeToPath is set at this point

        const absoluteWriteToPath = path().resolve(this.writeToPath); // don't use consumer.toAbsolutePath, it might be an inner dir

        if (relativeWrittenPath && absoluteWrittenPath !== absoluteWriteToPath) {
          const component = componentWithDeps.component; // @ts-ignore consumer is set here

          (0, _moveComponents().moveExistingComponent)(this.consumer, component, absoluteWrittenPath, absoluteWriteToPath);
        }
      });
    }
  }

  async _installPackagesIfNeeded() {
    var _this$consumer3;

    if (!this.installNpmPackages) return;

    if ((_this$consumer3 = this.consumer) !== null && _this$consumer3 !== void 0 && _this$consumer3.isLegacy) {
      await (0, _installPackages().installNpmPackagesForComponents)({
        // $FlowFixMe consumer is set here
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        consumer: this.consumer,
        basePath: this.basePath,
        componentsWithDependencies: this.componentsWithDependencies,
        verbose: this.verbose,
        // $FlowFixMe
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        silentPackageManagerResult: this.silentPackageManagerResult,
        installPeerDependencies: this.installPeerDependencies,
        installProdPackagesOnly: this.installProdPackagesOnly
      });
    } else {
      var _ManyComponentsWriter2;

      try {
        var _ManyComponentsWriter;

        await ((_ManyComponentsWriter = ManyComponentsWriter.externalInstaller) === null || _ManyComponentsWriter === void 0 ? void 0 : _ManyComponentsWriter.install());
      } catch (err) {
        _logger().default.error('_installPackagesIfNeeded, external package-installer found an error', err);

        throw new (_bitError().BitError)(`failed installing the packages, consider running the command with "--skip-dependency-installation" flag.
error from the package-manager: ${err.message}.
please use the '--log=error' flag for the full error.`);
      } // this compiles all components on the workspace, not only the imported ones.
      // reason being is that the installed above deletes all dists dir of components that are somehow part of the
      // dependency graph. not only the imported components.


      await ((_ManyComponentsWriter2 = ManyComponentsWriter.externalCompiler) === null || _ManyComponentsWriter2 === void 0 ? void 0 : _ManyComponentsWriter2.call(ManyComponentsWriter));
    }
  }

  async _getAllLinks() {
    return (0, _links().getAllComponentsLinks)({
      componentsWithDependencies: this.componentsWithDependencies,
      writtenComponents: this.writtenComponents,
      writtenDependencies: this.writtenDependencies,
      consumer: this.consumer,
      bitMap: this.bitMap,
      createNpmLinkFiles: this.createNpmLinkFiles,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      writePackageJson: this.writePackageJson
    });
  }

  _getComponentRootDir(bitId) {
    if (this.consumer) {
      return this.writeToPath ? (0, _path2().pathNormalizeToLinux)(this.consumer.getPathRelativeToConsumer(path().resolve(this.writeToPath))) : this.consumer.composeRelativeComponentPath(bitId);
    }

    return (0, _composeComponentPath().composeComponentPath)(bitId);
  }

  _getDependencyRootDir(bitId) {
    if (this.isolated) {
      return (0, _composeComponentPath().composeDependencyPathForIsolated)(bitId, _constants().DEFAULT_DIR_DEPENDENCIES);
    } // @ts-ignore consumer is set here


    return this.consumer.composeRelativeDependencyPath(bitId);
  }

  _throwErrorWhenDirectoryNotEmpty(componentDir, componentMap) {
    // if not writeToPath specified, it goes to the default directory. When componentMap exists, the
    // component is not new, and it's ok to override the existing directory.
    if (!this.writeToPath && componentMap) return; // if writeToPath specified and that directory is already used for that component, it's ok to override

    if (this.writeToPath && componentMap && componentMap.rootDir && componentMap.rootDir === this.writeToPath) return;

    if (_fsExtra().default.pathExistsSync(componentDir)) {
      if (!(0, _utils().isDir)(componentDir)) {
        throw new (_generalError().default)(`unable to import to ${componentDir} because it's a file`);
      }

      if (!(0, _utils().isDirEmptySync)(componentDir) && !this.override) {
        throw new (_generalError().default)(`unable to import to ${componentDir}, the directory is not empty. use --override flag to delete the directory and then import`);
      }
    }
  }

}

exports.default = ManyComponentsWriter;
(0, _defineProperty2().default)(ManyComponentsWriter, "externalInstaller", void 0);
(0, _defineProperty2().default)(ManyComponentsWriter, "externalCompiler", void 0);