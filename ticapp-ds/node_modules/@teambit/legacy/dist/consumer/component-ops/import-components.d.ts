import { BitId, BitIds } from '../../bit-id';
import { Consumer } from '../../consumer';
import { RemoteLaneId } from '../../lane-id/lane-id';
import { ComponentWithDependencies, Scope } from '../../scope';
import DependencyGraph from '../../scope/graph/scope-graph';
import { Lane } from '../../scope/models';
import Component from '../component';
import { FilesStatus, MergeStrategy } from '../versions-ops/merge-version/merge-version';
import { MergeResultsThreeWay } from '../versions-ops/merge-version/three-way-merge';
export declare type ImportOptions = {
    ids: string[];
    verbose: boolean;
    merge?: boolean;
    mergeStrategy?: MergeStrategy;
    withEnvironments?: boolean;
    writeToPath?: string;
    writePackageJson?: boolean;
    writeConfig: boolean;
    writeDists?: boolean;
    override: boolean;
    installNpmPackages: boolean;
    objectsOnly: boolean;
    saveDependenciesAsComponents?: boolean;
    importDependenciesDirectly?: boolean;
    importDependents?: boolean;
    fromOriginalScope?: boolean;
    skipLane?: boolean;
    lanes?: {
        laneIds: RemoteLaneId[];
        lanes?: Lane[];
    };
    allHistory?: boolean;
};
declare type ComponentMergeStatus = {
    componentWithDependencies: ComponentWithDependencies;
    mergeResults: MergeResultsThreeWay | null | undefined;
};
declare type ImportedVersions = {
    [id: string]: string[];
};
export declare type ImportStatus = 'added' | 'updated' | 'up to date';
export declare type ImportDetails = {
    id: string;
    versions: string[];
    latestVersion: string | null;
    status: ImportStatus;
    filesStatus: FilesStatus | null | undefined;
    missingDeps: BitId[];
    deprecated: boolean;
};
export declare type ImportResult = {
    dependencies: ComponentWithDependencies[];
    envComponents?: Component[];
    importDetails: ImportDetails[];
};
export default class ImportComponents {
    consumer: Consumer;
    scope: Scope;
    options: ImportOptions;
    mergeStatus: {
        [id: string]: FilesStatus;
    };
    private laneObjects;
    private divergeData;
    constructor(consumer: Consumer, options: ImportOptions);
    importComponents(): Promise<ImportResult>;
    importSpecificComponents(): Promise<ImportResult>;
    _fetchDivergeData(componentsWithDependencies: ComponentWithDependencies[]): Promise<void>;
    _throwForDivergedHistory(): void;
    /**
     * it can happen for example when importing a component with `--dependent` flag and the component has
     * the same dependent with different versions. we only want the one with the higher version
     */
    _filterComponentsWithLowerVersions(componentsWithDependencies: ComponentWithDependencies[]): ComponentWithDependencies[];
    _getBitIds(): Promise<BitIds>;
    private populateBitIdsFromLanes;
    _getDependenciesFromGraph(bitIds: BitId[], graphs: DependencyGraph[]): BitId[];
    _getDependentsFromGraph(bitIds: BitId[], graphs: DependencyGraph[]): BitId[];
    _getComponentsGraphs(bitIds: BitId[]): Promise<DependencyGraph[]>;
    importAccordingToBitMap(): Promise<ImportResult>;
    /**
     * author might require bit-components that were installed via a package-manager. in that case,
     * the objects are not imported until bit build or bit tag was running. this makes sure to get
     * the objects on 'bit import', so then in the UI, they'll be shown nicely.
     */
    getIdsOfDepsInstalledAsPackages(): Promise<BitId[]>;
    _getCurrentVersions(ids: BitIds): Promise<ImportedVersions>;
    /**
     * get import details, includes the diff between the versions array before import and after import
     */
    _getImportDetails(currentVersions: ImportedVersions, components: ComponentWithDependencies[]): Promise<ImportDetails[]>;
    _throwForPotentialIssues(ids: BitIds): Promise<void>;
    _throwForModifiedOrNewComponents(ids: BitIds): Promise<void>;
    _throwForModifiedOrNewDependencies(componentsAndDependencies: ComponentWithDependencies[]): Promise<void>;
    /**
     * Model Component id() calculation uses id.toString() for the hash.
     * If an imported component has scopereadonly name equals to a local name, both will have the exact same
     * hash and they'll override each other.
     */
    _throwForDifferentComponentWithSameName(ids: BitIds): void;
    _getMergeStatus(componentWithDependencies: ComponentWithDependencies): Promise<ComponentMergeStatus>;
    /**
     * 1) when there are conflicts and the strategy is "ours", don't write the imported component to
     * the filesystem, only update bitmap.
     *
     * 2) when there are conflicts and the strategy is "theirs", override the local changes by the
     * imported component. (similar to --override)
     *
     * 3) when there is no conflict or there are conflicts and the strategy is manual, write the files
     * according to the merge result. (done by applyModifiedVersion())
     */
    _updateComponentFilesPerMergeStrategy(componentMergeStatus: ComponentMergeStatus): FilesStatus | null | undefined;
    /**
     * update the component files if they are modified and there is a merge strategy.
     * returns only the components that need to be written to the filesystem
     */
    updateAllComponentsAccordingToMergeStrategy(componentsWithDependencies: ComponentWithDependencies[]): Promise<ComponentWithDependencies[]>;
    _shouldSaveLaneData(): boolean;
    _saveLaneDataIfNeeded(componentsWithDependencies: ComponentWithDependencies[]): Promise<void>;
    _writeToFileSystem(componentsWithDependencies: ComponentWithDependencies[]): Promise<void>;
}
export {};
