"use strict";

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.install = install;
exports.installIds = installIds;

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../links");

  _links = function () {
    return data;
  };

  return data;
}

function _installPackages() {
  const data = require("../../npm-client/install-packages");

  _installPackages = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * does the following (the order is important):
 * 1) install npm packages of the consumer root.
 * 2) install npm packages of all imported and nested components
 * 3) link all components
 */
async function install(consumer, verbose) {
  const candidateComponents = consumer.bitMap.getAllComponents([_constants().COMPONENT_ORIGINS.IMPORTED, _constants().COMPONENT_ORIGINS.NESTED]);
  const dirs = candidateComponents.map(componentMap => componentMap.rootDir).filter(dir => dir);
  const consumerPath = consumer.getPath(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  const dirsAbsolute = dirs.map(dir => path().join(consumerPath, dir));
  await (0, _installPackages().installPackages)(consumer, dirsAbsolute, verbose, true);
  return (0, _links().linkAllToNodeModules)(consumer);
}
/**
 * does the following (the order is important):
 * 1) install npm packages of the provided ids.
 * 2) link the provided ids.
 */


async function installIds(consumer, ids, verbose) {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  const {
    components
  } = await consumer.loadComponents(ids);
  const dirs = components.map(component => {
    var _component$componentM;

    return (_component$componentM = component.componentMap) === null || _component$componentM === void 0 ? void 0 : _component$componentM.rootDir;
  }).filter(dir => dir);
  if (dirs.length) await (0, _installPackages().installPackages)(consumer, dirs, verbose);

  _analytics().Analytics.setExtraData('num_components', components.length);

  const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
  return nodeModuleLinker.link();
}