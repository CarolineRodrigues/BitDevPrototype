"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moveExistingComponent = moveExistingComponent;
exports.moveExistingComponentFilesToOneDir = moveExistingComponentFilesToOneDir;
exports.movePaths = movePaths;

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));

  _bitIds = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../links");

  _links = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _moveSync() {
  const data = _interopRequireDefault(require("../../utils/fs/move-sync"));

  _moveSync = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = require("../../utils/path");

  _path2 = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function movePaths(consumer, {
  from,
  to
}) {
  const fromExists = _fsExtra().default.existsSync(from);

  const toExists = _fsExtra().default.existsSync(to);

  if (fromExists && toExists) {
    throw new (_generalError().default)(`unable to move because both paths from (${from}) and to (${to}) already exist`);
  }

  if (!fromExists && !toExists) throw new (_generalError().default)(`both paths from (${from}) and to (${to}) do not exist`);
  const fromRelative = consumer.getPathRelativeToConsumer(from);
  const toRelative = consumer.getPathRelativeToConsumer(to);
  const fromAbsolute = consumer.toAbsolutePath(fromRelative);
  const toAbsolute = consumer.toAbsolutePath(toRelative);
  const existingPath = fromExists ? fromAbsolute : toAbsolute;
  const changes = consumer.bitMap.updatePathLocation(fromRelative, toRelative, existingPath);

  if (fromExists && !toExists) {
    // user would like to physically move the file. Otherwise (!fromExists and toExists), user would like to only update bit.map
    (0, _moveSync().default)(fromAbsolute, toAbsolute);
  }

  if (!(0, _isEmpty2().default)(changes)) {
    const componentsIds = changes.map(c => c.id);
    const {
      components
    } = await consumer.loadComponents(_bitIds().default.fromArray(componentsIds));
    await packageJsonUtils().addComponentsToRoot(consumer, components);
    const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
    await nodeModuleLinker.link();
    await (0, _links().reLinkDependents)(consumer, components);
  }

  return changes;
}

function moveExistingComponent(consumer, component, oldPath, newPath) {
  if (_fsExtra().default.existsSync(newPath)) {
    throw new (_generalError().default)(`could not move the component ${component.id.toString()} from ${oldPath} to ${newPath} as the destination path already exists`);
  }

  const componentMap = consumer.bitMap.getComponent(component.id);
  const oldPathRelative = consumer.getPathRelativeToConsumer(oldPath);
  const newPathRelative = consumer.getPathRelativeToConsumer(newPath);
  componentMap.updateDirLocation(oldPathRelative, newPathRelative);
  consumer.bitMap.markAsChanged();

  if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
    component.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newRelative = file.relative.replace(oldPathRelative, newPathRelative);
      file.updatePaths({
        newRelative
      });
    });
  } else {
    component.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newBase = file.base.replace(oldPathRelative, newPathRelative);
      file.updatePaths({
        newBase
      });
    });
  }

  component.dataToPersist.removePath(new (_removePath().default)(oldPathRelative));
  component.writtenPath = newPathRelative;
}
/**
 * since v14.8.0 Bit encourages users not to add individual files, only directories.
 * this function helps migrate a component that have files in different directories in the
 * workspace and moves them into one specified directory. this dir will be the rootDir.
 * since it only moves files, one prerequisite is to not have the same filename twice.
 */


async function moveExistingComponentFilesToOneDir(consumer, id, to) {
  const componentMap = consumer.bitMap.getComponent(id, {
    ignoreVersion: true
  });

  if (componentMap.origin !== _constants().COMPONENT_ORIGINS.AUTHORED) {
    throw new (_generalError().default)(`bit move --component is relevant for authored components only. ${id.toString()} is not an authored component`);
  }

  const existingRootDir = componentMap.hasRootDir() ? componentMap.rootDir : componentMap.trackDir;

  if (existingRootDir) {
    throw new (_generalError().default)(`${id.toString()} has already one directory (${existingRootDir}) for all its files.
to change that directory, use bit move without --component flag`);
  }

  const toRelative = consumer.getPathRelativeToConsumer(to);
  const toAbsolute = consumer.toAbsolutePath(toRelative);

  if (_fsExtra().default.existsSync(toAbsolute)) {
    const stats = _fsExtra().default.statSync(toAbsolute);

    if (stats.isFile()) throw new (_generalError().default)(`unable to move files into "${to}", as this path is a file`);
    const isEmpty = (0, _utils().isDirEmptySync)(toAbsolute);
    if (!isEmpty) throw new (_generalError().default)(`unable to move files into "${to}", the directory is not empty`);
  }

  const fileNames = componentMap.files.map(f => f.name);
  const sameName = fileNames.find(name => fileNames.filter(n => n === name).length > 1);

  if (sameName) {
    throw new (_generalError().default)(`unable to move the files because there are more than one file with the name ${sameName}`);
  }

  const changes = componentMap.files.map(file => {
    const fromAbsolute = consumer.toAbsolutePath(file.relativePath);
    (0, _moveSync().default)(fromAbsolute, _path().default.join(toAbsolute, file.name));
    return {
      from: file.relativePath,
      to: (0, _path2().pathJoinLinux)(toRelative, file.name)
    };
  });
  componentMap.addRootDirToDistributedFiles(toRelative);
  consumer.bitMap.markAsChanged();
  return [{
    id,
    changes
  }];
}