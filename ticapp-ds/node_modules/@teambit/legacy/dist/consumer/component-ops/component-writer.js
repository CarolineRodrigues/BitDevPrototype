"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _values2() {
  const data = _interopRequireDefault(require("ramda/src/values"));

  _values2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _envExtension() {
  const data = _interopRequireDefault(require("../../legacy-extensions/env-extension"));

  _envExtension = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = require("../../utils/path");

  _path2 = function () {
    return data;
  };

  return data;
}

function _packageJsonTransformer() {
  const data = require("../component/package-json-transformer");

  _packageJsonTransformer = function () {
    return data;
  };

  return data;
}

function _packageJsonUtils() {
  const data = require("../component/package-json-utils");

  _packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _componentConfig() {
  const data = _interopRequireDefault(require("../config/component-config"));

  _componentConfig = function () {
    return data;
  };

  return data;
}

function _artifactFiles() {
  const data = require("../component/sources/artifact-files");

  _artifactFiles = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

class ComponentWriter {
  // when using capsule, the consumer is not defined
  constructor({
    component,
    writeToPath,
    writeConfig = false,
    writePackageJson = true,
    override = true,
    isolated = false,
    origin,
    consumer,
    scope = consumer === null || consumer === void 0 ? void 0 : consumer.scope,
    bitMap,
    ignoreBitDependencies = true,
    deleteBitDirContent,
    existingComponentMap,
    excludeRegistryPrefix = false,
    saveOnLane = false,
    applyPackageJsonTransformers = true
  }) {
    (0, _defineProperty2().default)(this, "component", void 0);
    (0, _defineProperty2().default)(this, "writeToPath", void 0);
    (0, _defineProperty2().default)(this, "writeConfig", void 0);
    (0, _defineProperty2().default)(this, "writePackageJson", void 0);
    (0, _defineProperty2().default)(this, "override", void 0);
    (0, _defineProperty2().default)(this, "isolated", void 0);
    (0, _defineProperty2().default)(this, "origin", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "ignoreBitDependencies", void 0);
    (0, _defineProperty2().default)(this, "deleteBitDirContent", void 0);
    (0, _defineProperty2().default)(this, "existingComponentMap", void 0);
    (0, _defineProperty2().default)(this, "excludeRegistryPrefix", void 0);
    (0, _defineProperty2().default)(this, "saveOnLane", void 0);
    (0, _defineProperty2().default)(this, "applyPackageJsonTransformers", void 0);
    this.component = component;
    this.writeToPath = writeToPath;
    this.writeConfig = writeConfig;
    this.writePackageJson = writePackageJson;
    this.override = override;
    this.isolated = isolated;
    this.origin = origin;
    this.consumer = consumer;
    this.scope = scope;
    this.bitMap = bitMap;
    this.ignoreBitDependencies = ignoreBitDependencies;
    this.deleteBitDirContent = deleteBitDirContent;
    this.existingComponentMap = existingComponentMap;
    this.excludeRegistryPrefix = excludeRegistryPrefix;
    this.saveOnLane = saveOnLane;
    this.applyPackageJsonTransformers = applyPackageJsonTransformers;
  }

  static getInstance(componentWriterProps) {
    return new ComponentWriter(componentWriterProps);
  }
  /**
   * write the component to the filesystem and update .bitmap with the details.
   *
   * bitMap gets updated before writing the files to the filesystem, because as part of writing the
   * package-json file, the componentMap is needed to be stored with the updated version.
   *
   * when a component is not new, write the files according to the paths in .bitmap.
   */


  async write() {
    if (!this.consumer) throw new Error('ComponentWriter.write expect to have a consumer');
    await this.populateComponentsFilesToWrite();
    this.component.dataToPersist.addBasePath(this.consumer.getPath());
    await this.component.dataToPersist.persistAllToFS();
    return this.component;
  }

  async populateComponentsFilesToWrite(packageManager) {
    if (!this.component.files || !this.component.files.length) {
      throw new (_showDoctorError().default)(`Component ${this.component.id.toString()} is invalid as it has no files`);
    }

    this.throwForImportingLegacyIntoHarmony();
    this.component.dataToPersist = new (_dataToPersist().default)();

    this._updateFilesBasePaths();

    this.component.componentMap = this.existingComponentMap || this.addComponentToBitMap(this.writeToPath);

    this._copyFilesIntoDistsWhenDistsOutsideComponentDir();

    this._determineWhetherToDeleteComponentDirContent();

    await this._handlePreviouslyNestedCurrentlyImportedCase();

    this._determineWhetherToWriteConfig();

    this._updateComponentRootPathAccordingToBitMap();

    this._updateBitMapIfNeeded();

    await this._updateConsumerConfigIfNeeded();

    this._determineWhetherToWritePackageJson();

    await this.populateFilesToWriteToComponentDir(packageManager);
    if (this.isolated) await this.populateArtifacts();
    return this.component;
  }

  throwForImportingLegacyIntoHarmony() {
    if (this.component.isLegacy && this.consumer && !this.consumer.isLegacy) {
      throw new Error(`unable to write component "${this.component.id.toString()}", it is a legacy component and this workspace is Harmony`);
    }
  }

  async populateFilesToWriteToComponentDir(packageManager) {
    if (this.deleteBitDirContent) {
      this.component.dataToPersist.removePath(new (_removePath().default)(this.writeToPath));
    }

    this.component.files.forEach(file => file.override = this.override);
    this.component.files.map(file => this.component.dataToPersist.addFile(file));
    const dists = await this.component.dists.getDistsToWrite(this.component, this.bitMap, this.consumer, false);
    if (dists) this.component.dataToPersist.merge(dists); // TODO: change to new eject config
    // if (this.writeConfig && this.consumer) {
    //   const configToWrite = await this.component.getConfigToWrite(this.consumer, this.bitMap);
    //   this.component.dataToPersist.merge(configToWrite.dataToPersist);
    // }
    // make sure the project's package.json is not overridden by Bit
    // If a consumer is of isolated env it's ok to override the root package.json (used by the env installation
    // of compilers / testers / extensions)

    if (this.writePackageJson && (this.isolated || this.consumer && this.consumer.isolated || this.writeToPath !== '.')) {
      var _this$consumer, _this$scope;

      const artifactsDir = this.getArtifactsDir();
      const {
        packageJson,
        distPackageJson
      } = (0, _packageJsonUtils().preparePackageJsonToWrite)(this.bitMap, this.component, artifactsDir || this.writeToPath, this.override, this.ignoreBitDependencies, this.excludeRegistryPrefix, packageManager, Boolean(this.isolated));

      const componentConfig = _componentConfig().default.fromComponent(this.component); // @todo: temporarily this is running only when there is no version (or version is "latest")
      // so then package.json always has a valid version. we'll need to figure out when the version
      // needs to be incremented and when it should not.


      if ((!this.consumer || this.consumer.isolated) && !this.component.id.hasVersion()) {
        // this only needs to be done in an isolated
        // or consumerless (dependency in an isolated) environment
        packageJson.addOrUpdateProperty('version', this._getNextPatchVersion());
      }

      componentConfig.setCompiler(this.component.compiler ? this.component.compiler.toBitJsonObject() : {});
      componentConfig.setTester(this.component.tester ? this.component.tester.toBitJsonObject() : {});
      packageJson.addOrUpdateProperty('bit', componentConfig.toPlainObject());

      if ((!((_this$consumer = this.consumer) !== null && _this$consumer !== void 0 && _this$consumer.isLegacy) || !((_this$scope = this.scope) !== null && _this$scope !== void 0 && _this$scope.isLegacy)) && this.applyPackageJsonTransformers) {
        await this._applyTransformers(this.component, packageJson);
      }

      this._mergeChangedPackageJsonProps(packageJson);

      this._mergePackageJsonPropsFromOverrides(packageJson);

      this.component.dataToPersist.addFile(packageJson.toVinylFile());
      if (distPackageJson) this.component.dataToPersist.addFile(distPackageJson.toVinylFile());
      this.component.packageJsonFile = packageJson;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (this.component.license && this.component.license.contents) {
      this.component.license.updatePaths({
        newBase: this.writeToPath
      }); // $FlowFixMe this.component.license is set

      this.component.license.override = this.override; // $FlowFixMe this.component.license is set
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      this.component.dataToPersist.addFile(this.component.license);
    }
  }
  /**
   * currently, it writes all artifacts.
   * later, this responsibility might move to pkg extension, which could write only artifacts
   * that are set in package.json.files[], to have a similar structure of a package.
   */


  async populateArtifacts() {
    if (!this.scope) {
      // when capsules are written via the workspace, do not write artifacts, they get created by
      // build-pipeline. when capsules are written via the scope, we do need the dists.
      return;
    }

    const extensionsNamesForArtifacts = ['teambit.compilation/compiler'];
    const artifactsFiles = (0, _lodash().flatten)(extensionsNamesForArtifacts.map(extName => (0, _artifactFiles().getArtifactFilesByExtension)(this.component.extensions, extName)));
    const scope = this.scope;
    const artifactsVinylFlattened = [];
    await Promise.all(artifactsFiles.map(async artifactFiles => {
      if (!artifactFiles) return;

      if (!(artifactFiles instanceof _artifactFiles().ArtifactFiles)) {
        artifactFiles = (0, _artifactFiles().deserializeArtifactFiles)(artifactFiles);
      } // fyi, if this is coming from the isolator aspect, it is optimized to import all at once.
      // see artifact-files.importMultipleDistsArtifacts().


      const vinylFiles = await artifactFiles.getVinylsAndImportIfMissing(this.component.scope, scope);
      artifactsVinylFlattened.push(...vinylFiles);
    }));
    const artifactsDir = this.getArtifactsDir();

    if (artifactsDir) {
      artifactsVinylFlattened.forEach(a => a.updatePaths({
        newBase: artifactsDir
      }));
    }

    this.component.dataToPersist.addManyFiles(artifactsVinylFlattened);
  }

  getArtifactsDir() {
    // @todo: decide whether new components are allowed to be imported to a legacy workspace
    // if not, remove the "this.consumer.isLegacy" part in the condition below
    if (!this.consumer || this.consumer.isLegacy || this.component.isLegacy) return this.component.writtenPath;
    if (this.origin === _constants().COMPONENT_ORIGINS.NESTED) return this.component.writtenPath;
    return (0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, this.component), {}, {
      id: this.component.id,
      allowNonScope: true
    }));
  }

  addComponentToBitMap(rootDir) {
    const filesForBitMap = this.component.files.map(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return {
        name: file.basename,
        relativePath: (0, _path2().pathNormalizeToLinux)(file.relative),
        test: file.test
      };
    });
    return this.bitMap.addComponent({
      componentId: this.component.id,
      files: filesForBitMap,
      mainFile: (0, _path2().pathNormalizeToLinux)(this.component.mainFile),
      rootDir,
      origin: this.origin,
      trackDir: this.existingComponentMap && this.existingComponentMap.trackDir,
      originallySharedDir: this.component.originallySharedDir,
      wrapDir: this.component.wrapDir,
      onLanesOnly: this.saveOnLane
    });
  }
  /**
   * these changes were entered manually by a user via `overrides` key
   */


  _mergePackageJsonPropsFromOverrides(packageJson) {
    const valuesToMerge = this.component.overrides.componentOverridesPackageJsonData;
    packageJson.mergePackageJsonObject(valuesToMerge);
  }
  /**
   * these are changes made by aspects
   */


  async _applyTransformers(component, packageJson) {
    return _packageJsonTransformer().PackageJsonTransformer.applyTransformers(component, packageJson);
  }
  /**
   * these are changes done by a compiler
   */


  _mergeChangedPackageJsonProps(packageJson) {
    if (!this.component.packageJsonChangedProps) return;

    const valuesToMerge = this._replaceDistPathTemplateWithCalculatedDistPath(packageJson);

    packageJson.mergePackageJsonObject(valuesToMerge);
  }
  /**
   * see https://github.com/teambit/bit/issues/1808 for more info why it's needed
   */


  _replaceDistPathTemplateWithCalculatedDistPath(packageJson) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const packageJsonChangedProps = this.component.packageJsonChangedProps;
    const isReplaceNeeded = (0, _values2().default)(packageJsonChangedProps).some(val => val.includes(_constants().COMPONENT_DIST_PATH_TEMPLATE));

    if (!isReplaceNeeded) {
      return packageJsonChangedProps;
    }

    const distRootDir = this.component.dists.getDistDir(this.consumer, this.writeToPath || '.');
    const distRelativeToPackageJson = (0, _path2().getPathRelativeRegardlessCWD)(path().dirname(packageJson.filePath), // $FlowFixMe
    distRootDir);
    return Object.keys(packageJsonChangedProps).reduce((acc, key) => {
      const val = packageJsonChangedProps[key].replace(_constants().COMPONENT_DIST_PATH_TEMPLATE, distRelativeToPackageJson);
      acc[key] = val;
      return acc;
    }, {});
  }

  _copyFilesIntoDistsWhenDistsOutsideComponentDir() {
    if (!this.consumer) return; // not relevant when consumer is not available

    if (!this.consumer.shouldDistsBeInsideTheComponent() && this.component.dists.isEmpty()) {
      // since the dists are set to be outside the components dir, the source files must be saved there
      // otherwise, other components in dists won't be able to link to this component
      this.component.copyFilesIntoDists();
    }
  }

  _updateComponentRootPathAccordingToBitMap() {
    // $FlowFixMe this.component.componentMap is set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.writeToPath = this.component.componentMap.getRootDir();
    this.component.writtenPath = this.writeToPath;

    this._updateFilesBasePaths();
  }
  /**
   * when there is componentMap, this component (with this version or other version) is already part of the project.
   * There are several options as to what was the origin before and what is the origin now and according to this,
   * we update/remove/don't-touch the record in bit.map.
   * 1) current origin is AUTHORED - If the version is the same as before, don't update bit.map. Otherwise, update.
   * 2) current origin is IMPORTED - If the version is the same as before, don't update bit.map. Otherwise, update.
   * 3) current origin is NESTED - If it was not NESTED before, don't update.
   */


  _updateBitMapIfNeeded() {
    var _this$consumer2;

    if (this.isolated) return;

    if ((_this$consumer2 = this.consumer) !== null && _this$consumer2 !== void 0 && _this$consumer2.isLegacy) {
      // this logic is not needed in Harmony, and we can't just remove the component as it may have
      // lanes data
      const componentMapExistWithSameVersion = this.bitMap.isExistWithSameVersion(this.component.id);

      if (componentMapExistWithSameVersion) {
        if (this.existingComponentMap && // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        this.existingComponentMap !== _constants().COMPONENT_ORIGINS.NESTED && this.origin === _constants().COMPONENT_ORIGINS.NESTED) {
          return;
        }

        this.bitMap.removeComponent(this.component.id);
      }
    } // @ts-ignore this.component.componentMap is set


    this.component.componentMap = this.addComponentToBitMap(this.component.componentMap.rootDir);
  }

  async _updateConsumerConfigIfNeeded() {
    var _this$component$compo2;

    // for authored components there is no bit.json/package.json component specific
    // so if the overrides or envs were changed, it should be written to the consumer-config
    const areEnvsChanged = async () => {
      var _this$component, _this$component$compo;

      // $FlowFixMe this.component.componentMap is set
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const context = {
        componentDir: (_this$component = this.component) === null || _this$component === void 0 ? void 0 : (_this$component$compo = _this$component.componentMap) === null || _this$component$compo === void 0 ? void 0 : _this$component$compo.getComponentDir()
      };
      const compilerFromConsumer = this.consumer ? await this.consumer.getEnv(_constants().COMPILER_ENV_TYPE, context) : undefined;
      const testerFromConsumer = this.consumer ? await this.consumer.getEnv(_constants().TESTER_ENV_TYPE, context) : undefined;
      const compilerFromComponent = this.component.compiler ? this.component.compiler.toModelObject() : undefined;
      const testerFromComponent = this.component.tester ? this.component.tester.toModelObject() : undefined;
      return _envExtension().default.areEnvsDifferent(compilerFromConsumer ? compilerFromConsumer.toModelObject() : undefined, compilerFromComponent) || _envExtension().default.areEnvsDifferent(testerFromConsumer ? testerFromConsumer.toModelObject() : undefined, testerFromComponent);
    };

    if (((_this$component$compo2 = this.component.componentMap) === null || _this$component$compo2 === void 0 ? void 0 : _this$component$compo2.origin) === _constants().COMPONENT_ORIGINS.AUTHORED && this.consumer) {
      var _this$consumer3, _this$consumer3$confi;

      const envsChanged = await areEnvsChanged();
      const componentsConfig = (_this$consumer3 = this.consumer) === null || _this$consumer3 === void 0 ? void 0 : (_this$consumer3$confi = _this$consumer3.config) === null || _this$consumer3$confi === void 0 ? void 0 : _this$consumer3$confi.componentsConfig;
      componentsConfig === null || componentsConfig === void 0 ? void 0 : componentsConfig.updateOverridesIfChanged(this.component, envsChanged);
    }
  }

  _determineWhetherToWriteConfig() {
    // $FlowFixMe this.component.componentMap is set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.component.componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
      this.writeConfig = false;
    }
  }
  /**
   * don't write the package.json for an authored component, because its dependencies are managed
   * by the root package.json
   */


  _determineWhetherToWritePackageJson() {
    this.writePackageJson = this.writePackageJson && this.origin !== _constants().COMPONENT_ORIGINS.AUTHORED;
  }
  /**
   * when a user imports a component that was a dependency before, write the component directly
   * into the components directory for an easy access/change. Then, remove the current record from
   * bit.map and add an updated one.
   */


  async _handlePreviouslyNestedCurrentlyImportedCase() {
    if (!this.consumer) return; // $FlowFixMe this.component.componentMap is set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (this.origin === _constants().COMPONENT_ORIGINS.IMPORTED && this.component.componentMap.origin === _constants().COMPONENT_ORIGINS.NESTED) {
      await this._cleanOldNestedComponent();
      this.component.componentMap = this.addComponentToBitMap(this.writeToPath);
    }
  }
  /**
   * For IMPORTED component we have to delete the content of the directory before importing.
   * Otherwise, when the author adds new files outside of the previous originallySharedDir and this user imports them
   * the environment will contain both copies, the old one with the old originallySharedDir and the new one.
   * If a user made changes to the imported component, it will show a warning and stop the process.
   */


  _determineWhetherToDeleteComponentDirContent() {
    if (typeof this.deleteBitDirContent === 'undefined') {
      this.deleteBitDirContent = this.origin === _constants().COMPONENT_ORIGINS.IMPORTED;
    }
  }

  _updateFilesBasePaths() {
    const newBase = this.writeToPath || '.';
    this.component.files.forEach(file => file.updatePaths({
      newBase
    }));

    if (!this.component.dists.isEmpty()) {
      this.component.dists.get().forEach(dist => dist.updatePaths({
        newBase
      }));
    }
  }

  async _cleanOldNestedComponent() {
    if (!this.consumer) throw new Error('ComponentWriter._cleanOldNestedComponent expect to have a consumer'); // $FlowFixMe this function gets called when it was previously NESTED, so the rootDir is set
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const oldLocation = path().join(this.consumer.getPath(), this.component.componentMap.rootDir);

    _logger().default.debugAndAddBreadCrumb('component-writer._cleanOldNestedComponent', 'deleting the old directory of a component at {oldLocation}', {
      oldLocation
    });

    await _fsExtra().default.remove(oldLocation);
    await this._removeNodeModulesLinksFromDependents();
    this.bitMap.removeComponent(this.component.id);
  }

  async _removeNodeModulesLinksFromDependents() {
    if (!this.consumer) {
      throw new Error('ComponentWriter._removeNodeModulesLinksFromDependents expect to have a consumer');
    }

    const directDependentIds = await this.consumer.getAuthoredAndImportedDependentsIdsOf([this.component]);
    await Promise.all(directDependentIds.map(dependentId => {
      const dependentComponentMap = this.consumer ? this.consumer.bitMap.getComponent(dependentId) : null;
      const relativeLinkPath = this.consumer ? (0, _componentNodeModulesPath().default)(this.component) : null;
      const nodeModulesLinkAbs = this.consumer && dependentComponentMap && relativeLinkPath ? this.consumer.toAbsolutePath(path().join(dependentComponentMap.getRootDir(), relativeLinkPath)) : null;

      if (nodeModulesLinkAbs) {
        _logger().default.debug(`deleting an obsolete link to node_modules at ${nodeModulesLinkAbs}`);
      }

      return nodeModulesLinkAbs ? _fsExtra().default.remove(nodeModulesLinkAbs) : Promise.resolve();
    }));
  }

  _getNextPatchVersion() {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return _semver().default.inc(this.component.version, 'prerelease') || '0.0.1-0';
  }

}

exports.default = ComponentWriter;