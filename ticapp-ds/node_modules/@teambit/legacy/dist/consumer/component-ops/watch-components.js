"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.WATCHER_COMPLETED_MSG = exports.STARTED_WATCHING_MSG = void 0;

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _chokidar() {
  const data = _interopRequireDefault(require("chokidar"));

  _chokidar = function () {
    return data;
  };

  return data;
}

function _() {
  const data = require("..");

  _ = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

/* eslint no-console: 0 */
// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
const STARTED_WATCHING_MSG = 'started watching for component changes to rebuild';
exports.STARTED_WATCHING_MSG = STARTED_WATCHING_MSG;
const WATCHER_COMPLETED_MSG = 'watching for changes';
exports.WATCHER_COMPLETED_MSG = WATCHER_COMPLETED_MSG;

class WatchComponents {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // dir => component-id
  constructor(verbose) {
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "verbose", void 0);
    (0, _defineProperty2().default)(this, "trackDirs", {});
    this.verbose = verbose;
  }

  async watchAll() {
    // TODO: run build in the beginning of process (it's work like this in other envs)
    this.consumer = await (0, _().loadConsumer)();

    const watcher = this._getWatcher();

    console.log(_chalk().default.yellow(`bit binary version: ${_constants().BIT_VERSION}`));
    console.log(_chalk().default.yellow(`node version: ${process.version}`));
    const log = console.log.bind(console);
    return new Promise((resolve, reject) => {
      // prefix your command with "BIT_LOG=*" to see all watch events
      if (process.env.BIT_LOG) {
        watcher.on('all', (event, path) => {
          log(event, path);
        });
      }

      watcher.on('ready', () => {
        log(_chalk().default.yellow(STARTED_WATCHING_MSG));
      });
      watcher.on('change', p => {
        log(`file ${p} has been changed`);

        this._handleChange(p).catch(err => reject(err));
      });
      watcher.on('add', p => {
        log(`file ${p} has been added`);

        this._handleChange(p, true).catch(err => reject(err));
      });
      watcher.on('unlink', p => {
        log(`file ${p} has been removed`);

        this._handleChange(p).catch(err => reject(err));
      });
      watcher.on('error', err => {
        log(`Watcher error ${err}`);
        reject(err);
      });
    });
  }

  async _handleChange(filePath, isNew = false) {
    const componentId = await this._getBitIdByPathAndReloadConsumer(filePath, isNew);

    if (componentId) {
      const idStr = componentId.toString();
      console.log(`running build for ${_chalk().default.bold(idStr)}`); // TODO: Make sure the log for build is printed to console

      const buildResults = await (0, _consumer().build)(idStr, false, this.verbose);

      if (buildResults) {
        console.log(`\t${_chalk().default.cyan(buildResults.join('\n\t'))}`);
      } else {
        console.log(`${idStr} doesn't have a compiler, nothing to build`);
      }
    } else {
      console.log(`file ${filePath} is not part of any component, ignoring it`);
    }

    _loader().default.stop();

    console.log(_chalk().default.yellow(WATCHER_COMPLETED_MSG));
  }

  async _getBitIdByPathAndReloadConsumer(filePath, isNew) {
    const relativeFile = (0, _utils().pathNormalizeToLinux)(this.consumer.getPathRelativeToConsumer(filePath));
    let componentId = this.consumer.bitMap.getComponentIdByPath(relativeFile);

    if (!isNew && !componentId) {
      return null;
    }

    this.consumer = await (0, _().loadConsumer)(undefined, true);

    if (!componentId) {
      componentId = this.consumer.bitMap.getComponentIdByPath(relativeFile);
    }

    if (isNew && !componentId) {
      const trackDir = Object.keys(this.trackDirs).find(dir => relativeFile.startsWith(dir));

      if (trackDir) {
        const id = this.trackDirs[trackDir];
        const bitId = this.consumer.getParsedId(id); // loading the component causes the bitMap to be updated with the new path

        await this.consumer.loadComponent(bitId);
        componentId = this.consumer.bitMap.getComponentIdByPath(relativeFile);
      }
    }

    return componentId;
  }

  _getWatcher() {
    const pathsToWatch = this._getPathsToWatch();

    return _chokidar().default.watch(pathsToWatch, {
      ignoreInitial: true,
      // Using the function way since the regular way not working as expected
      // It might be solved when upgrading to chokidar > 3.0.0
      // See:
      // https://github.com/paulmillr/chokidar/issues/773
      // https://github.com/paulmillr/chokidar/issues/492
      // https://github.com/paulmillr/chokidar/issues/724
      ignored: path => {
        // Ignore package.json temporarily since it cerates endless loop since it's re-written after each build
        if (path.includes('dist') || path.includes('node_modules') || path.includes('package.json')) {
          return true;
        }

        return false;
      },
      persistent: true,
      useFsEvents: false
    });
  }

  _getPathsToWatch() {
    const componentsFromBitMap = this.consumer.bitMap.getAllComponents();
    const paths = componentsFromBitMap.map(componentMap => {
      const componentId = componentMap.id.toString();
      const trackDir = componentMap.getTrackDir();

      if (trackDir) {
        this.trackDirs[trackDir] = componentId;
      }

      const relativePaths = trackDir ? [trackDir] : componentMap.getFilesRelativeToConsumer();
      const absPaths = relativePaths.map(relativePath => this.consumer.toAbsolutePath(relativePath));

      if (this.verbose) {
        console.log(`watching ${_chalk().default.bold(componentId)}\n${absPaths.join('\n')}`);
      }

      return absPaths;
    });
    return (0, _flatten2().default)(paths);
  }

}

exports.default = WatchComponents;