"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deleteComponentsFiles;

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _dists() {
  const data = _interopRequireDefault(require("../component/sources/dists"));

  _dists = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

async function deleteComponentsFiles(consumer, bitIds, deleteFilesForAuthor) {
  _logger().default.debug(`deleteComponentsFiles, ids: ${bitIds.toString()}`);

  const filesToDelete = consumer.isLegacy ? getFilesToDeleteLegacy() : getFilesToDeleteHarmony();
  filesToDelete.addBasePath(consumer.getPath());
  return filesToDelete.persistAllToFS();

  function getFilesToDeleteLegacy() {
    const dataToPersist = new (_dataToPersist().default)();
    bitIds.forEach(id => {
      const ignoreVersion = id.isLocal() || !id.hasVersion();
      const componentMap = consumer.bitMap.getComponentIfExist(id, {
        ignoreVersion
      });

      if (!componentMap) {
        _logger().default.warn(`deleteComponentsFiles was unable to delete ${id.toString()} because the id is missing from bitmap`);

        return null;
      }

      if (componentMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED || componentMap.origin === _constants().COMPONENT_ORIGINS.NESTED) {
        // $FlowFixMe rootDir is set for non authored
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const rootDir = componentMap.rootDir;
        dataToPersist.removePath(new (_removePath().default)(rootDir, true));

        if (!consumer.shouldDistsBeInsideTheComponent()) {
          const distDir = _dists().default.getDistDirWhenDistIsOutsideCompDir(consumer.config, rootDir);

          dataToPersist.removePath(new (_removePath().default)(distDir, true));
        }
      } else if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && deleteFilesForAuthor) {
        const filesToRemove = componentMap.getAllFilesPaths().map(f => new (_removePath().default)(f));
        dataToPersist.removeManyPaths(filesToRemove);
      }

      return null;
    });
    return dataToPersist;
  }

  function getFilesToDeleteHarmony() {
    const dataToPersist = new (_dataToPersist().default)();
    bitIds.forEach(id => {
      if (!deleteFilesForAuthor) return;
      const ignoreVersion = id.isLocal() || !id.hasVersion();
      const componentMap = consumer.bitMap.getComponentIfExist(id, {
        ignoreVersion
      });

      if (!componentMap) {
        _logger().default.warn(`deleteComponentsFiles was unable to delete ${id.toString()} because the id is missing from bitmap`);

        return;
      }

      const rootDir = componentMap.rootDir;
      if (!rootDir) throw new Error(`rootDir is missing from ${id.toString()}`);
      dataToPersist.removePath(new (_removePath().default)(rootDir, true));
    });
    return dataToPersist;
  }
}