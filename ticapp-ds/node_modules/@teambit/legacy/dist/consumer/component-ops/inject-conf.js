"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _equals2() {
  const data = _interopRequireDefault(require("ramda/src/equals"));

  _equals2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _removeEmptyDir() {
  const data = _interopRequireDefault(require("../../utils/fs/remove-empty-dir"));

  _removeEmptyDir = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = _interopRequireDefault(require("../config"));

  _config = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * the opposite of 'eject-conf'.
 * delete configuration files on the fs.
 */
var injectConf = async function injectConf(component, consumerPath, force = false) {
  const componentMap = component.componentMap;

  if (!componentMap) {
    throw new (_showDoctorError().default)('could not find component in the .bitmap file');
  }

  const componentDir = componentMap.getComponentDir();

  if (!componentDir) {
    throw new (_generalError().default)('unable to inject-conf for a component without root directory');
  }

  if (!force && areEnvsModified(component, component.componentFromModel)) {
    throw new (_generalError().default)('unable to inject-conf, some or all configuration files are modified. please use "--force" flag to force removing the configuration files');
  } // Delete bit.json


  const bitJsonDirFullPath = path().normalize(path().join(consumerPath, componentDir));
  await _config().default.removeIfExist(bitJsonDirFullPath);
  await (0, _removeEmptyDir().default)(bitJsonDirFullPath);
  return {
    id: component.id.toStringWithoutVersion()
  };
};
/**
 * returns whether the envs configuration files were modified on the filesystem
 */


exports.default = injectConf;

function areEnvsModified(componentFromFs, componentFromModel) {
  if (!componentFromModel) return false;
  const envTypes = [_constants().COMPILER_ENV_TYPE, _constants().TESTER_ENV_TYPE];
  return envTypes.some(envType => {
    const fsHashes = // $FlowFixMe
    componentFromFs[envType] && componentFromFs[envType].files ? componentFromFs[envType].files.map(file => file.toSourceAsLinuxEOL().hash()).sort() : [];
    const modelHashes = // $FlowFixMe
    componentFromModel[envType] && componentFromModel[envType].files ? componentFromModel[envType].files.map(file => file.file.hash()).sort() : [];
    return !(0, _equals2().default)(fsHashes, modelHashes);
  });
}