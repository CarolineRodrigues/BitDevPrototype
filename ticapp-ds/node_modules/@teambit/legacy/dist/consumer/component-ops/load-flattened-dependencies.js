"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FlattenedDependencyLoader = void 0;

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));

  _uniq2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));

  _bitIds = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _componentDependencies() {
  const data = _interopRequireDefault(require("../../scope/component-dependencies"));

  _componentDependencies = function () {
    return data;
  };

  return data;
}

class FlattenedDependencyLoader {
  constructor(consumer, ignoreIds = new (_bitIds().default)(), loadComponentsFunc) {
    this.consumer = consumer;
    this.ignoreIds = ignoreIds;
    this.loadComponentsFunc = loadComponentsFunc;
    (0, _defineProperty2().default)(this, "cache", {});
  }

  async load(component) {
    const dependencies = await this.loadManyDependencies(component.dependencies.getAllIds().difference(this.ignoreIds));
    const devDependencies = await this.loadManyDependencies(component.devDependencies.getAllIds().difference(this.ignoreIds));
    const extensionDependencies = await this.loadManyDependencies(component.extensions.extensionsBitIds.difference(this.ignoreIds));

    const filterIgnoreIds = comps => {
      if (!this.ignoreIds.length) {
        // workaround for old @teambit/cli. for some reason, comps sometimes have null/undefined
        // and as a result, even comps.filter(x => x) causes of errors later on.
        return comps;
      }

      return comps.filter(dep => !this.ignoreIds.has(dep.id));
    };

    const filteredDeps = filterIgnoreIds(dependencies);
    const filteredDevDeps = filterIgnoreIds(devDependencies);
    const filteredExtDeps = filterIgnoreIds(extensionDependencies);
    await this.loadFlattenedRecursively(filteredDeps);
    await this.loadFlattenedRecursively(filteredDevDeps);
    await this.loadFlattenedRecursively(filteredExtDeps);
    return new (_componentDependencies().default)({
      component,
      dependencies: filteredDeps,
      devDependencies: filteredDevDeps,
      extensionDependencies: filteredExtDeps
    });
  }

  async loadManyDependencies(dependenciesIds) {
    return (0, _pMapSeries().default)(dependenciesIds, dep => this.loadDependency(dep));
  }

  async loadDependency(dependencyId) {
    if (!this.cache[dependencyId.toString()]) {
      const componentMap = this.consumer.bitMap.getComponentIfExist(dependencyId);

      const couldBeModified = componentMap && componentMap.origin !== _constants().COMPONENT_ORIGINS.NESTED;

      if (couldBeModified) {
        if (this.loadComponentsFunc) {
          const dependency = await this.loadComponentsFunc([dependencyId]);
          if (!dependency.length || !dependency[0]) throw new Error(`unable to load ${dependencyId.toString()} using custom load function`);
          this.cache[dependencyId.toString()] = dependency[0];
        } else {
          this.cache[dependencyId.toString()] = await this.consumer.loadComponentForCapsule(dependencyId);
        }

        return this.cache[dependencyId.toString()];
      } // for capsule, a dependency might have been installed as a package in the workspace, and as
      // such doesn't have a componentMap, which result in not stripping the sharedDir.
      // using the loadComponentWithDependenciesFromModel, all dependencies are loaded and their
      // shared dir is stripped. (see e2e-test of 'isolating with capsule' in dependencies-as-packages.e2e file)


      const componentWithDependenciesFromModel = await this.consumer.loadComponentWithDependenciesFromModel(dependencyId, false);
      this.cache[dependencyId.toString()] = componentWithDependenciesFromModel.component.clone();
    }

    return this.cache[dependencyId.toString()];
  }

  async loadFlattenedRecursively(deps, visited = []) {
    if ((0, _isEmpty2().default)(deps)) return [];
    const notVisitedDeps = deps.filter(dep => !visited.includes(dep.id.toString()));
    const flattenedFromModel = await this.loadFlattenedFromModel(notVisitedDeps);
    deps.push(...flattenedFromModel);
    const flattenedFromFs = await this.loadFlattenedFromFs(notVisitedDeps);
    const newVisitedIds = deps.map(dep => dep.id.toString());
    deps.push(...flattenedFromFs);

    if (flattenedFromFs.length) {
      const newVisited = (0, _uniq2().default)(visited.concat(newVisitedIds));
      await this.loadFlattenedRecursively(deps, newVisited);
      return deps;
    }

    return deps;
  }

  async loadFlattenedFromModel(deps) {
    const dependenciesFromModel = deps.filter(d => !d.loadedFromFileSystem);
    const flattenedIdsFromModel = dependenciesFromModel.map(d => d.getAllFlattenedDependencies());
    const flattenedFromModel = await this.loadManyDependencies((0, _flatten2().default)(flattenedIdsFromModel));
    return flattenedFromModel;
  } // @todo: in case of out-of-sync, when a component has versions in the objects but the .bitmap
  // has the component without any version, this function result in "Maximum call stack size
  // exceeded" error.


  async loadFlattenedFromFs(components) {
    const currentIds = _bitIds().default.fromArray(components.map(c => c.id));

    const ids = (0, _flatten2().default)(components.filter(c => c.loadedFromFileSystem).map(c => c.getAllDependenciesIds()));

    const idsUniq = _bitIds().default.uniqFromArray(ids);

    const newIds = idsUniq.filter(id => !currentIds.has(id));
    if ((0, _isEmpty2().default)(newIds)) return [];
    const deps = await this.loadManyDependencies(newIds);
    if ((0, _isEmpty2().default)(deps)) return [];
    return deps;
  }

}

exports.FlattenedDependencyLoader = FlattenedDependencyLoader;