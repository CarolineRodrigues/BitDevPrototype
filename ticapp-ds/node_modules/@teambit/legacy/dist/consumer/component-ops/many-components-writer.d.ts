import { BitId } from '../../bit-id';
import { ComponentWithDependencies } from '../../scope';
import { PathLinuxRelative, PathOsBasedAbsolute, PathOsBasedRelative } from '../../utils/path';
import BitMap from '../bit-map';
import ComponentMap from '../bit-map/component-map';
import Component from '../component/consumer-component';
import DataToPersist from '../component/sources/data-to-persist';
import Consumer from '../consumer';
import { ComponentWriterProps } from './component-writer';
interface ExternalPackageInstaller {
    install: () => Promise<any>;
}
export interface ManyComponentsWriterParams {
    packageManager?: string;
    consumer?: Consumer;
    silentPackageManagerResult?: boolean;
    componentsWithDependencies: ComponentWithDependencies[];
    writeToPath?: string;
    override?: boolean;
    isolated?: boolean;
    writePackageJson?: boolean;
    saveDependenciesAsComponents?: boolean;
    writeConfig?: boolean;
    ignoreBitDependencies?: boolean;
    createNpmLinkFiles?: boolean;
    writeDists?: boolean;
    installNpmPackages?: boolean;
    installPeerDependencies?: boolean;
    addToRootPackageJson?: boolean;
    verbose?: boolean;
    installProdPackagesOnly?: boolean;
    excludeRegistryPrefix?: boolean;
    saveOnLane?: boolean;
    isLegacy?: boolean;
    applyPackageJsonTransformers?: boolean;
    resetConfig?: boolean;
}
/**
 * write the components into '/components' dir (or according to the bit.map) and its dependencies in the
 * '/components/.dependencies' dir. Both directories are configurable in bit.json
 * For example: global/a has a dependency my-scope/global/b@1. The directories will be:
 * project/root/components/global/a/impl.js
 * project/root/components/.dependencies/global/b/my-scope/1/impl.js
 *
 * In case there are some same dependencies shared between the components, it makes sure to
 * write them only once.
 */
export default class ManyComponentsWriter {
    consumer?: Consumer;
    silentPackageManagerResult?: boolean;
    componentsWithDependencies: ComponentWithDependencies[];
    writeToPath?: string;
    override: boolean;
    writePackageJson: boolean;
    writeConfig: boolean;
    ignoreBitDependencies: boolean | undefined;
    createNpmLinkFiles: boolean;
    writeDists: boolean;
    installNpmPackages: boolean;
    installPeerDependencies: boolean;
    addToRootPackageJson: boolean;
    verbose: boolean;
    excludeRegistryPrefix: boolean;
    installProdPackagesOnly?: boolean;
    dependenciesIdsCache: Record<string, any>;
    writtenComponents: Component[];
    writtenDependencies: Component[];
    isolated: boolean;
    bitMap: BitMap;
    basePath?: string;
    saveOnLane?: boolean;
    packageManager?: string;
    isLegacy?: boolean;
    applyPackageJsonTransformers?: boolean;
    resetConfig?: boolean;
    constructor(params: ManyComponentsWriterParams);
    static externalInstaller: ExternalPackageInstaller;
    static externalCompiler: (ids?: BitId[]) => Promise<any>;
    static registerExternalInstaller(installer: ExternalPackageInstaller): void;
    _setBooleanDefault(field: boolean | null | undefined, defaultValue: boolean): boolean;
    writeAll(): Promise<void>;
    _writeComponentsAndDependencies(): Promise<void>;
    _installPackages(): Promise<void>;
    _writeLinks(): Promise<void>;
    _persistComponentsData(): Promise<void>;
    _populateComponentsFilesToWrite(): Promise<void>;
    /**
     * e.g. [bar, bar/foo] => [bar_1, bar/foo]
     * otherwise, the bar/foo component will be saved inside "bar" component.
     * in case bar_1 is taken, increment to bar_2 until the name is available.
     */
    private fixDirsIfNested;
    _getWriteComponentsParams(): ComponentWriterProps[];
    _getWriteParamsOfOneComponent(componentWithDeps: ComponentWithDependencies): ComponentWriterProps;
    _getDefaultWriteParams(): Record<string, any>;
    _populateComponentsDependenciesToWrite(): Promise<void>;
    _moveComponentsIfNeeded(): void;
    _installPackagesIfNeeded(): Promise<void>;
    _getAllLinks(): Promise<DataToPersist>;
    _getComponentRootDir(bitId: BitId): PathLinuxRelative;
    _getDependencyRootDir(bitId: BitId): PathOsBasedRelative;
    _throwErrorWhenDirectoryNotEmpty(componentDir: PathOsBasedAbsolute, componentMap: ComponentMap | null | undefined): void;
}
export {};
