import { BitIds } from '../../bit-id';
import { Scope } from '../../scope';
import { PathLinuxRelative } from '../../utils/path';
import BitMap from '../bit-map/bit-map';
import ComponentMap, { ComponentOrigin } from '../bit-map/component-map';
import Component from '../component/consumer-component';
import PackageJsonFile from '../component/package-json-file';
import Consumer from '../consumer';
export declare type ComponentWriterProps = {
    component: Component;
    writeToPath: PathLinuxRelative;
    writeConfig?: boolean;
    writePackageJson?: boolean;
    override?: boolean;
    isolated?: boolean;
    origin: ComponentOrigin;
    consumer: Consumer | undefined;
    scope?: Scope | undefined;
    bitMap: BitMap;
    ignoreBitDependencies?: boolean | BitIds;
    deleteBitDirContent?: boolean;
    existingComponentMap?: ComponentMap;
    excludeRegistryPrefix?: boolean;
    saveOnLane?: boolean;
    applyPackageJsonTransformers?: boolean;
};
export default class ComponentWriter {
    component: Component;
    writeToPath: PathLinuxRelative;
    writeConfig: boolean;
    writePackageJson: boolean;
    override: boolean;
    isolated: boolean | undefined;
    origin: ComponentOrigin;
    consumer: Consumer | undefined;
    scope?: Scope | undefined;
    bitMap: BitMap;
    ignoreBitDependencies: boolean | BitIds;
    deleteBitDirContent: boolean | undefined;
    existingComponentMap: ComponentMap | undefined;
    excludeRegistryPrefix: boolean;
    saveOnLane: boolean;
    applyPackageJsonTransformers: boolean;
    constructor({ component, writeToPath, writeConfig, writePackageJson, override, isolated, origin, consumer, scope, bitMap, ignoreBitDependencies, deleteBitDirContent, existingComponentMap, excludeRegistryPrefix, saveOnLane, applyPackageJsonTransformers, }: ComponentWriterProps);
    static getInstance(componentWriterProps: ComponentWriterProps): ComponentWriter;
    /**
     * write the component to the filesystem and update .bitmap with the details.
     *
     * bitMap gets updated before writing the files to the filesystem, because as part of writing the
     * package-json file, the componentMap is needed to be stored with the updated version.
     *
     * when a component is not new, write the files according to the paths in .bitmap.
     */
    write(): Promise<Component>;
    populateComponentsFilesToWrite(packageManager?: string): Promise<Component>;
    private throwForImportingLegacyIntoHarmony;
    populateFilesToWriteToComponentDir(packageManager?: string): Promise<void>;
    /**
     * currently, it writes all artifacts.
     * later, this responsibility might move to pkg extension, which could write only artifacts
     * that are set in package.json.files[], to have a similar structure of a package.
     */
    private populateArtifacts;
    private getArtifactsDir;
    addComponentToBitMap(rootDir: string | undefined): ComponentMap;
    /**
     * these changes were entered manually by a user via `overrides` key
     */
    _mergePackageJsonPropsFromOverrides(packageJson: PackageJsonFile): void;
    /**
     * these are changes made by aspects
     */
    _applyTransformers(component: Component, packageJson: PackageJsonFile): Promise<void>;
    /**
     * these are changes done by a compiler
     */
    _mergeChangedPackageJsonProps(packageJson: PackageJsonFile): void;
    /**
     * see https://github.com/teambit/bit/issues/1808 for more info why it's needed
     */
    _replaceDistPathTemplateWithCalculatedDistPath(packageJson: PackageJsonFile): Record<string, any>;
    _copyFilesIntoDistsWhenDistsOutsideComponentDir(): void;
    _updateComponentRootPathAccordingToBitMap(): void;
    /**
     * when there is componentMap, this component (with this version or other version) is already part of the project.
     * There are several options as to what was the origin before and what is the origin now and according to this,
     * we update/remove/don't-touch the record in bit.map.
     * 1) current origin is AUTHORED - If the version is the same as before, don't update bit.map. Otherwise, update.
     * 2) current origin is IMPORTED - If the version is the same as before, don't update bit.map. Otherwise, update.
     * 3) current origin is NESTED - If it was not NESTED before, don't update.
     */
    _updateBitMapIfNeeded(): void;
    _updateConsumerConfigIfNeeded(): Promise<void>;
    _determineWhetherToWriteConfig(): void;
    /**
     * don't write the package.json for an authored component, because its dependencies are managed
     * by the root package.json
     */
    _determineWhetherToWritePackageJson(): void;
    /**
     * when a user imports a component that was a dependency before, write the component directly
     * into the components directory for an easy access/change. Then, remove the current record from
     * bit.map and add an updated one.
     */
    _handlePreviouslyNestedCurrentlyImportedCase(): Promise<void>;
    /**
     * For IMPORTED component we have to delete the content of the directory before importing.
     * Otherwise, when the author adds new files outside of the previous originallySharedDir and this user imports them
     * the environment will contain both copies, the old one with the old originallySharedDir and the new one.
     * If a user made changes to the imported component, it will show a warning and stop the process.
     */
    _determineWhetherToDeleteComponentDirContent(): void;
    _updateFilesBasePaths(): void;
    _cleanOldNestedComponent(): Promise<void>;
    _removeNodeModulesLinksFromDependents(): Promise<void>;
    _getNextPatchVersion(): string;
}
