"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _equals2() {
  const data = _interopRequireDefault(require("ramda/src/equals"));

  _equals2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _ramdaAdjunct() {
  const data = require("ramda-adjunct");

  _ramdaAdjunct = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _jsonFile() {
  const data = _interopRequireDefault(require("../component/sources/json-file"));

  _jsonFile = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("./extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * There are two Bit Config: WorkspaceConfig and ComponentConfig, both inherit this class.
 * The config data can be written in package.json inside "bit" property. And, can be written in
 * bit.json file. Also, it might be written in both, in which case, if there is any conflict, the
 * bit.json wins.
 */
class AbstractConfig {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  constructor(props) {
    (0, _defineProperty2().default)(this, "path", void 0);
    (0, _defineProperty2().default)(this, "_compiler", void 0);
    (0, _defineProperty2().default)(this, "_tester", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "compilerDependencies", void 0);
    (0, _defineProperty2().default)(this, "testerDependencies", void 0);
    (0, _defineProperty2().default)(this, "lang", void 0);
    (0, _defineProperty2().default)(this, "bindingPrefix", void 0);
    (0, _defineProperty2().default)(this, "extensions", void 0);
    (0, _defineProperty2().default)(this, "writeToPackageJson", false);
    (0, _defineProperty2().default)(this, "writeToBitJson", false);
    this._compiler = props.compiler || {};
    this._tester = props.tester || {};
    this.lang = props.lang || _constants().DEFAULT_LANGUAGE;
    this.bindingPrefix = props.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;
    this.extensions = props.extensions || new (_extensionData().ExtensionDataList)();
  }

  get compiler() {
    const compilerObj = AbstractConfig.transformEnvToObject(this._compiler);
    if ((0, _isEmpty2().default)(compilerObj)) return undefined;
    return compilerObj;
  }

  setCompiler(compiler) {
    this._compiler = AbstractConfig.transformEnvToObject(compiler);
  }

  get tester() {
    const testerObj = AbstractConfig.transformEnvToObject(this._tester);
    if ((0, _isEmpty2().default)(testerObj)) return undefined;
    return testerObj;
  }

  setTester(tester) {
    this._tester = AbstractConfig.transformEnvToObject(tester);
  }

  hasCompiler() {
    return !!this.compiler && this._compiler !== _constants().NO_PLUGIN_TYPE && !(0, _isEmpty2().default)(this.compiler);
  }

  hasTester() {
    return !!this.tester && this._tester !== _constants().NO_PLUGIN_TYPE && !(0, _isEmpty2().default)(this.tester);
  }

  getEnvsByType(type) {
    if (type === _constants().COMPILER_ENV_TYPE) {
      return this.compiler;
    }

    return this.tester;
  }
  /**
   * if there is only one env (compiler/tester) and it doesn't have any special configuration, only
   * the name, convert it to a string.
   */


  static convertEnvToStringIfPossible(envObj) {
    if (!envObj) return undefined;
    if (Object.keys(envObj).length !== 1) return envObj; // it has more than one id

    const envId = Object.keys(envObj)[0];

    if ((0, _ramdaAdjunct().isNilOrEmpty)(envObj[envId].rawConfig) && (0, _ramdaAdjunct().isNilOrEmpty)(envObj[envId].options)) {
      return envId;
    }

    return envObj;
  }

  getDependencies() {
    return _bitId().BitIds.fromObject(this.dependencies);
  }

  toPlainObject() {
    var _this$extensions;

    const isPropDefaultOrNull = (val, key) => {
      if (!val) return false;
      if (key === 'lang') return val !== _constants().DEFAULT_LANGUAGE;
      if (key === 'bindingPrefix') return val !== _constants().DEFAULT_BINDINGS_PREFIX;
      if (key === 'extensions') return !(0, _equals2().default)(val, _constants().DEFAULT_EXTENSIONS);
      return true;
    };

    return (0, _utils().filterObject)({
      lang: this.lang,
      bindingPrefix: this.bindingPrefix,
      env: {
        compiler: AbstractConfig.convertEnvToStringIfPossible(this.compiler),
        tester: AbstractConfig.convertEnvToStringIfPossible(this.tester)
      },
      dependencies: this.dependencies,
      extensions: (_this$extensions = this.extensions) === null || _this$extensions === void 0 ? void 0 : _this$extensions.toConfigObject()
    }, isPropDefaultOrNull);
  }

  async write({
    workspaceDir,
    componentDir
  }) {
    const jsonFiles = await this.prepareToWrite({
      workspaceDir,
      componentDir
    });
    const dataToPersist = new (_dataToPersist().default)();
    dataToPersist.addManyFiles(jsonFiles);
    dataToPersist.addBasePath(workspaceDir); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return dataToPersist.persistAllToFS();
  }

  async prepareToWrite({
    workspaceDir,
    componentDir = '.'
  }) {
    const files = await this.toVinyl({
      workspaceDir,
      componentDir
    });
    return files;
  }

  async toVinyl({
    workspaceDir,
    componentDir = '.'
  }) {
    const plainObject = this.toPlainObject();
    const jsonFiles = [];

    if (this.writeToPackageJson) {
      const packageJsonFile = await _packageJsonFile().default.load(workspaceDir, componentDir);
      packageJsonFile.addOrUpdateProperty('bit', plainObject);
      jsonFiles.push(packageJsonFile.toVinylFile());
    }

    if (this.writeToBitJson) {
      const bitJsonPath = AbstractConfig.composeBitJsonPath(componentDir);
      const params = {
        base: componentDir,
        override: true,
        path: bitJsonPath,
        content: plainObject
      };

      const bitJsonFile = _jsonFile().default.load(params);

      jsonFiles.push(bitJsonFile);
    }

    return jsonFiles;
  }

  static composeBitJsonPath(bitPath) {
    return path().join(bitPath, _constants().BIT_JSON);
  }

  static composePackageJsonPath(bitPath) {
    return path().join(bitPath, _constants().PACKAGE_JSON);
  }

  static async pathHasBitJson(bitPath) {
    return _fsExtra().default.pathExists(this.composeBitJsonPath(bitPath));
  }

  static async pathHasPackageJson(bitPath) {
    return _fsExtra().default.pathExists(this.composePackageJsonPath(bitPath));
  }

  static async loadJsonFileIfExist(jsonFilePath) {
    try {
      const file = await _fsExtra().default.readJson(jsonFilePath);
      return file;
    } catch (e) {
      if (e.code === 'ENOENT') return null;
      throw e;
    }
  }

  static async removeIfExist(bitPath) {
    const dirToRemove = this.composeBitJsonPath(bitPath);
    const exists = await _fsExtra().default.pathExists(dirToRemove);

    if (exists) {
      _logger().default.info(`abstract-config, deleting ${dirToRemove}`);

      await _fsExtra().default.remove(dirToRemove);
      return true;
    }

    return false;
  }

  static transformEnvToObject(env) {
    if (typeof env === 'string') {
      if (env === _constants().NO_PLUGIN_TYPE) return {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return {
        [env]: {}
      };
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return env;
  }

}

exports.default = AbstractConfig;