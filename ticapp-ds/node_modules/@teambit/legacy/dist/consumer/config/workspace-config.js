"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _propOr2() {
  const data = _interopRequireDefault(require("ramda/src/propOr"));

  _propOr2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _merge2() {
  const data = _interopRequireDefault(require("ramda/src/merge"));

  _merge2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _filterObject() {
  const data = _interopRequireDefault(require("../../utils/filter-object"));

  _filterObject = function () {
    return data;
  };

  return data;
}

function _abstractConfig() {
  const data = _interopRequireDefault(require("./abstract-config"));

  _abstractConfig = function () {
    return data;
  };

  return data;
}

function _consumerOverrides() {
  const data = _interopRequireDefault(require("./consumer-overrides"));

  _consumerOverrides = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _invalidConfigPropPath() {
  const data = _interopRequireDefault(require("./exceptions/invalid-config-prop-path"));

  _invalidConfigPropPath = function () {
    return data;
  };

  return data;
}

function _invalidPackageManager() {
  const data = _interopRequireDefault(require("./exceptions/invalid-package-manager"));

  _invalidPackageManager = function () {
    return data;
  };

  return data;
}

const DEFAULT_USE_WORKSPACES = false;
const DEFAULT_MANAGE_WORKSPACES = true;

class WorkspaceConfig extends _abstractConfig().default {
  // path where to store build artifacts
  // path to remove while storing build artifacts. If, for example the code is in 'src' directory, and the component
  // is-string is in src/components/is-string, the dists files will be in dists/component/is-string (without the 'src')
  // save hub dependencies as bit components rather than npm packages
  // package manager client to use
  // package manager process options
  // Enables integration with Yarn Workspaces
  // manage workspaces with yarn
  // workspace package.json if exists (parsed)
  // default remote scope to export to
  static registerOnWorkspaceConfigIsExist(func) {
    this.workspaceConfigIsExistRegistry = func;
  }

  static registerOnWorkspaceConfigLoading(func) {
    this.workspaceConfigLoadingRegistry = func;
  }

  static registerOnWorkspaceConfigEnsuring(func) {
    this.workspaceConfigEnsuringRegistry = func;
  }

  static registerOnWorkspaceConfigReset(func) {
    this.workspaceConfigResetRegistry = func;
  }

  constructor({
    compiler,
    tester,
    saveDependenciesAsComponents = _constants().DEFAULT_SAVE_DEPENDENCIES_AS_COMPONENTS,
    lang,
    distTarget,
    distEntry,
    componentsDefaultDirectory = _constants().DEFAULT_COMPONENTS_DIR_PATH,
    dependenciesDirectory = _constants().DEFAULT_DEPENDENCIES_DIR_PATH,
    bindingPrefix,
    extensions,
    packageManager = _constants().DEFAULT_PACKAGE_MANAGER,
    packageManagerArgs,
    packageManagerProcessOptions,
    useWorkspaces = DEFAULT_USE_WORKSPACES,
    manageWorkspaces = DEFAULT_MANAGE_WORKSPACES,
    resolveModules,
    defaultScope,
    overrides = _consumerOverrides().default.load()
  }) {
    super({
      compiler,
      tester,
      lang,
      bindingPrefix,
      extensions
    });
    (0, _defineProperty2().default)(this, "distTarget", void 0);
    (0, _defineProperty2().default)(this, "distEntry", void 0);
    (0, _defineProperty2().default)(this, "componentsDefaultDirectory", void 0);
    (0, _defineProperty2().default)(this, "dependenciesDirectory", void 0);
    (0, _defineProperty2().default)(this, "saveDependenciesAsComponents", void 0);
    (0, _defineProperty2().default)(this, "packageManager", void 0);
    (0, _defineProperty2().default)(this, "packageManagerArgs", void 0);
    (0, _defineProperty2().default)(this, "packageManagerProcessOptions", void 0);
    (0, _defineProperty2().default)(this, "useWorkspaces", void 0);
    (0, _defineProperty2().default)(this, "manageWorkspaces", void 0);
    (0, _defineProperty2().default)(this, "resolveModules", void 0);
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "packageJsonObject", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);

    if (packageManager !== 'npm' && packageManager !== 'yarn') {
      throw new (_invalidPackageManager().default)(packageManager);
    }

    this.distTarget = distTarget;
    this.distEntry = distEntry;
    this.componentsDefaultDirectory = componentsDefaultDirectory; // Make sure we have the component name in the path. otherwise components will be imported to the same dir.

    if (!componentsDefaultDirectory.includes('{name}')) {
      this.componentsDefaultDirectory = `${this.componentsDefaultDirectory}/{name}`;
    }

    this.dependenciesDirectory = dependenciesDirectory;
    this.saveDependenciesAsComponents = saveDependenciesAsComponents;
    this.packageManager = packageManager;
    this.packageManagerArgs = packageManagerArgs;
    this.packageManagerProcessOptions = packageManagerProcessOptions;
    this.useWorkspaces = useWorkspaces;
    this.manageWorkspaces = manageWorkspaces;
    this.resolveModules = resolveModules;
    this.defaultScope = defaultScope;
    this.overrides = overrides;
  }

  toPlainObject() {
    const superObject = super.toPlainObject();
    let consumerObject = (0, _merge2().default)(superObject, {
      componentsDefaultDirectory: this.componentsDefaultDirectory,
      dependenciesDirectory: this.dependenciesDirectory,
      saveDependenciesAsComponents: this.saveDependenciesAsComponents,
      packageManager: this.packageManager,
      packageManagerArgs: this.packageManagerArgs,
      packageManagerProcessOptions: this.packageManagerProcessOptions,
      useWorkspaces: this.useWorkspaces,
      manageWorkspaces: this.manageWorkspaces,
      resolveModules: this.resolveModules,
      defaultScope: this.defaultScope,
      overrides: this.overrides.overrides
    });

    if (this.distEntry || this.distTarget) {
      const dist = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (this.distEntry) dist.entry = this.distEntry; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (this.distTarget) dist.target = this.distTarget;
      consumerObject = (0, _merge2().default)(consumerObject, {
        dist
      });
    }

    const isPropDefault = (val, key) => {
      if (key === 'dependenciesDirectory') return val !== _constants().DEFAULT_DEPENDENCIES_DIR_PATH;
      if (key === 'useWorkspaces') return val !== DEFAULT_USE_WORKSPACES;
      if (key === 'manageWorkspaces') return val !== DEFAULT_MANAGE_WORKSPACES;
      if (key === 'saveDependenciesAsComponents') return val !== _constants().DEFAULT_SAVE_DEPENDENCIES_AS_COMPONENTS;
      if (key === 'resolveModules') return !(0, _isEmpty2().default)(val);
      if (key === 'defaultScope') return Boolean(val);
      if (key === 'overrides') return !(0, _isEmpty2().default)(val);
      return true;
    };

    return (0, _filterObject().default)(consumerObject, isPropDefault);
  }

  static create(workspaceConfigProps) {
    return new WorkspaceConfig(workspaceConfigProps);
  }

  static async ensure(dirPath, standAlone = false, workspaceConfigProps = {}) {
    const ensureFunc = this.workspaceConfigEnsuringRegistry;
    return ensureFunc(dirPath, standAlone, workspaceConfigProps);
  }

  static async _ensure(workspacePath, standAlone, workspaceConfigProps = {}) {
    try {
      const workspaceConfig = await this.load(workspacePath);
      return workspaceConfig;
    } catch (err) {
      if (err instanceof _exceptions().BitConfigNotFound || err instanceof _exceptions().InvalidBitJson) {
        const consumerBitJson = this.create(workspaceConfigProps);
        const packageJsonExists = await _abstractConfig().default.pathHasPackageJson(workspacePath);

        if (packageJsonExists && !standAlone) {
          consumerBitJson.writeToPackageJson = true;
        } else {
          consumerBitJson.writeToBitJson = true;
        }

        return consumerBitJson;
      }

      throw err;
    }
  }

  static async reset(dirPath, resetHard) {
    const deleteBitJsonFile = async () => {
      const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);

      _logger().default.info(`deleting the workspace configuration file at ${bitJsonPath}`);

      await _fsExtra().default.remove(bitJsonPath);
    };

    if (resetHard) {
      await deleteBitJsonFile();
    }

    const resetFunc = this.workspaceConfigResetRegistry;
    await resetFunc(dirPath, resetHard);
    await WorkspaceConfig.ensure(dirPath);
  }

  static fromPlainObject(object) {
    this.validate(object);
    const {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      env,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      lang,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      componentsDefaultDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependenciesDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dist,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      extensions,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      saveDependenciesAsComponents,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManager,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerArgs,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerProcessOptions,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      useWorkspaces,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      manageWorkspaces,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      resolveModules,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      defaultScope,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrides
    } = object;
    return new WorkspaceConfig({
      compiler: (0, _propOr2().default)(undefined, 'compiler', env),
      tester: (0, _propOr2().default)(undefined, 'tester', env),
      lang,
      bindingPrefix,
      extensions,
      saveDependenciesAsComponents,
      componentsDefaultDirectory,
      dependenciesDirectory,
      packageManager,
      packageManagerArgs,
      packageManagerProcessOptions,
      useWorkspaces,
      manageWorkspaces,
      resolveModules,
      distTarget: (0, _propOr2().default)(undefined, 'target', dist),
      distEntry: (0, _propOr2().default)(undefined, 'entry', dist),
      defaultScope,
      overrides: _consumerOverrides().default.load(overrides)
    });
  }

  static async load(dirPath) {
    const res = await this._loadIfExist(dirPath);

    if (!res) {
      throw new (_exceptions().BitConfigNotFound)();
    }

    return res;
  }

  static async loadIfExist(dirPath) {
    const loadFunc = this.workspaceConfigLoadingRegistry;

    if (loadFunc && typeof loadFunc === 'function') {
      return loadFunc(dirPath);
    }

    return undefined;
  }

  static async isExist(dirPath) {
    const isExistFunc = this.workspaceConfigIsExistRegistry;

    if (isExistFunc && typeof isExistFunc === 'function') {
      return isExistFunc(dirPath);
    }

    return undefined;
  }

  static async _isExist(dirPath) {
    const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);

    const packageJsonPath = _abstractConfig().default.composePackageJsonPath(dirPath);

    const bitJsonExist = await _fsExtra().default.pathExists(bitJsonPath);

    if (bitJsonExist) {
      return true;
    }

    const packageJson = await this.loadPackageJson(packageJsonPath);

    if (packageJson && packageJson.bit) {
      return true;
    }

    return false;
  }

  static async _loadIfExist(dirPath) {
    const bitJsonPath = _abstractConfig().default.composeBitJsonPath(dirPath);

    const packageJsonPath = _abstractConfig().default.composePackageJsonPath(dirPath);

    const [bitJsonFile, packageJsonFile] = await Promise.all([this.loadBitJson(bitJsonPath), // $FlowFixMe
    this.loadPackageJson(packageJsonPath)]);
    const bitJsonConfig = bitJsonFile || {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const packageJsonHasConfig = packageJsonFile && packageJsonFile.bit; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const packageJsonConfig = packageJsonHasConfig ? packageJsonFile.bit : {};
    if ((0, _isEmpty2().default)(bitJsonConfig) && (0, _isEmpty2().default)(packageJsonConfig)) return undefined; // in case of conflicts, bit.json wins package.json

    const config = Object.assign(packageJsonConfig, bitJsonConfig);
    const workspaceConfig = this.fromPlainObject(config);
    workspaceConfig.path = bitJsonPath;
    workspaceConfig.writeToBitJson = Boolean(bitJsonFile);
    workspaceConfig.writeToPackageJson = packageJsonHasConfig;
    workspaceConfig.packageJsonObject = packageJsonFile;
    return workspaceConfig;
  }

  static async loadBitJson(bitJsonPath) {
    try {
      const file = await _abstractConfig().default.loadJsonFileIfExist(bitJsonPath);
      return file;
    } catch (e) {
      throw new (_exceptions().InvalidBitJson)(bitJsonPath);
    }
  }

  static async loadPackageJson(packageJsonPath) {
    try {
      const file = await _abstractConfig().default.loadJsonFileIfExist(packageJsonPath);
      return file;
    } catch (e) {
      throw new (_exceptions().InvalidPackageJson)(packageJsonPath);
    }
  }

  static validate(object) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const {
      componentsDefaultDirectory,
      dependenciesDirectory
    } = object;
    const pathsToValidate = {
      componentsDefaultDirectory,
      dependenciesDirectory
    };
    Object.keys(pathsToValidate).forEach(field => throwForInvalidPath(field, pathsToValidate[field]));

    function throwForInvalidPath(fieldName, pathToValidate) {
      if (pathToValidate && !(0, _utils().isValidPath)(pathToValidate)) {
        throw new (_invalidConfigPropPath().default)(fieldName, pathToValidate);
      }
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    _consumerOverrides().default.validate(object.overrides);
  }

}

exports.default = WorkspaceConfig;
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigIsExistRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigLoadingRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigEnsuringRegistry", void 0);
(0, _defineProperty2().default)(WorkspaceConfig, "workspaceConfigResetRegistry", void 0);