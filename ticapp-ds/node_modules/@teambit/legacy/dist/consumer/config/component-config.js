"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _mergeAll2() {
  const data = _interopRequireDefault(require("ramda/src/mergeAll"));

  _mergeAll2 = function () {
    return data;
  };

  return data;
}

function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));

  _prop2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _merge2() {
  const data = _interopRequireDefault(require("ramda/src/merge"));

  _merge2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _filterObject() {
  const data = _interopRequireDefault(require("../../utils/filter-object"));

  _filterObject = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _abstractConfig() {
  const data = _interopRequireDefault(require("./abstract-config"));

  _abstractConfig = function () {
    return data;
  };

  return data;
}

function _extensionData() {
  const data = require("./extension-data");

  _extensionData = function () {
    return data;
  };

  return data;
}

// TODO: take for some other place like config
// TODO: unify this and the same in src/components/utils/load-extensions/load-resolved-extensions.ts
const ignoreLoadingExtensionsErrors = false;

class ComponentConfig extends _abstractConfig().default {
  // whether a component has bit.json written to FS or package.json written with 'bit' property
  static registerOnComponentConfigLoading(extId, func) {
    this.componentConfigLoadingRegistry[extId] = func;
  }

  static registerOnComponentConfigLegacyLoading(extId, func) {
    this.componentConfigLegacyLoadingRegistry[extId] = func;
  }

  constructor({
    compiler,
    tester,
    lang,
    bindingPrefix,
    extensions,
    defaultScope,
    overrides
  }) {
    super({
      compiler,
      tester,
      lang,
      bindingPrefix,
      extensions
    });
    (0, _defineProperty2().default)(this, "overrides", void 0);
    (0, _defineProperty2().default)(this, "defaultScope", void 0);
    (0, _defineProperty2().default)(this, "componentHasWrittenConfig", false);
    (0, _defineProperty2().default)(this, "packageJsonFile", void 0);
    this.defaultScope = defaultScope;
    this.overrides = overrides;
    this.writeToBitJson = true; // will be changed later to work similar to workspace-config
  }

  toPlainObject() {
    const superObject = super.toPlainObject();
    const componentObject = (0, _merge2().default)(superObject, {
      overrides: this.overrides
    });

    const isPropDefaultOrEmpty = (val, key) => {
      if (key === 'overrides') return !(0, _isEmpty2().default)(val);
      return true;
    };

    return (0, _filterObject().default)(componentObject, isPropDefaultOrEmpty);
  }

  validate(bitJsonPath) {
    if (typeof this.compiler !== 'object' || typeof this.tester !== 'object' || // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.extensions() && typeof this.extensions() !== 'object') {
      throw new (_showDoctorError().default)(`bit.json at "${bitJsonPath}" is invalid, re-import the component with "--conf" flag to recreate it`);
    }
  }
  /**
   * Return the extensions as ExtensionDataList
   *
   * @returns {ExtensionDataList}
   * @memberof ComponentConfig
   */


  parseExtensions() {
    return _extensionData().ExtensionDataList.fromArray(this.extensions);
  }

  static fromPlainObject(object) {
    const {
      env,
      lang,
      bindingPrefix,
      extensions,
      overrides
    } = object;
    let parsedExtensions = new (_extensionData().ExtensionDataList)();

    if (!(extensions instanceof _extensionData().ExtensionDataList)) {
      if (Array.isArray(extensions)) {
        parsedExtensions = _extensionData().ExtensionDataList.fromArray(extensions);
      } else {
        parsedExtensions = _extensionData().ExtensionDataList.fromConfigObject(extensions);
      }
    }

    return new ComponentConfig({
      compiler: env ? (0, _prop2().default)('compiler', env) : undefined,
      tester: env ? (0, _prop2().default)('tester', env) : undefined,
      extensions: parsedExtensions,
      defaultScope: object.defaultScope,
      lang,
      bindingPrefix,
      overrides
    }); // TODO: run runOnLoadEvent
  }

  static fromComponent(component) {
    return new ComponentConfig({
      version: component.version,
      scope: component.scope,
      lang: component.lang,
      bindingPrefix: component.bindingPrefix,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      compiler: component.compiler || {},
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      tester: component.tester || {},
      overrides: component.overrides.componentOverridesData
    }); // TODO: run runOnLoadEvent
  }

  mergeWithComponentData(component) {
    this.bindingPrefix = this.bindingPrefix || component.bindingPrefix;
    this.lang = this.lang || component.lang;
  }
  /**
   * Use the workspaceConfig as a base. Override values if exist in componentConfig
   * This only used for legacy props that were defined in the root like compiler / tester
   */


  static mergeWithWorkspaceRootConfigs(consumer, componentId, componentConfig, workspaceConfig) {
    const plainWorkspaceConfig = workspaceConfig ? workspaceConfig._legacyPlainObject() : undefined;
    let legacyWorkspaceConfigToMerge = {};

    if (plainWorkspaceConfig) {
      legacyWorkspaceConfigToMerge = (0, _filterObject().default)(plainWorkspaceConfig, (val, key) => key !== 'overrides');
    }

    const componentConfigFromWorkspaceToMerge = (workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.getComponentConfig(componentId)) || {};
    const defaultOwner = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.defaultOwner;

    if (defaultOwner && defaultOwner !== _constants().DEFAULT_REGISTRY_DOMAIN_PREFIX) {
      componentConfigFromWorkspaceToMerge.bindingPrefix = defaultOwner.startsWith('@') ? defaultOwner : `@${defaultOwner}`;
    }

    const mergedObject = (0, _mergeAll2().default)([legacyWorkspaceConfigToMerge, componentConfigFromWorkspaceToMerge, componentConfig]);
    mergedObject.extensions = _extensionData().ExtensionDataList.fromConfigObject(mergedObject.extensions); // Do not try to load extension for itself (usually happen when using '*' pattern)

    mergedObject.extensions = mergedObject.extensions.remove(componentId);
    mergedObject.defaultScope = (componentConfigFromWorkspaceToMerge === null || componentConfigFromWorkspaceToMerge === void 0 ? void 0 : componentConfigFromWorkspaceToMerge.defaultScope) || (workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.defaultScope);
    return ComponentConfig.fromPlainObject(mergedObject);
  }
  /**
   * component config is written by default to package.json inside "bit" property.
   * in case "eject-conf" was running or the component was imported with "--conf" flag, the
   * bit.json is written as well.
   *
   * @param {*} componentDir root component directory, needed for loading package.json file.
   * in case a component is authored, leave this param empty to not load the project package.json
   * @param {*} workspaceConfig
   */


  static async loadConfigFromFolder({
    componentDir,
    workspaceDir
  }) {
    let bitJsonPath;
    let componentHasWrittenConfig = false;
    let packageJsonFile;

    if (componentDir) {
      bitJsonPath = _abstractConfig().default.composeBitJsonPath(componentDir);
    }

    const loadBitJson = async () => {
      if (!bitJsonPath) {
        return {};
      }

      try {
        const file = await _abstractConfig().default.loadJsonFileIfExist(bitJsonPath);

        if (file) {
          componentHasWrittenConfig = true;
          return file;
        }

        return {};
      } catch (e) {
        throw new (_showDoctorError().default)(`bit.json at "${bitJsonPath}" is not a valid JSON file, re-import the component with "--conf" flag to recreate it`);
      }
    };

    const loadPackageJson = async () => {
      if (!componentDir) return {};

      try {
        const file = await _packageJsonFile().default.load(workspaceDir, componentDir);
        packageJsonFile = file;
        const packageJsonObject = file.fileExist ? file.packageJsonObject : undefined;
        const packageJsonHasConfig = Boolean(packageJsonObject && packageJsonObject.bit);

        if (packageJsonHasConfig) {
          const packageJsonConfig = packageJsonObject === null || packageJsonObject === void 0 ? void 0 : packageJsonObject.bit;
          componentHasWrittenConfig = true;
          return packageJsonConfig;
        }

        return {};
      } catch (e) {
        throw new (_showDoctorError().default)(`package.json at ${_abstractConfig().default.composePackageJsonPath(componentDir)} is not a valid JSON file, consider to re-import the file to re-generate the file`);
      }
    };

    const [bitJsonConfig, packageJsonConfig] = await Promise.all([loadBitJson(), loadPackageJson()]); // in case of conflicts, bit.json wins package.json

    const config = Object.assign(packageJsonConfig, bitJsonConfig);
    return {
      config,
      bitJsonPath,
      packageJsonFile,
      componentHasWrittenConfig
    };
  }
  /**
   * component config is written by default to package.json inside "bit" property.
   * in case "eject-conf" was running or the component was imported with "--conf" flag, the
   * bit.json is written as well.
   *
   * @param {*} componentDir root component directory, needed for loading package.json file.
   * in case a component is authored, leave this param empty to not load the project package.json
   * @param {*} workspaceConfig
   */


  static async load({
    consumer,
    componentId,
    componentDir,
    workspaceDir,
    workspaceConfig
  }) {
    let componentConfig; // Harmony project
    // TODO: consider loading legacy components in vendor folder as legacy instead of as harmony components

    if (!workspaceConfig.isLegacy) {
      const onLoadResults = await this.runOnLoadEvent(this.componentConfigLoadingRegistry, componentId);
      const wsComponentConfig = onLoadResults[0];
      const defaultScope = wsComponentConfig.defaultScope;
      const splittedScope = defaultScope.split('.');
      const defaultOwner = splittedScope.length === 1 ? defaultScope : splittedScope[0];

      let bindingPrefix = _constants().DEFAULT_REGISTRY_DOMAIN_PREFIX;

      if (defaultOwner && defaultOwner !== _constants().DEFAULT_REGISTRY_DOMAIN_PREFIX) {
        bindingPrefix = defaultOwner.startsWith('@') ? defaultOwner : `@${defaultOwner}`;
      }

      componentConfig = new ComponentConfig({
        extensions: wsComponentConfig.extensions,
        defaultScope,
        bindingPrefix
      }); // Legacy project
    } else {
      const {
        config,
        bitJsonPath,
        packageJsonFile,
        componentHasWrittenConfig
      } = await this.loadConfigFromFolder({
        componentDir,
        workspaceDir
      });
      componentConfig = ComponentConfig.mergeWithWorkspaceRootConfigs(consumer, componentId, config, workspaceConfig);
      componentConfig.path = bitJsonPath;
      componentConfig.componentHasWrittenConfig = componentHasWrittenConfig;
      componentConfig.packageJsonFile = packageJsonFile;
      await this.runOnLegacyLoadEvent(this.componentConfigLegacyLoadingRegistry, componentId, componentConfig);
    } // @ts-ignore seems to be a bug in ts v3.7.x, it doesn't recognize Promise.all array correctly


    return componentConfig;
  }
  /**
   * Run all subscribers to the component config legacy load event
   *
   * @static
   * @param {ConfigLegacyLoadRegistry} subscribers
   * @param {BitId} id
   * @param {*} config
   * @memberof ComponentConfig
   */


  static async runOnLegacyLoadEvent(subscribers, id, config) {
    _logger().default.debugAndAddBreadCrumb('componentConfigLegacyLoad', `running on legacy load even for component ${id.toString()}`);

    try {
      await (0, _pMapSeries().default)(Object.keys(subscribers), async extId => {
        const func = subscribers[extId];
        return func(id, config);
      });
    } catch (err) {
      if (!ignoreLoadingExtensionsErrors) {
        throw err;
      } // TODO: improve texts


      _logger().default.console(`\nfailed loading an extension for component ${id.toString()}, error is:`, 'warn', 'yellow'); // TODO: this show an ugly error, we should somehow show a proper errors


      _logger().default.console(err, 'warn', 'yellow');

      _logger().default.console('the error has been ignored', 'warn', 'yellow');

      _logger().default.warn('extension on load event throw an error', err);
    }
  }
  /**
   * Run all subscribers to the component config load event
   *
   * @static
   * @param {ConfigLoadRegistry} subscribers
   * @param {BitId} id
   * @memberof ComponentConfig
   */


  static async runOnLoadEvent(subscribers, id) {
    _logger().default.debugAndAddBreadCrumb('componentConfigLoad', `running on load even for component ${id.toString()}`);

    try {
      const res = await (0, _pMapSeries().default)(Object.keys(subscribers), async extId => {
        const func = subscribers[extId];
        return func(id);
      });
      return res;
    } catch (err) {
      if (!ignoreLoadingExtensionsErrors) {
        throw err;
      } // TODO: improve texts


      _logger().default.console(`\nfailed loading an extension for component ${id.toString()}, error is:`, 'warn', 'yellow'); // TODO: this show an ugly error, we should somehow show a proper errors


      _logger().default.console(err, 'warn', 'yellow');

      _logger().default.console('the error has been ignored', 'warn', 'yellow');

      _logger().default.warn('extension on load event throw an error', err);
    }

    return [];
  }

}

exports.default = ComponentConfig;
(0, _defineProperty2().default)(ComponentConfig, "componentConfigLoadingRegistry", {});
(0, _defineProperty2().default)(ComponentConfig, "componentConfigLegacyLoadingRegistry", {});