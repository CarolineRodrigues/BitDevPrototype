"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _prop2() {
  const data = _interopRequireDefault(require("ramda/src/prop"));

  _prop2 = function () {
    return data;
  };

  return data;
}

function _sortBy2() {
  const data = _interopRequireDefault(require("ramda/src/sortBy"));

  _sortBy2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _envFactory() {
  const data = _interopRequireDefault(require("../legacy-extensions/env-factory"));

  _envFactory = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _autoTag() {
  const data = require("../scope/component-ops/auto-tag");

  _autoTag = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../scope/component-ops/scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../scope/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _installExtensions() {
  const data = _interopRequireDefault(require("../scope/extensions/install-extensions"));

  _installExtensions = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../scope/models");

  _models = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("../scope/scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _versionDependencies() {
  const data = require("../scope/version-dependencies");

  _versionDependencies = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _composeComponentPath() {
  const data = require("../utils/bit/compose-component-path");

  _composeComponentPath = function () {
    return data;
  };

  return data;
}

function _packageNameToComponentId() {
  const data = require("../utils/bit/package-name-to-component-id");

  _packageNameToComponentId = function () {
    return data;
  };

  return data;
}

function _bitMap() {
  const data = _interopRequireWildcard(require("./bit-map/bit-map"));

  _bitMap = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = _interopRequireDefault(require("./component"));

  _component = function () {
    return data;
  };

  return data;
}

function _componentStatusLoader() {
  const data = require("./component-ops/component-status-loader");

  _componentStatusLoader = function () {
    return data;
  };

  return data;
}

function _manipulateDir() {
  const data = require("./component-ops/manipulate-dir");

  _manipulateDir = function () {
    return data;
  };

  return data;
}

function _componentLoader() {
  const data = _interopRequireDefault(require("./component/component-loader"));

  _componentLoader = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = require("./component/dependencies");

  _dependencies = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("./component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("./component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _workspaceConfig() {
  const data = _interopRequireDefault(require("./config/workspace-config"));

  _workspaceConfig = function () {
    return data;
  };

  return data;
}

function _consumerLocator() {
  const data = require("./consumer-locator");

  _consumerLocator = function () {
    return data;
  };

  return data;
}

function _dirStructure() {
  const data = _interopRequireDefault(require("./dir-structure/dir-structure"));

  _dirStructure = function () {
    return data;
  };

  return data;
}

function _exceptions2() {
  const data = require("./exceptions");

  _exceptions2 = function () {
    return data;
  };

  return data;
}

function _consumerMigrator() {
  const data = _interopRequireDefault(require("./migrations/consumer-migrator"));

  _consumerMigrator = function () {
    return data;
  };

  return data;
}

function _consumerMigratorManifest() {
  const data = _interopRequireDefault(require("./migrations/consumer-migrator-manifest"));

  _consumerMigratorManifest = function () {
    return data;
  };

  return data;
}

function _unexpectedPackageName() {
  const data = require("./exceptions/unexpected-package-name");

  _unexpectedPackageName = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * @todo: change the class name to Workspace
 */
class Consumer {
  // Mark that the consumer instance is of isolated env and not real
  // list of git hooks added during init process
  // list of git hooks already exists during init process
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // cache loaded components
  // args entered by the user in the command line after '--'
  constructor({
    projectPath,
    config,
    scope,
    created = false,
    isolated = false,
    addedGitHooks,
    existingGitHooks
  }) {
    (0, _defineProperty2().default)(this, "projectPath", void 0);
    (0, _defineProperty2().default)(this, "created", void 0);
    (0, _defineProperty2().default)(this, "config", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "isolated", false);
    (0, _defineProperty2().default)(this, "addedGitHooks", void 0);
    (0, _defineProperty2().default)(this, "existingGitHooks", void 0);
    (0, _defineProperty2().default)(this, "_dirStructure", void 0);
    (0, _defineProperty2().default)(this, "_componentsStatusCache", {});
    (0, _defineProperty2().default)(this, "packageManagerArgs", []);
    (0, _defineProperty2().default)(this, "componentLoader", void 0);
    (0, _defineProperty2().default)(this, "componentStatusLoader", void 0);
    (0, _defineProperty2().default)(this, "packageJson", void 0);
    (0, _defineProperty2().default)(this, "onCacheClear", []);
    this.projectPath = projectPath;
    this.config = config;
    this.created = created;
    this.isolated = isolated;
    this.scope = scope;
    this.addedGitHooks = addedGitHooks;
    this.existingGitHooks = existingGitHooks;
    this.componentLoader = _componentLoader().default.getInstance(this);
    this.componentStatusLoader = new (_componentStatusLoader().ComponentStatusLoader)(this);
    this.packageJson = _packageJsonFile().default.loadSync(projectPath);
  }

  async setBitMap() {
    this.bitMap = await _bitMap().default.load(this);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get compiler() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.getEnv(_constants().COMPILER_ENV_TYPE);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get tester() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.getEnv(_constants().TESTER_ENV_TYPE);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get dirStructure() {
    if (!this._dirStructure) {
      this._dirStructure = new (_dirStructure().default)(this.config.componentsDefaultDirectory, this.config._dependenciesDirectory);
    }

    return this._dirStructure;
  }

  get componentFsCache() {
    return this.componentLoader.componentFsCache;
  }

  get bitmapIdsFromCurrentLane() {
    return this.bitMap.getAllIdsAvailableOnLane();
  }

  get bitMapIdsFromAllLanes() {
    return this.bitMap.getAllBitIdsFromAllLanes();
  }

  clearCache() {
    this.componentLoader.clearComponentsCache();
    this.onCacheClear.forEach(func => func());
  }

  async getEnv(envType, context) {
    const props = this._getEnvProps(envType, context);

    if (!props) return undefined;
    return (0, _envFactory().default)(envType, props);
  }

  getTmpFolder(fullPath = false) {
    if (!fullPath) {
      return _constants().BIT_WORKSPACE_TMP_DIRNAME;
    }

    return path().join(this.getPath(), _constants().BIT_WORKSPACE_TMP_DIRNAME);
  }

  getCurrentLaneId() {
    return _laneId().LocalLaneId.from(this.scope.lanes.getCurrentLaneName() || _constants().DEFAULT_LANE);
  }

  async getCurrentLaneObject() {
    return this.scope.lanes.getCurrentLaneObject();
  }

  async cleanTmpFolder() {
    const tmpPath = this.getTmpFolder(true);
    const exists = await _fsExtra().default.pathExists(tmpPath);

    if (exists) {
      _logger().default.info(`consumer.cleanTmpFolder, deleting ${tmpPath}`);

      return _fsExtra().default.remove(tmpPath);
    }

    return undefined;
  }
  /**
   * Running migration process for consumer to update the stores (.bit.map.json) to the current version
   *
   * @param {any} verbose - print debug logs
   * @returns {Object} - wether the process run and wether it succeeded
   * @memberof Consumer
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  async migrate(verbose) {
    // Check version of stores (bitmap / bitjson) to check if we need to run migrate
    // If migration is needed add loader - loader.start(BEFORE_MIGRATION);
    // bitmap migrate
    if (verbose) console.log('running migration process for consumer'); // eslint-disable-line

    const bitmapSchema = this.bitMap.schema;

    if (_semver().default.gte(bitmapSchema, _bitMap().CURRENT_BITMAP_SCHEMA)) {
      _logger().default.trace('bit.map version is up to date');

      return {
        run: false
      };
    }

    _loader().default.start(_loaderMessages().BEFORE_MIGRATION);

    _logger().default.debugAndAddBreadCrumb('consumer.migrate', `start consumer migration. bitmapSchema ${bitmapSchema}, current schema ${_bitMap().CURRENT_BITMAP_SCHEMA}`);

    const result = await (0, _consumerMigrator().default)(bitmapSchema, _consumerMigratorManifest().default, this.bitMap, verbose);
    result.bitMap.schema = _bitMap().CURRENT_BITMAP_SCHEMA; // mark the bitmap as changed to make sure it persist to FS

    result.bitMap.markAsChanged(); // Update the version of the bitmap instance of the consumer (to prevent duplicate migration)

    this.bitMap.schema = result.bitMap.schema;
    await result.bitMap.write(this.componentFsCache);

    _loader().default.stop();

    return {
      run: true,
      success: true
    };
  }

  async write() {
    await Promise.all([this.config.write({
      workspaceDir: this.projectPath
    }), this.scope.ensureDir()]);
    this.bitMap.markAsChanged();
    await this.writeBitMap();
    return this;
  }

  getPath() {
    return this.projectPath;
  }

  toAbsolutePath(pathStr) {
    if (path().isAbsolute(pathStr)) throw new Error(`toAbsolutePath expects relative path, got ${pathStr}`);
    return path().join(this.projectPath, pathStr);
  }

  getPathRelativeToConsumer(pathToCheck) {
    const absolutePath = path().resolve(pathToCheck); // if pathToCheck was absolute, it returns it back

    return path().relative(this.getPath(), absolutePath);
  }

  getParsedId(id, useVersionFromBitmap = false, searchWithoutScopeInProvidedId = false) {
    if (id.startsWith('@')) {
      throw new (_unexpectedPackageName().UnexpectedPackageName)(id);
    } // @ts-ignore (we know it will never be undefined since it pass throw=true)


    const bitId = this.bitMap.getExistingBitId(id, true, searchWithoutScopeInProvidedId);

    if (!useVersionFromBitmap) {
      const version = _bitId().BitId.getVersionOnlyFromString(id);

      return bitId.changeVersion(version || _constants().LATEST);
    }

    return bitId;
  }

  getParsedIdIfExist(id, useVersionFromBitmap = false, searchWithoutScopeInProvidedId = false) {
    const bitId = this.bitMap.getExistingBitId(id, false, searchWithoutScopeInProvidedId);
    if (!bitId) return undefined;

    if (!useVersionFromBitmap) {
      const version = _bitId().BitId.getVersionOnlyFromString(id);

      return bitId.changeVersion(version || _constants().LATEST);
    }

    return bitId;
  }
  /**
   * throws a ComponentNotFound exception if not found in the model
   */


  async loadComponentFromModel(id) {
    if (!id.version) throw new TypeError('consumer.loadComponentFromModel, version is missing from the id');
    const modelComponent = await this.scope.getModelComponent(id);
    const componentVersion = modelComponent.toComponentVersion(id.version);
    const manipulateDirData = await (0, _manipulateDir().getManipulateDirForExistingComponents)(this, componentVersion);
    return modelComponent.toConsumerComponent(id.version, this.scope.name, this.scope.objects, manipulateDirData);
  }
  /**
   * return a component only when it's stored locally.
   * don't go to any remote server and don't throw an exception if the component is not there.
   */


  async loadComponentFromModelIfExist(id) {
    if (!id.version) return undefined;
    return this.loadComponentFromModel(id).catch(err => {
      if (err instanceof _exceptions().ComponentNotFound) return undefined;
      throw err;
    });
  }

  async loadAllVersionsOfComponentFromModel(id) {
    const modelComponent = await this.scope.getModelComponent(id);
    const componentsP = modelComponent.listVersions().map(async versionNum => {
      const componentVersion = modelComponent.toComponentVersion(versionNum);
      const manipulateDirData = await (0, _manipulateDir().getManipulateDirForExistingComponents)(this, componentVersion);
      return modelComponent.toConsumerComponent(versionNum, this.scope.name, this.scope.objects, manipulateDirData);
    });
    return Promise.all(componentsP);
  }

  async loadComponentWithDependenciesFromModel(id, throwIfNotExist = true) {
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope);

    const getModelComponent = async () => {
      if (throwIfNotExist) return this.scope.getModelComponent(id);
      const modelComponent = await this.scope.getModelComponentIfExist(id);
      if (modelComponent) return modelComponent;
      await scopeComponentsImporter.importMany({
        ids: new (_bitId().BitIds)(id)
      });
      return this.scope.getModelComponent(id);
    };

    const modelComponent = await getModelComponent();

    if (!id.version) {
      throw new TypeError('consumer.loadComponentWithDependenciesFromModel, version is missing from the id');
    }

    const versionDependencies = await scopeComponentsImporter.componentToVersionDependencies(modelComponent, id);
    const manipulateDirData = await (0, _manipulateDir().getManipulateDirWhenImportingComponents)(this.bitMap, [versionDependencies], this.scope.objects);
    return versionDependencies.toConsumer(this.scope.objects, manipulateDirData);
  }

  async loadComponent(id) {
    const {
      components
    } = await this.loadComponents(_bitId().BitIds.fromArray([id]));
    return components[0];
  }

  loadComponentForCapsule(id) {
    return this.componentLoader.loadForCapsule(id);
  }

  async loadComponents(ids, throwOnFailure = true) {
    return this.componentLoader.loadMany(ids, throwOnFailure);
  }

  importEnvironment(bitId, verbose = false, dontPrintEnvMsg) {
    return (0, _installExtensions().default)({
      ids: [{
        componentId: bitId
      }],
      scope: this.scope,
      verbose,
      dontPrintEnvMsg
    });
  }

  async importComponentsLegacy(ids, withAllVersions, saveDependenciesAsComponents) {
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope);

    const versionDependenciesArr = withAllVersions ? await scopeComponentsImporter.importManyWithAllVersions(ids, false) : await scopeComponentsImporter.importMany({
      ids
    });
    const shouldDependenciesSavedAsComponents = await this.shouldDependenciesSavedAsComponents(versionDependenciesArr.map(v => v.component.id), saveDependenciesAsComponents);
    const manipulateDirData = await (0, _manipulateDir().getManipulateDirWhenImportingComponents)(this.bitMap, versionDependenciesArr, this.scope.objects);
    const componentWithDependencies = await (0, _pMapSeries().default)(versionDependenciesArr, versionDependencies => versionDependencies.toConsumer(this.scope.objects, manipulateDirData));
    componentWithDependencies.forEach(componentWithDeps => {
      const shouldSavedAsComponents = shouldDependenciesSavedAsComponents.find(c => c.id.isEqual(componentWithDeps.component.id));

      if (!shouldSavedAsComponents) {
        throw new Error(`saveDependenciesAsComponents is missing for ${componentWithDeps.component.id.toString()}`);
      }

      componentWithDeps.component.dependenciesSavedAsComponents = shouldSavedAsComponents.saveDependenciesAsComponents;
    });
    return componentWithDependencies;
  }

  async importComponentsHarmony(ids, withAllVersions, lanes = []) {
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope);

    const versionDependenciesArr = withAllVersions ? await scopeComponentsImporter.importManyWithAllVersions(ids, false, undefined, lanes) : await scopeComponentsImporter.importMany({
      ids,
      lanes
    });
    const componentWithDependencies = await (0, _pMapSeries().default)(versionDependenciesArr, versionDependencies => versionDependencies.toConsumer(this.scope.objects));
    return componentWithDependencies;
  }

  async importComponentsObjectsHarmony(ids, fromOriginalScope = false, allHistory = false) {
    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope);

    await scopeComponentsImporter.importManyDeltaWithoutDeps(ids, allHistory);

    _loader().default.start(`import ${ids.length} components with their dependencies (if missing)`);

    const versionDependenciesArr = fromOriginalScope ? await scopeComponentsImporter.importManyFromOriginalScopes(ids) : await scopeComponentsImporter.importMany({
      ids
    });
    const componentWithDependencies = await (0, _versionDependencies().multipleVersionDependenciesToConsumer)(versionDependenciesArr, this.scope.objects);
    return componentWithDependencies;
  }

  async shouldDependenciesSavedAsComponents(bitIds, saveDependenciesAsComponents) {
    if (saveDependenciesAsComponents === undefined) {
      saveDependenciesAsComponents = this.config._saveDependenciesAsComponents;
    }

    const remotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope);
    const shouldDependenciesSavedAsComponents = bitIds.map(bitId => {
      return {
        id: bitId,
        // if it doesn't go to the hub, it can't import dependencies as packages
        saveDependenciesAsComponents: this.isLegacy ? saveDependenciesAsComponents || !remotes.isHub(bitId.scope) : false
      };
    });
    return shouldDependenciesSavedAsComponents;
  }
  /**
   * By default, the dists paths are inside the component.
   * If dist attribute is populated in bit.json, the paths are in consumer-root/dist-target.
   */


  shouldDistsBeInsideTheComponent() {
    return !this.config._distEntry && !this.config._distTarget;
  }

  async listComponentsForAutoTagging(modifiedComponents) {
    return (0, _autoTag().getAutoTagPending)(this, modifiedComponents);
  }
  /**
   * Check whether a model representation and file-system representation of the same component is the same.
   * The way how it is done is by converting the file-system representation of the component into
   * a Version object. Once this is done, we have two Version objects, and we can compare their hashes
   */


  async isComponentModified(componentFromModel, componentFromFileSystem) {
    if (!(componentFromModel instanceof _models().Version)) {
      throw new TypeError(`isComponentModified expects componentFromModel to be Version, got ${typeof componentFromModel}`);
    }

    if (!(componentFromFileSystem instanceof _component().default)) {
      throw new TypeError(`isComponentModified expects componentFromFileSystem to be ConsumerComponent, got ${typeof componentFromFileSystem}`);
    }

    if (typeof componentFromFileSystem._isModified === 'undefined') {
      const componentMap = this.bitMap.getComponent(componentFromFileSystem.id);

      if (componentMap.originallySharedDir) {
        componentFromFileSystem.originallySharedDir = componentMap.originallySharedDir;
      }

      componentFromFileSystem.log = componentFromModel.log; // ignore the log, it's irrelevant for the comparison
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const {
        version
      } = await this.scope.sources.consumerComponentToVersion({
        consumer: this,
        consumerComponent: componentFromFileSystem
      }); // sometime dependencies from the FS don't have an exact version.

      const copyDependenciesVersionsFromModelToFS = (dependenciesFS, dependenciesModel) => {
        dependenciesFS.get().forEach(dependency => {
          const dependencyFromModel = dependenciesModel.get().find(modelDependency => modelDependency.id.isEqualWithoutVersion(dependency.id));

          if (dependencyFromModel && !dependency.id.hasVersion()) {
            dependency.id = dependencyFromModel.id;
          }
        });
      };

      copyDependenciesVersionsFromModelToFS(version.dependencies, componentFromModel.dependencies);
      copyDependenciesVersionsFromModelToFS(version.devDependencies, componentFromModel.devDependencies);
      sortProperties(version); // prefix your command with "BIT_LOG=*" to see the actual id changes

      if (process.env.BIT_LOG && componentFromModel.calculateHash().hash !== version.calculateHash().hash) {
        console.log('-------------------componentFromModel------------------------'); // eslint-disable-line no-console

        console.log(componentFromModel.id()); // eslint-disable-line no-console

        console.log('------------------------componentFromFileSystem (version)----'); // eslint-disable-line no-console

        console.log(version.id()); // eslint-disable-line no-console

        console.log('-------------------------END---------------------------------'); // eslint-disable-line no-console
      }

      componentFromFileSystem._isModified = componentFromModel.calculateHash().hash !== version.calculateHash().hash;
    }

    return componentFromFileSystem._isModified;

    function sortProperties(version) {
      // sort the files by 'relativePath' because the order can be changed when adding or renaming
      // files in bitmap, which affects later on the model.
      version.files = (0, _sortBy2().default)((0, _prop2().default)('relativePath'), version.files);
      componentFromModel.files = (0, _sortBy2().default)((0, _prop2().default)('relativePath'), componentFromModel.files);
      version.dependencies.sort();
      version.devDependencies.sort();
      version.packageDependencies = (0, _utils().sortObject)(version.packageDependencies);
      version.devPackageDependencies = (0, _utils().sortObject)(version.devPackageDependencies);
      version.compilerPackageDependencies = (0, _utils().sortObject)(version.compilerPackageDependencies);
      version.testerPackageDependencies = (0, _utils().sortObject)(version.testerPackageDependencies);
      version.peerPackageDependencies = (0, _utils().sortObject)(version.peerPackageDependencies);
      sortOverrides(version.overrides);
      componentFromModel.dependencies.sort();
      componentFromModel.devDependencies.sort();
      componentFromModel.packageDependencies = (0, _utils().sortObject)(componentFromModel.packageDependencies);
      componentFromModel.devPackageDependencies = (0, _utils().sortObject)(componentFromModel.devPackageDependencies);
      componentFromModel.compilerPackageDependencies = (0, _utils().sortObject)(componentFromModel.compilerPackageDependencies);
      componentFromModel.testerPackageDependencies = (0, _utils().sortObject)(componentFromModel.testerPackageDependencies);
      componentFromModel.peerPackageDependencies = (0, _utils().sortObject)(componentFromModel.peerPackageDependencies);
      sortOverrides(componentFromModel.overrides);
    }

    function sortOverrides(overrides) {
      if (!overrides) return;

      _constants().DEPENDENCIES_FIELDS.forEach(field => {
        if (overrides[field]) overrides[field] = (0, _utils().sortObject)(overrides[field]);
      });
    }
  }

  async getManyComponentsStatuses(ids) {
    return this.componentStatusLoader.getManyComponentsStatuses(ids);
  }

  async getComponentStatusById(id) {
    return this.componentStatusLoader.getComponentStatusById(id);
  }

  updateNextVersionOnBitmap(taggedComponents, exactVersion, releaseType, preRelease) {
    taggedComponents.forEach(taggedComponent => {
      const log = taggedComponent.log;
      if (!log) throw new Error('updateNextVersionOnBitmap, unable to get log');
      const nextVersion = {
        version: exactVersion || releaseType,
        // one of them is set for sure
        message: log.message,
        username: log.username,
        email: log.email
      };
      if (preRelease) nextVersion.preRelease = preRelease;
      if (!taggedComponent.componentMap) throw new Error('updateNextVersionOnBitmap componentMap is missing');
      taggedComponent.componentMap.updateNextVersion(nextVersion);
    });
    if (taggedComponents.length) this.bitMap.markAsChanged();
  }

  async updateComponentsVersions(components) {
    const getPackageJsonDir = (componentMap, component, id) => {
      if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
        if (componentMap.hasRootDir()) return null; // no package.json in this case

        return (0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, component), {}, {
          id,
          allowNonScope: true
        }));
      }

      return componentMap.rootDir;
    };

    const currentLane = this.getCurrentLaneId();

    const isAvailableOnMain = async (component, id) => {
      if (currentLane.isDefault()) {
        return true;
      }

      if (!id.hasVersion()) {
        // component was unsnapped on the current lane and is back to a new component
        return true;
      }

      const modelComponent = component instanceof _models().ModelComponent ? component : await this.scope.getModelComponent(component.id);
      return modelComponent.hasHead();
    };

    const updateVersions = async unknownComponent => {
      const id = unknownComponent instanceof _models().ModelComponent ? unknownComponent.toBitIdWithLatestVersionAllowNull() : unknownComponent.id;
      this.bitMap.updateComponentId(id);
      this.bitMap.removeConfig(id);
      const availableOnMain = await isAvailableOnMain(unknownComponent, id);

      if (!availableOnMain) {
        this.bitMap.setComponentProp(id, 'onLanesOnly', true);
      }

      const componentMap = this.bitMap.getComponent(id);
      componentMap.clearNextVersion();

      if (this.isLegacy) {
        // on Harmony, components don't have package.json
        const component = unknownComponent instanceof _component().default ? unknownComponent : await this.loadComponent(unknownComponent.toBitId());
        const packageJsonDir = getPackageJsonDir(componentMap, component, id);
        packageJsonDir // if it has package.json, it's imported, which must have a version
        ? await packageJsonUtils().updateAttribute(this, packageJsonDir, 'version', id.version) : await Promise.resolve();
      }
    }; // important! DO NOT use Promise.all here! otherwise, you're gonna enter into a whole world of pain.
    // imagine tagging comp1 with auto-tagged comp2, comp1 package.json is written while comp2 is
    // trying to get the dependencies of comp1 using its package.json.


    return (0, _pMapSeries().default)(components, updateVersions);
  }

  getComponentIdFromNodeModulesPath(requirePath, bindingPrefix) {
    const {
      packageName
    } = this.splitPackagePathToNameAndFile(requirePath);
    return (0, _packageNameToComponentId().packageNameToComponentId)(this, packageName, bindingPrefix);
  }
  /**
   * e.g.
   * input: @bit/my-scope.my-name/internal-path.js
   * output: { packageName: '@bit/my-scope', internalPath: 'internal-path.js' }
   */


  splitPackagePathToNameAndFile(packagePath) {
    const packagePathWithoutNM = this.stripNodeModulesFromPackagePath(packagePath);
    const packageSplitBySlash = packagePathWithoutNM.split('/');
    const isScopedPackage = packagePathWithoutNM.startsWith('@');
    const packageName = isScopedPackage ? `${packageSplitBySlash.shift()}/${packageSplitBySlash.shift()}` : packageSplitBySlash.shift();
    const internalPath = packageSplitBySlash.join('/');
    return {
      packageName,
      internalPath
    };
  }

  stripNodeModulesFromPackagePath(requirePath) {
    requirePath = (0, _utils().pathNormalizeToLinux)(requirePath);
    const prefix = requirePath.includes('node_modules') ? 'node_modules/' : '';
    const withoutPrefix = prefix ? requirePath.slice(requirePath.indexOf(prefix) + prefix.length) : requirePath;

    if (!withoutPrefix.includes('/') && withoutPrefix.startsWith('@')) {
      throw new (_generalError().default)('getComponentIdFromNodeModulesPath expects the path to have at least one slash for the scoped package, such as @bit/');
    }

    return withoutPrefix;
  }

  composeRelativeComponentPath(bitId) {
    const {
      componentsDefaultDirectory
    } = this.dirStructure; // in the past, scope was the full-scope (owner+scope-name), currently, scope is only the scope-name.

    const compDirBackwardCompatible = this.isLegacy ? componentsDefaultDirectory.replace('{scope}', '{scopeId}') : componentsDefaultDirectory;
    return (0, _composeComponentPath().composeComponentPath)(bitId, compDirBackwardCompatible);
  }

  composeComponentPath(bitId) {
    const addToPath = [this.getPath(), this.composeRelativeComponentPath(bitId)];

    _logger().default.debug(`component dir path: ${addToPath.join('/')}`);

    _analytics().Analytics.addBreadCrumb('composeComponentPath', `component dir path: ${_analytics().Analytics.hashData(addToPath.join('/'))}`);

    return path().join(...addToPath);
  }

  composeRelativeDependencyPath(bitId) {
    const dependenciesDir = this.dirStructure.dependenciesDirStructure;
    return (0, _composeComponentPath().composeDependencyPath)(bitId, dependenciesDir);
  }

  composeDependencyPath(bitId) {
    const relativeDependencyPath = this.composeRelativeDependencyPath(bitId);
    return path().join(this.getPath(), relativeDependencyPath);
  }

  static create(projectPath, noGit = false, workspaceConfigProps) {
    return this.ensure(projectPath, noGit, workspaceConfigProps);
  }

  static _getScopePath(projectPath, noGit) {
    const gitDirPath = path().join(projectPath, _constants().DOT_GIT_DIR);
    let resolvedScopePath = path().join(projectPath, _constants().BIT_HIDDEN_DIR);

    if (!noGit && _fsExtra().default.existsSync(gitDirPath) && !_fsExtra().default.existsSync(resolvedScopePath)) {
      resolvedScopePath = path().join(gitDirPath, _constants().BIT_GIT_DIR);
    }

    return resolvedScopePath;
  }

  static async ensure(projectPath, standAlone = false, workspaceConfigProps) {
    const resolvedScopePath = Consumer._getScopePath(projectPath, standAlone);

    let existingGitHooks; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const scopeP = _scope().Scope.ensure(resolvedScopePath);

    const configP = _workspaceConfig().default.ensure(projectPath, standAlone, workspaceConfigProps);

    const [scope, config] = await Promise.all([scopeP, configP]);
    const consumer = new Consumer({
      projectPath,
      created: true,
      scope,
      config,
      existingGitHooks
    });
    await consumer.setBitMap();
    return consumer;
  }
  /**
   * if resetHard, delete consumer-files: bitMap and bit.json and also the local scope (.bit dir).
   * otherwise, delete the consumer-files only when they are corrupted
   */


  static async reset(projectPath, resetHard, noGit = false) {
    const resolvedScopePath = Consumer._getScopePath(projectPath, noGit);

    _bitMap().default.reset(projectPath, resetHard);

    const scopeP = _scope().Scope.reset(resolvedScopePath, resetHard);

    const configP = _workspaceConfig().default.reset(projectPath, resetHard);

    const packageJsonP = _packageJsonFile().default.reset(projectPath);

    await Promise.all([scopeP, configP, packageJsonP]);
  }

  async resetNew() {
    this.bitMap.resetToNewComponents();
    await _scope().Scope.reset(this.scope.path, true);
  }

  static async createIsolatedWithExistingScope(consumerPath, scope) {
    // if it's an isolated environment, it's normal to have already the consumer
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const config = await _workspaceConfig().default._ensure(consumerPath); // isolated environments in the workspace rely on a physical node_modules folder
    // for this reason, we must use a package manager that supports one

    config.packageManager = 'npm'; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const consumer = new Consumer({
      projectPath: consumerPath,
      created: true,
      scope,
      isolated: true,
      // @ts-ignore @gilad, the config type is incorrect indeed
      config
    });
    await consumer.setBitMap();
    return consumer;
  }

  static locateProjectScope(projectPath) {
    if (_fsExtra().default.existsSync(path().join(projectPath, _constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR))) {
      return path().join(projectPath, _constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR);
    }

    if (_fsExtra().default.existsSync(path().join(projectPath, _constants().BIT_HIDDEN_DIR))) {
      return path().join(projectPath, _constants().BIT_HIDDEN_DIR);
    }

    return undefined;
  }

  static async load(currentPath) {
    const consumerInfo = await (0, _consumerLocator().getConsumerInfo)(currentPath);

    if (!consumerInfo) {
      return Promise.reject(new (_exceptions2().ConsumerNotFound)());
    }

    let consumer;

    if ((!consumerInfo.hasConsumerConfig || !consumerInfo.hasScope) && consumerInfo.hasBitMap) {
      consumer = await Consumer.create(consumerInfo.path);
      await Promise.all([consumer.config.write({
        workspaceDir: consumer.projectPath
      }), consumer.scope.ensureDir()]);
    }

    const config = consumer && consumer.config ? consumer.config : await _workspaceConfig().default.loadIfExist(consumerInfo.path);
    const scopePath = Consumer.locateProjectScope(consumerInfo.path);
    const scope = await _scope().Scope.load(scopePath);
    consumer = new Consumer({
      projectPath: consumerInfo.path,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      config,
      scope
    });
    await consumer.setBitMap();
    return consumer;
  }
  /**
   * legacy is a workspace uses the old bit.json or "bit" prop of package.json.
   * new workspaces use workspace.jsonc file
   */


  get isLegacy() {
    if (!('isLegacy' in this.config)) {
      // this happens for example when running `bit import --compiler`. the environment dir has its
      // own consumer and the config is not ILegacyWorkspaceConfig but WorkspaceConfig
      return true;
    }

    return this.config.isLegacy;
  }
  /**
   * clean up removed components from bitmap
   * @param {BitIds} componentsToRemoveFromFs - delete component that are used by other components.
   */


  async cleanFromBitMap(componentsToRemoveFromFs) {
    _logger().default.debug(`consumer.cleanFromBitMap, cleaning ${componentsToRemoveFromFs.toString()} from .bitmap`);

    this.bitMap.removeComponents(componentsToRemoveFromFs);
  }

  async addRemoteAndLocalVersionsToDependencies(component, loadedFromFileSystem) {
    _logger().default.debug(`addRemoteAndLocalVersionsToDependencies for ${component.id.toString()}`);

    _analytics().Analytics.addBreadCrumb('addRemoteAndLocalVersionsToDependencies', `addRemoteAndLocalVersionsToDependencies for ${_analytics().Analytics.hashData(component.id.toString())}`);

    let modelDependencies = new (_dependencies().Dependencies)([]);
    let modelDevDependencies = new (_dependencies().Dependencies)([]);

    if (loadedFromFileSystem) {
      // when loaded from file-system, the dependencies versions are fetched from bit.map.
      // find the model version of the component and get the stored versions of the dependencies
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const mainComponentFromModel = component.componentFromModel;

      if (mainComponentFromModel) {
        // otherwise, the component is probably on the file-system only and not on the model.
        modelDependencies = mainComponentFromModel.dependencies;
        modelDevDependencies = mainComponentFromModel.devDependencies;
      }
    }

    await component.dependencies.addRemoteAndLocalVersions(this.scope, modelDependencies);
    await component.devDependencies.addRemoteAndLocalVersions(this.scope, modelDevDependencies);
  }

  async getAuthoredAndImportedDependentsIdsOf(components) {
    const authoredAndImportedComponents = this.bitMap.getAllIdsAvailableOnLane([_constants().COMPONENT_ORIGINS.IMPORTED, _constants().COMPONENT_ORIGINS.AUTHORED]);

    const componentsIds = _bitId().BitIds.fromArray(components.map(c => c.id));

    return this.scope.findDirectDependentComponents(authoredAndImportedComponents, componentsIds);
  }

  async getAuthoredAndImportedDependentsComponentsOf(components) {
    const dependentsIds = await this.getAuthoredAndImportedDependentsIdsOf(components);

    const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(this.scope);

    const versionDependenciesArr = await scopeComponentsImporter.importMany({
      ids: dependentsIds
    });
    const manipulateDirData = await (0, _manipulateDir().getManipulateDirWhenImportingComponents)(this.bitMap, versionDependenciesArr, this.scope.objects);
    const dependentComponentsP = versionDependenciesArr.map(c => c.component.toConsumer(this.scope.objects, manipulateDirData));
    return Promise.all(dependentComponentsP);
  }

  async injectConf(componentId, force) {
    const component = await this.loadComponent(componentId);
    return component.injectConfig(this.getPath(), this.bitMap, force);
  }

  _getEnvProps(envType, context) {
    const envs = this.config._getEnvsByType(envType);

    if (!envs) return undefined;
    const envName = Object.keys(envs)[0];
    const envObject = envs[envName];
    return {
      name: envName,
      consumerPath: this.getPath(),
      scopePath: this.scope.getPath(),
      rawConfig: envObject.rawConfig,
      files: envObject.files,
      bitJsonPath: path().dirname(this.config.path),
      options: envObject.options,
      envType,
      context
    };
  }

  async writeBitMap() {
    await this.bitMap.write(this.componentFsCache);
  }

  async onDestroy() {
    await this.cleanTmpFolder();
    await this.scope.scopeJson.writeIfChanged(this.scope.path);
    await this.writeBitMap();
  }

}

exports.default = Consumer;