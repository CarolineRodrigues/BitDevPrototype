"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HarmonyMigrator = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _() {
  const data = require("..");

  _ = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

class HarmonyMigrator {
  constructor(consumer) {
    this.consumer = consumer;
    (0, _defineProperty2().default)(this, "messages", []);
  }

  async migrate() {
    await this.initAsHarmony();
    const status = {
      individualFiles: [],
      changedToRootDir: []
    };
    const authorComponents = this.consumer.bitMap.getAllComponents(_constants().COMPONENT_ORIGINS.AUTHORED);
    authorComponents.forEach(componentMap => {
      if (componentMap.rootDir) return;

      if (!componentMap.trackDir) {
        status.individualFiles.push(componentMap.id.toStringWithoutVersion());
        return;
      }

      componentMap.changeRootDirAndUpdateFilesAccordingly(componentMap.trackDir);
      status.changedToRootDir.push(componentMap.id.toStringWithoutVersion());
      this.consumer.bitMap.markAsChanged();
    });
    this.printResults(status);
    this.printMessages();
  }

  async initAsHarmony() {
    if (!this.consumer.isLegacy) return; // it's already Harmony.

    this.backupAndRemoveBitJson();
    await this.backupAndRemoveBitPropInPkgJson();
    const workspacePath = this.consumer.getPath(); // because Harmony feature is added, the load writes the workspace.jsonc because the configuration
    // files are now missing.

    const consumer = await _().Consumer.load(workspacePath);

    if (!_fsExtra().default.existsSync(_path().default.join(workspacePath, _constants().WORKSPACE_JSONC))) {
      throw new Error('failed initializing the workspace as Harmony');
    }

    this.messages.push('congratulations! your workspace has been initialized as Harmony');
    this.consumer = consumer;
  }

  async backupAndRemoveBitPropInPkgJson() {
    const packageJsonFile = await _packageJsonFile().default.load(this.consumer.getPath());
    if (!packageJsonFile.packageJsonObject.bit) return;
    packageJsonFile.packageJsonObject['bit-legacy'] = packageJsonFile.packageJsonObject.bit;
    delete packageJsonFile.packageJsonObject.bit;
    await packageJsonFile.write();
    this.messages.push(`Harmony doesn't work with the previous "bit" property in the package.json.
this property has been renamed to "bit-legacy". delete it once you don't need it.`);
  }

  backupAndRemoveBitJson() {
    const bitJsonPath = _path().default.join(this.consumer.getPath(), 'bit.json');

    if (!_fsExtra().default.existsSync(bitJsonPath)) return;

    _fsExtra().default.moveSync(bitJsonPath, `${bitJsonPath}.legacy`);

    this.messages.push(`Harmony doesn't work with your previous configuration file ${bitJsonPath}.
this file has been renamed to include ".legacy" suffix. delete it once you don't need it.`);
  }

  throwOnLegacy() {
    if (this.consumer.isLegacy) {
      throw new (_generalError().default)(`your workspace is working in legacy mode.
before starting the migration, please re-init the workspace as harmony by following these steps.
1. backup and remove your workspace settings (either bit.json or "bit" prop in package.json).
2. run "BIT_FEATURES=harmony bit init" (on Windows run "set BIT_FEATURES=harmony && bit init")`);
    }
  }

  printResults(results) {
    if (results.individualFiles.length) {
      _logger().default.console(_chalk().default.red(`these components were added as individual files and not as directories, which are invalid in Harmony
      please make sure each component has its own directory and re-add it. alternatively, use "bit move --component" to help with the move.`));

      _logger().default.console(results.individualFiles.join('\n'));
    }

    if (results.changedToRootDir.length) {
      _logger().default.console(_chalk().default.green('the following components were successfully converted from trackDir to rootDir'));

      _logger().default.console(results.changedToRootDir.join('\n'));
    }

    this.messages.push('please run "bit status" to make sure the workspace is error-free before continue working');
  }

  printMessages() {
    this.messages.forEach(message => {
      _logger().default.console(_chalk().default.bold(`\n[-] ${message}`));
    });
  }

}

exports.HarmonyMigrator = HarmonyMigrator;