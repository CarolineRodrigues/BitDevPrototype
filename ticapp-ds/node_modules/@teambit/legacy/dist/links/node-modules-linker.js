"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _glob() {
  const data = _interopRequireDefault(require("glob"));

  _glob = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../consumer/component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _packageJsonTransformer() {
  const data = require("../consumer/component/package-json-transformer");

  _packageJsonTransformer = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../consumer/component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = require("../utils/path");

  _path2 = function () {
    return data;
  };

  return data;
}

function _linkContent() {
  const data = require("./link-content");

  _linkContent = function () {
    return data;
  };

  return data;
}

function _linkFile() {
  const data = _interopRequireDefault(require("./link-file"));

  _linkFile = function () {
    return data;
  };

  return data;
}

function _linkGenerator() {
  const data = require("./link-generator");

  _linkGenerator = function () {
    return data;
  };

  return data;
}

function _symlink() {
  const data = _interopRequireDefault(require("./symlink"));

  _symlink = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * link given components to node_modules, so it's possible to use absolute link instead of relative
 * for example, require('@bit/remote-scope.bar.foo)
 */
class NodeModuleLinker {
  // preparation for the capsule, which is going to have only BitMap with no Consumer
  constructor(components, consumer, bitMap) {
    (0, _defineProperty2().default)(this, "components", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "bitMap", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    this.components = _componentsList().default.getUniqueComponents(components);
    this.consumer = consumer;
    this.bitMap = bitMap;
    this.dataToPersist = new (_dataToPersist().default)();
  }

  async link() {
    var _this$consumer;

    const links = await this.getLinks();
    const linksResults = this.getLinksResults();
    if (this.consumer) links.addBasePath(this.consumer.getPath());
    await links.persistAllToFS();
    await ((_this$consumer = this.consumer) === null || _this$consumer === void 0 ? void 0 : _this$consumer.componentFsCache.deleteAllDependenciesDataCache());
    return linksResults;
  }

  async getLinks() {
    this.dataToPersist = new (_dataToPersist().default)();
    await this._populateShouldDependenciesSavedAsComponentsData(); // don't use Promise.all because down the road it calls transformPackageJson of pkg aspect, which loads components

    await (0, _pMapSeries().default)(this.components, component => {
      const componentId = component.id.toString();

      _logger().default.debug(`linking component to node_modules: ${componentId}`);

      const componentMap = this.bitMap.getComponent(component.id);
      component.componentMap = componentMap;

      switch (componentMap.origin) {
        case _constants().COMPONENT_ORIGINS.IMPORTED:
          return this._populateImportedComponentsLinks(component);

        case _constants().COMPONENT_ORIGINS.NESTED:
          return this._populateNestedComponentsLinks(component);

        case _constants().COMPONENT_ORIGINS.AUTHORED:
          return this._populateAuthoredComponentsLinks(component);

        default:
          throw new Error(`ComponentMap.origin ${componentMap.origin} of ${componentId} is not recognized`);
      }
    });
    return this.dataToPersist;
  }

  getLinksResults() {
    const linksResults = [];

    const getExistingLinkResult = id => linksResults.find(linkResult => linkResult.id.isEqual(id));

    const addLinkResult = (id, from, to) => {
      if (!id) return;
      const existingLinkResult = getExistingLinkResult(id);

      if (existingLinkResult) {
        existingLinkResult.bound.push({
          from,
          to
        });
      } else {
        linksResults.push({
          id,
          bound: [{
            from,
            to
          }]
        });
      }
    };

    this.dataToPersist.symlinks.forEach(symlink => {
      addLinkResult(symlink.componentId, symlink.src, symlink.dest);
    }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      addLinkResult(file.componentId, file.srcPath, file.path);
    });
    this.components.forEach(component => {
      const existingLinkResult = getExistingLinkResult(component.id);

      if (!existingLinkResult) {
        linksResults.push({
          id: component.id,
          bound: []
        });
      }
    });
    return linksResults;
  }

  async _populateImportedComponentsLinks(component) {
    if (!component.isLegacy) {
      await this._populateImportedNonLegacyComponentsLinks(component);
      return;
    }

    const componentMap = component.componentMap;
    const componentId = component.id; // @todo: this should probably be `const bindingPrefix = component.bindingPrefix;`

    const bindingPrefix = component.bindingPrefix || _constants().DEFAULT_BINDINGS_PREFIX;

    const linkPath = (0, _componentNodeModulesPath().default)({
      bindingPrefix,
      id: componentId,
      allowNonScope: true,
      defaultScope: this._getDefaultScope(component),
      extensions: component.extensions
    }); // when a user moves the component directory, use component.writtenPath to find the correct target
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const srcTarget = component.writtenPath || componentMap.rootDir;
    const shouldDistsBeInsideTheComponent = this.consumer ? this.consumer.shouldDistsBeInsideTheComponent() : true;

    if (this.consumer && !component.dists.isEmpty() && component.dists.writeDistsFiles && !shouldDistsBeInsideTheComponent) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const distTarget = component.dists.getDistDir(this.consumer, componentMap.getRootDir());

      const packagesSymlinks = this._getSymlinkPackages(srcTarget, distTarget, component);

      this.dataToPersist.addManySymlinks(packagesSymlinks);

      const distSymlink = _symlink().default.makeInstance(distTarget, linkPath, componentId);

      distSymlink.forDistOutsideComponentsDir = true;
      this.dataToPersist.addSymlink(distSymlink);
    } else if (srcTarget !== '.') {
      // avoid creating symlinks from node_modules to itself
      this.dataToPersist.addSymlink(_symlink().default.makeInstance(srcTarget, linkPath, componentId, true));
    }

    await this._populateDependenciesAndMissingLinks(component);
  }

  async _populateNestedComponentsLinks(component) {
    await this._populateDependenciesAndMissingLinks(component);
  }

  _getDefaultScope(component) {
    if (component) {
      return component.defaultScope;
    }

    return this.consumer ? this.consumer.config.defaultScope : null;
  }
  /**
   * for Harmony version and above, instead of symlink from the component dir to node_modules,
   * create a directory on node_modules and symlink each one of the source files, this way, the
   * structure is exactly the same as Authored
   */


  async _populateImportedNonLegacyComponentsLinks(component) {
    const componentId = component.id;
    const componentNodeModulesPath = (0, _componentNodeModulesPath().default)({
      bindingPrefix: component.bindingPrefix,
      id: componentId,
      allowNonScope: true,
      defaultScope: this._getDefaultScope(component),
      extensions: component.extensions
    });
    const componentMap = component.componentMap;
    const filesToBind = componentMap.getAllFilesPaths();
    filesToBind.forEach(file => {
      const fileWithRootDir = componentMap.hasRootDir() ? path().join(componentMap.rootDir, file) : file;
      const dest = path().join(componentNodeModulesPath, file);
      this.dataToPersist.addSymlink(_symlink().default.makeInstance(fileWithRootDir, dest, componentId, true));
    });

    this._deleteExistingLinksRootIfSymlink(componentNodeModulesPath); // remove this for now, it should be handled by dependency-linker.addSymlinkFromComponentDirNMToWorkspaceDirNM
    // this.addSymlinkFromComponentDirNMToWorkspaceDirNM(component, componentNodeModulesPath);


    await this._populateDependenciesAndMissingLinks(component);
  }
  /**
   * add symlink from the node_modules in the component's root-dir to the workspace node-modules
   * of the component. e.g.
   * ws-root/node_modules/comp1/node_modules -> ws-root/components/comp1/node_modules
   */
  // private addSymlinkFromComponentDirNMToWorkspaceDirNM(
  //   component: Component,
  //   componentNodeModulesPath: PathOsBasedRelative
  // ) {
  //   const componentMap = component.componentMap as ComponentMap;
  //   if (!componentMap.rootDir || !this.consumer) return;
  //   const nodeModulesInCompRoot = path.join(componentMap.rootDir, 'node_modules');
  //   if (!fs.existsSync(this.consumer.toAbsolutePath(nodeModulesInCompRoot))) return;
  //   const nodeModulesInWorkspaceRoot = path.join(componentNodeModulesPath, 'node_modules');
  //   this.dataToPersist.addSymlink(
  //     Symlink.makeInstance(nodeModulesInCompRoot, nodeModulesInWorkspaceRoot, component.id)
  //   );
  // }

  /**
   * even when an authored component has rootDir, we can't just symlink that rootDir to
   * node_modules/rootDir. it could work only when the main-file is index.js, not for other cases.
   * node expects the module inside node_modules to have either package.json with valid "main"
   * property or an index.js file. this main property can't be relative.
   */


  async _populateAuthoredComponentsLinks(component) {
    const componentId = component.id;
    const linkPath = (0, _componentNodeModulesPath().default)({
      bindingPrefix: component.bindingPrefix,
      id: componentId,
      allowNonScope: true,
      defaultScope: this._getDefaultScope(component),
      extensions: component.extensions
    });
    component.isLegacy ? this.symlinkFilesAuthorLegacy(component, linkPath) : this.symlinkDirAuthorHarmony(component, linkPath);

    this._deleteExistingLinksRootIfSymlink(linkPath);

    this._deleteOldLinksOfIdWithoutScope(component);

    await this._createPackageJsonForAuthor(component);
  }

  symlinkFilesAuthorLegacy(component, linkPath) {
    const componentMap = component.componentMap;
    const filesToBind = componentMap.getAllFilesPaths(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    component.dists.updateDistsPerWorkspaceConfig(component.id, this.consumer, component.componentMap);
    filesToBind.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const isMain = file === componentMap.mainFile;
      const fileWithRootDir = componentMap.hasRootDir() ? path().join(componentMap.rootDir, file) : file;
      const possiblyDist = component.dists.calculateDistFileForAuthored(path().normalize(fileWithRootDir), // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      this.consumer, isMain);
      const dest = path().join(linkPath, file);
      const destRelative = (0, _path2().getPathRelativeRegardlessCWD)(path().dirname(dest), possiblyDist);
      const fileContent = (0, _linkContent().getLinkToFileContent)(destRelative); // if component.compiler is set, this component is working with the old compiler (< v15)
      // and not with compile extension. as such, the dists for author are in the root, not in the
      // component directory. Having symlinks here instead of links causes import of module-paths to
      // break. try e2e-test: 'as author, move individual component files to dedicated directory with bit move --component'

      if (fileContent && component.compiler) {
        const linkFile = _linkFile().default.load({
          filePath: dest,
          content: fileContent,
          srcPath: file,
          componentId: component.id,
          override: true,
          ignorePreviousSymlink: true // in case the component didn't have a compiler before, this file was a symlink

        }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        this.dataToPersist.addFile(linkFile);
      } else {
        // it's an un-supported file, or it's Harmony version and above, create a symlink instead
        this.dataToPersist.addSymlink(_symlink().default.makeInstance(fileWithRootDir, dest, component.id, true));
      }
    });
  }
  /**
   * on Harmony, just symlink the entire source directory into "src" in node-modules.
   */


  symlinkDirAuthorHarmony(component, linkPath) {
    const componentMap = component.componentMap;
    const filesToBind = componentMap.getAllFilesPaths();
    filesToBind.forEach(file => {
      const fileWithRootDir = path().join(componentMap.rootDir, file);
      const dest = path().join(linkPath, file);
      this.dataToPersist.addSymlink(_symlink().default.makeInstance(fileWithRootDir, dest, component.id, true));
    });

    if (_constants().IS_WINDOWS) {
      this.dataToPersist.addSymlink(_symlink().default.makeInstance(componentMap.rootDir, path().join(linkPath, _constants().SOURCE_DIR_SYMLINK_TO_NM), component.id));
    }
  }
  /**
   * Removing existing links root (the package path) - to handle cases it was linked by package manager for example
   * this makes sure we are not affecting other places (like package manager cache) we shouldn't touch
   * If you have a case when this deletes something created by the package manager and it's not the desired behavior,
   * do not delete this code, but make sure the package manger nest the installed version into it's dependent
   * @param component
   */


  _deleteExistingLinksRootIfSymlink(linkPath) {
    try {
      const stat = _fsExtra().default.lstatSync(linkPath);

      if (stat.isSymbolicLink()) {
        this.dataToPersist.removePath(new (_removePath().default)(linkPath));
      }

      return undefined;
    } catch (err) {
      return undefined; // probably file does not exist
    }
  }
  /**
   * for AUTHORED components, when a component is new, upon build, we generate links on
   * node_modules. The path doesn't have the scope-name as it doesn't exist yet. (e.g. @bit/foo).
   * Later on, when the component is exported and has a scope-name, the path is complete.
   * (e.g. @bit/scope.foo). At this stage, this function deletes the old-partial paths.
   *
   * This is not needed in Harmony because in Harmony the node-module has already the default-scope.
   */


  _deleteOldLinksOfIdWithoutScope(component) {
    var _this$consumer2;

    if ((_this$consumer2 = this.consumer) !== null && _this$consumer2 !== void 0 && _this$consumer2.isLegacy && component.id.scope) {
      const previousDest = (0, _componentNodeModulesPath().default)({
        bindingPrefix: component.bindingPrefix,
        id: component.id.changeScope(null),
        allowNonScope: true,
        defaultScope: this._getDefaultScope(component),
        extensions: component.extensions
      });
      this.dataToPersist.removePath(new (_removePath().default)(previousDest));
    }
  }
  /**
   * for IMPORTED and NESTED components
   */


  async _populateDependenciesAndMissingLinks(component) {
    // @ts-ignore loaded from FS, componentMap must be set
    const componentMap = component.componentMap;

    if (component.issues && (component.issues.getIssue(_componentIssues().IssuesClasses.MissingLinks) || component.issues.getIssue(_componentIssues().IssuesClasses.MissingCustomModuleResolutionLinks)) && this.consumer && component.componentFromModel) {
      const componentWithDependencies = await component.toComponentWithDependencies(this.consumer);
      component.copyAllDependenciesFromModel();
      const componentsDependenciesLinks = (0, _linkGenerator().getComponentsDependenciesLinks)([componentWithDependencies], this.consumer, false, this.bitMap);
      this.dataToPersist.addManyFiles(componentsDependenciesLinks.files);
      this.dataToPersist.addManySymlinks(componentsDependenciesLinks.symlinks);
    }

    if (component.hasDependencies()) {
      const dependenciesLinks = await this._getDependenciesLinks(component, componentMap);
      this.dataToPersist.addManySymlinks(dependenciesLinks);
    }
  }
  /**
   * When the dists is outside the components directory, it doesn't have access to the node_modules of the component's
   * root-dir. The solution is to go through the node_modules packages one by one and symlink them.
   */


  _getSymlinkPackages(from, to, component) {
    if (!this.consumer) throw new Error('getSymlinkPackages expects the Consumer to be defined');
    const dependenciesSavedAsComponents = component.dependenciesSavedAsComponents;
    const fromNodeModules = path().join(from, 'node_modules');
    const toNodeModules = path().join(to, 'node_modules');

    _logger().default.debug(`symlinkPackages for dists outside the component directory from ${fromNodeModules} to ${toNodeModules}`);

    const unfilteredDirs = _glob().default.sync('*', {
      cwd: fromNodeModules
    }); // when dependenciesSavedAsComponents the node_modules/@bit has real link files, we don't want to touch them
    // otherwise, node_modules/@bit has packages as any other directory in node_modules


    const dirsToFilter = dependenciesSavedAsComponents ? [this.consumer.config._bindingPrefix] : [];
    const customResolvedData = component.dependencies.getCustomResolvedData();

    if (!(0, _isEmpty2().default)(customResolvedData)) {
      // filter out packages that are actually symlinks to dependencies
      Object.keys(customResolvedData).forEach(importSource => dirsToFilter.push((0, _utils().first)(importSource.split('/'))));
    }

    const dirs = dirsToFilter.length ? unfilteredDirs.filter(dir => !dirsToFilter.includes(dir)) : unfilteredDirs;
    if (!dirs.length) return [];
    return dirs.map(dir => {
      const fromDir = path().join(fromNodeModules, dir);
      const toDir = path().join(toNodeModules, dir);
      return _symlink().default.makeInstance(fromDir, toDir);
    });
  }

  async _getDependenciesLinks(component, componentMap) {
    const getSymlinks = async dependency => {
      var _this$consumer3;

      const dependencyComponentMap = this.bitMap.getComponentIfExist(dependency.id);
      const depModel = await (((_this$consumer3 = this.consumer) === null || _this$consumer3 === void 0 ? void 0 : _this$consumer3.scope.getModelComponentIfExist(dependency.id)) || Promise.resolve());
      const bindingPrefix = depModel ? depModel.bindingPrefix : _constants().DEFAULT_BINDINGS_PREFIX;
      const dependenciesLinks = [];
      if (!dependencyComponentMap || !dependencyComponentMap.hasRootDir()) return dependenciesLinks;
      const parentRootDir = componentMap.getRootDir();
      const dependencyRootDir = dependencyComponentMap.getRootDir();
      dependenciesLinks.push(this._getDependencyLink(parentRootDir, dependency.id, dependencyRootDir, bindingPrefix, component));

      if (this.consumer && !this.consumer.shouldDistsBeInsideTheComponent()) {
        // when dists are written outside the component, it doesn't matter whether a component
        // has dists files or not, in case it doesn't have, the files are copied from the component
        // dir into the dist dir. (see consumer-component.write())
        const from = component.dists.getDistDirForConsumer(this.consumer, parentRootDir);
        const to = component.dists.getDistDirForConsumer(this.consumer, dependencyRootDir);

        const distSymlink = this._getDependencyLink(from, dependency.id, to, bindingPrefix, component);

        distSymlink.forDistOutsideComponentsDir = true;
        dependenciesLinks.push(distSymlink);
      }

      return dependenciesLinks;
    };

    const symlinksP = component.getAllDependencies().map(dependency => getSymlinks(dependency));
    const symlinks = await Promise.all(symlinksP);
    return (0, _flatten2().default)(symlinks);
  }

  _getDependencyLink(parentRootDir, bitId, rootDir, bindingPrefix, component) {
    const relativeDestPath = (0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, component), {}, {
      id: bitId,
      allowNonScope: true,
      bindingPrefix,
      isDependency: true
    }));
    const destPathInsideParent = path().join(parentRootDir, relativeDestPath);
    return _symlink().default.makeInstance(rootDir, destPathInsideParent, bitId);
  }
  /**
   * create package.json on node_modules/@bit/component-name/package.json with a property 'main'
   * pointing to the component's main file.
   * It is needed for Authored components only.
   * Since an authored component doesn't have rootDir, it's impossible to symlink to the component directory.
   * It makes it easier for Author to use absolute syntax between their own components.
   */


  async _createPackageJsonForAuthor(component) {
    var _this$consumer4;

    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const hasPackageJsonAsComponentFile = component.files.some(file => file.relative === _constants().PACKAGE_JSON);
    if (hasPackageJsonAsComponentFile) return; // don't generate package.json on top of the user package.json

    const dest = path().join((0, _componentNodeModulesPath().default)(_objectSpread(_objectSpread({}, component), {}, {
      id: component.id,
      allowNonScope: true
    })));

    const packageJson = _packageJsonFile().default.createFromComponent(dest, component, undefined, true, true);

    if (!((_this$consumer4 = this.consumer) !== null && _this$consumer4 !== void 0 && _this$consumer4.isLegacy)) {
      await this._applyTransformers(component, packageJson);

      if (_constants().IS_WINDOWS) {
        // in the workspace, override the "types" and add the "src" prefix.
        // otherwise, the navigation and auto-complete won't work on the IDE.
        // this is for Windows only. For Linux, we use symlinks for the files.
        packageJson.addOrUpdateProperty('types', `${_constants().SOURCE_DIR_SYMLINK_TO_NM}/${component.mainFile}`);
      }
    }

    if (packageJson.packageJsonObject.version === 'latest') {
      packageJson.packageJsonObject.version = '0.0.1-new';
    } // packageJson.mergePropsFromExtensions(component);
    // TODO: we need to have an hook here to get the transformer from the pkg extension
    // delete the version, otherwise, we have to maintains it. such as, when tagging, it should be
    // changed to the new tagged version.


    delete packageJson.packageJsonObject.version;
    this.dataToPersist.addFile(packageJson.toVinylFile());
  }
  /**
   * links are normally generated by `bit import`, `bit link` and `bit install`.
   * for `bit import` the data about whether dependenciesSavedAsComponents is already populated
   * for the rest, it's not.
   * @todo: avoid repopulating for imported. (not easy because by default, all components get "true").
   */


  async _populateShouldDependenciesSavedAsComponentsData() {
    if (!this.components.length || !this.consumer) return;
    const bitIds = this.components.map(c => c.id);
    const shouldDependenciesSavedAsComponents = await this.consumer.shouldDependenciesSavedAsComponents(bitIds);
    this.components.forEach(component => {
      const shouldSavedAsComponents = shouldDependenciesSavedAsComponents.find(c => c.id.isEqual(component.id));

      if (!shouldSavedAsComponents) {
        throw new Error(`_populateShouldDependenciesSavedAsComponentsData, saveDependenciesAsComponents is missing for ${component.id.toString()}`);
      }

      component.dependenciesSavedAsComponents = shouldSavedAsComponents.saveDependenciesAsComponents;
    });
  }
  /**
   * these are changes made by aspects
   */


  async _applyTransformers(component, packageJson) {
    return _packageJsonTransformer().PackageJsonTransformer.applyTransformers(component, packageJson);
  }

}

exports.default = NodeModuleLinker;