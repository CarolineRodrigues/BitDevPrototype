"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllComponentsLinks = getAllComponentsLinks;
exports.getLinksInDistToWrite = getLinksInDistToWrite;
exports.getReLinkDependentsData = getReLinkDependentsData;
exports.linkAllToNodeModules = linkAllToNodeModules;
exports.reLinkDependents = reLinkDependents;

function _flatten2() {
  const data = _interopRequireDefault(require("ramda/src/flatten"));

  _flatten2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _componentSchema() {
  const data = require("../consumer/component/component-schema");

  _componentSchema = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../consumer/component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function linkGenerator() {
  const data = _interopRequireWildcard(require("../links/link-generator"));

  linkGenerator = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _nodeModulesLinker() {
  const data = _interopRequireDefault(require("./node-modules-linker"));

  _nodeModulesLinker = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function linkAllToNodeModules(consumer, bitIds = []) {
  const componentsIds = bitIds.length ? _bitId().BitIds.fromArray(bitIds) : consumer.bitMap.getAllIdsAvailableOnLane();
  if ((0, _isEmpty2().default)(componentsIds)) return [];
  const {
    components
  } = await consumer.loadComponents(componentsIds);
  const nodeModuleLinker = new (_nodeModulesLinker().default)(components, consumer, consumer.bitMap);
  return nodeModuleLinker.link();
}
/**
 * Relevant for legacy components only (before Harmony).
 */


async function getLinksInDistToWrite(component, componentMap, consumer, bitMap, componentWithDependencies) {
  if (!componentWithDependencies && !consumer) {
    throw new Error('getLinksInDistToWrite expects either consumer or componentWithDependencies to be defined');
  }

  (0, _componentSchema().throwForNonLegacy)(component.isLegacy, getLinksInDistToWrite.name);
  const nodeModuleLinker = new (_nodeModulesLinker().default)([component], consumer, bitMap);
  const nodeModuleLinks = await nodeModuleLinker.getLinks();
  const dataToPersist = new (_dataToPersist().default)();
  dataToPersist.merge(nodeModuleLinks);

  const isAuthored = componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED;

  if (isAuthored) {
    // authored only need the node-modules links
    return dataToPersist;
  }

  const componentWithDeps = // $FlowFixMe
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  componentWithDependencies || (await component.toComponentWithDependencies(consumer));
  const componentsDependenciesLinks = linkGenerator().getComponentsDependenciesLinks([componentWithDeps], consumer, false, bitMap);
  const newMainFile = (0, _utils().pathNormalizeToLinux)(component.dists.calculateMainDistFile(component.mainFile));
  dataToPersist.merge(componentsDependenciesLinks);
  const packageJsonFile = component.packageJsonFile;

  if (packageJsonFile) {
    packageJsonFile.addOrUpdateProperty('main', newMainFile);
    dataToPersist.addFile(packageJsonFile.toVinylFile());
  }

  const entryPoints = linkGenerator().getEntryPointsForComponent(component, consumer, bitMap); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  dataToPersist.addManyFiles(entryPoints);
  return dataToPersist;
}

async function getReLinkDirectlyImportedDependenciesLinks(components, consumer) {
  _logger().default.debug(`reLinkDirectlyImportedDependencies: found ${components.length} components to re-link`);

  const componentsWithDependencies = await Promise.all(components.map(component => component.toComponentWithDependencies(consumer)));
  const componentsDependenciesLinks = linkGenerator().getComponentsDependenciesLinks(componentsWithDependencies, consumer, false, consumer.bitMap);
  const nodeModuleLinker = new (_nodeModulesLinker().default)(components, consumer, consumer.bitMap);
  const nodeModuleLinks = await nodeModuleLinker.getLinks();
  const dataToPersist = new (_dataToPersist().default)();
  dataToPersist.merge(componentsDependenciesLinks);
  dataToPersist.merge(nodeModuleLinks);
  return dataToPersist;
}

async function reLinkDependents(consumer, components) {
  const links = await getReLinkDependentsData(consumer, components, new (_bitId().BitIds)());
  links.addBasePath(consumer.getPath());
  await links.persistAllToFS();
}
/**
 * Not needed for Harmony.
 *
 * needed for the following cases:
 * 1) user is importing a component directly which was a dependency before. (before: NESTED, now: IMPORTED).
 * 2) user used bit-move to move a dependency to another directory.
 * as a result of the cases above, the link from the dependent to the dependency is broken.
 * find the dependents components and re-link them
 */


async function getReLinkDependentsData(consumer, components, linkedComponents) {
  _logger().default.debug('linker: check whether there are direct dependents for re-linking');

  const dataToPersist = new (_dataToPersist().default)();

  if (!consumer.isLegacy) {
    return dataToPersist;
  }

  const directDependentComponents = await consumer.getAuthoredAndImportedDependentsComponentsOf(components);

  if (directDependentComponents.length) {
    if (directDependentComponents.every(c => linkedComponents.has(c.id))) {
      // all components already linked
      return dataToPersist;
    }

    const data = await getReLinkDirectlyImportedDependenciesLinks(directDependentComponents, consumer);
    const packageJsonFiles = await packageJsonUtils().changeDependenciesToRelativeSyntax(consumer, directDependentComponents, components);
    dataToPersist.merge(data);
    dataToPersist.addManyFiles(packageJsonFiles);
  }

  return dataToPersist;
}
/**
 * link the components after import.
 * this process contains the following steps:
 * 1) writing link files to connect imported components to their dependencies
 * 2) writing index.js files (entry-point files) in the root directories of each one of the imported and dependencies components.
 * unless writePackageJson is true, because if package.json is written, its "main" attribute points to the entry-point.
 * 3) creating symlinks from components directories to node_modules
 * 4) in case a component was nested and now imported directly, re-link its dependents
 */


async function getAllComponentsLinks({
  componentsWithDependencies,
  writtenComponents,
  writtenDependencies,
  consumer,
  bitMap,
  createNpmLinkFiles
}) {
  const dataToPersist = new (_dataToPersist().default)();
  const componentsDependenciesLinks = linkGenerator().getComponentsDependenciesLinks(componentsWithDependencies, consumer, createNpmLinkFiles, bitMap);

  if (writtenDependencies) {
    const uniqDependencies = _componentsList().default.getUniqueComponents((0, _flatten2().default)(writtenDependencies));

    const entryPoints = uniqDependencies.map(component => linkGenerator().getEntryPointsForComponent(component, consumer, bitMap));
    dataToPersist.addManyFiles((0, _flatten2().default)(entryPoints));
  }

  const entryPoints = writtenComponents.map(component => linkGenerator().getEntryPointsForComponent(component, consumer, bitMap));
  dataToPersist.addManyFiles((0, _flatten2().default)(entryPoints));
  const bitAngularEntryPoints = writtenComponents.map(component => linkGenerator().getEntryPointForAngularComponent(component, consumer, bitMap)).filter(x => x); // remove nulls when components are not Angular
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  dataToPersist.addManyFiles(bitAngularEntryPoints);
  const allComponents = writtenDependencies ? [...writtenComponents, ...(0, _flatten2().default)(writtenDependencies)] : writtenComponents;
  const nodeModuleLinker = new (_nodeModulesLinker().default)(allComponents, consumer, bitMap);
  const nodeModuleLinks = await nodeModuleLinker.getLinks();
  dataToPersist.merge(nodeModuleLinks);

  if (consumer) {
    const allComponentsIds = _bitId().BitIds.uniqFromArray(allComponents.map(c => c.id));

    const reLinkDependentsData = await getReLinkDependentsData(consumer, writtenComponents, allComponentsIds);
    dataToPersist.merge(reLinkDependentsData);
  }

  dataToPersist.merge(componentsDependenciesLinks);
  return dataToPersist;
}