"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = unTagAction;

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _untagComponent() {
  const data = require("../../../scope/component-ops/untag-component");

  _untagComponent = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

async function unTagAction(version, force, soft, id) {
  const consumer = await (0, _consumer().loadConsumer)();
  const idHasWildcard = (0, _hasWildcard().default)(id);

  const untag = async () => {
    const currentLane = await consumer.getCurrentLaneObject();

    if (idHasWildcard) {
      return (0, _untagComponent().removeLocalVersionsForComponentsMatchedByWildcard)(consumer, currentLane, version, force, id);
    }

    if (id) {
      const bitId = consumer.getParsedId(id); // a user might run the command `bit untag id@version` instead of `bit untag id version`
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (bitId.hasVersion() && !version) version = bitId.version;
      const result = await (0, _untagComponent().removeLocalVersion)(consumer.scope, bitId, currentLane, version, force);
      return [result];
    } // untag all


    return (0, _untagComponent().removeLocalVersionsForAllComponents)(consumer, currentLane, version, force);
  };

  const softUntag = () => {
    const getIds = () => {
      const componentsList = new (_componentsList().default)(consumer);
      const softTaggedComponents = componentsList.listSoftTaggedComponents();

      if (idHasWildcard) {
        return componentsList.listComponentsByIdsWithWildcard([id]);
      }

      if (id) {
        return [consumer.getParsedId(id)];
      }

      return softTaggedComponents;
    };

    const idsToRemoveSoftTags = getIds();
    return idsToRemoveSoftTags.map(bitId => {
      var _componentMap$nextVer;

      const componentMap = consumer.bitMap.getComponent(bitId, {
        ignoreScopeAndVersion: true
      });
      const removedVersion = (_componentMap$nextVer = componentMap.nextVersion) === null || _componentMap$nextVer === void 0 ? void 0 : _componentMap$nextVer.version;
      if (!removedVersion) return null;
      componentMap.clearNextVersion();
      return {
        id: bitId,
        versions: [removedVersion]
      };
    }).filter(x => x);
  };

  let results;
  const isRealUntag = !soft;

  if (isRealUntag) {
    results = await untag();
    await consumer.scope.objects.persist();
    const components = results.map(result => result.component);
    await consumer.updateComponentsVersions(components);
  } else {
    // @ts-ignore null was filtered before.
    results = softUntag();
    consumer.bitMap.markAsChanged();
  }

  await consumer.onDestroy();
  return {
    results,
    isSoftUntag: !isRealUntag
  };
}