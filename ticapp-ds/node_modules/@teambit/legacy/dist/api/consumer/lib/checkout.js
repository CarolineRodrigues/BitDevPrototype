"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = checkout;

function _tail2() {
  const data = _interopRequireDefault(require("ramda/src/tail"));

  _tail2 = function () {
    return data;
  };

  return data;
}

function _head2() {
  const data = _interopRequireDefault(require("ramda/src/head"));

  _head2 = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _checkoutVersion() {
  const data = _interopRequireDefault(require("../../../consumer/versions-ops/checkout-version"));

  _checkoutVersion = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _flagHarmonyOnly() {
  const data = _interopRequireDefault(require("./exceptions/flag-harmony-only"));

  _flagHarmonyOnly = function () {
    return data;
  };

  return data;
}

function _noIdMatchWildcard() {
  const data = _interopRequireDefault(require("./exceptions/no-id-match-wildcard"));

  _noIdMatchWildcard = function () {
    return data;
  };

  return data;
}

async function checkout(values, checkoutProps) {
  _loader().default.start(_loaderMessages().BEFORE_CHECKOUT);

  const consumer = await (0, _consumer().loadConsumer)();

  if (checkoutProps.writeConfig && consumer.config.isLegacy) {
    throw new (_flagHarmonyOnly().default)('--conf');
  }

  await parseValues(consumer, values, checkoutProps);
  const checkoutResults = await (0, _checkoutVersion().default)(consumer, checkoutProps);
  await consumer.onDestroy();
  return checkoutResults;
}

async function parseValues(consumer, values, checkoutProps) {
  const firstValue = (0, _head2().default)(values);
  checkoutProps.version = firstValue && (_bitId().BitId.isValidVersion(firstValue) || firstValue === _constants().LATEST) ? firstValue : undefined;
  const ids = checkoutProps.version ? (0, _tail2().default)(values) : values; // if first value is a version, the rest are ids

  checkoutProps.latestVersion = Boolean(checkoutProps.version && checkoutProps.version === _constants().LATEST);

  if (!firstValue && !checkoutProps.reset && !checkoutProps.all) {
    throw new (_generalError().default)('please enter [values...] or use --reset --all flags');
  }

  if (checkoutProps.reset && checkoutProps.version) {
    throw new (_generalError().default)(`the first argument "${checkoutProps.version}" seems to be a version. however, --reset flag doesn't support a version`);
  }

  if (ids.length && checkoutProps.all) {
    throw new (_generalError().default)('please specify either [ids...] or --all, not both');
  }

  if (!checkoutProps.reset && !checkoutProps.version) {
    if (ids.length) throw new (_generalError().default)(`the specified version "${ids[0]}" is not a valid version`);else throw new (_generalError().default)('please specify a version');
  }

  if (!ids.length) {
    populateAllIds(consumer, checkoutProps);
  } else {
    const idsHasWildcard = (0, _hasWildcard().default)(ids);
    checkoutProps.ids = idsHasWildcard ? getIdsMatchedByWildcard(consumer, checkoutProps, ids) : ids.map(id => consumer.getParsedId(id));
  }
}
/**
 * when user didn't enter any id and used '--all' flag, populate all ids.
 */


function populateAllIds(consumer, checkoutProps) {
  if (!checkoutProps.all) {
    throw new (_generalError().default)('please specify [ids...] or use --all flag');
  }

  checkoutProps.ids = getCandidateIds(consumer, checkoutProps);
}

function getIdsMatchedByWildcard(consumer, checkoutProps, ids) {
  const candidateIds = getCandidateIds(consumer, checkoutProps);

  const matchedIds = _componentsList().default.filterComponentsByWildcard(candidateIds, ids);

  if (!matchedIds.length) throw new (_noIdMatchWildcard().default)(ids);
  return matchedIds;
}

function getCandidateIds(consumer, checkoutProps) {
  const idsFromBitMap = consumer.bitMap.getAuthoredAndImportedBitIds();
  return idsFromBitMap.map(bitId => {
    const version = checkoutProps.latestVersion ? _constants().LATEST : bitId.version;
    return bitId.changeVersion(version);
  });
}