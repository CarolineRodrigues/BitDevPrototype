"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _consumerNotFound() {
  const data = _interopRequireDefault(require("../../../consumer/exceptions/consumer-not-found"));

  _consumerNotFound = function () {
    return data;
  };

  return data;
}

function _getRemoteByName() {
  const data = _interopRequireDefault(require("../../../remotes/get-remote-by-name"));

  _getRemoteByName = function () {
    return data;
  };

  return data;
}

function _scopeGraph() {
  const data = _interopRequireDefault(require("../../../scope/graph/scope-graph"));

  _scopeGraph = function () {
    return data;
  };

  return data;
}

function _vizgraph() {
  const data = _interopRequireDefault(require("../../../scope/graph/vizgraph"));

  _vizgraph = function () {
    return data;
  };

  return data;
}

var paintGraph = async function paintGraph(id, options) {
  const {
    image,
    remote,
    layout,
    allVersions
  } = options;
  const consumer = await (0, _consumer().loadConsumerIfExist)();
  if (!consumer && !remote) throw new (_consumerNotFound().default)();

  const getBitId = () => {
    if (!id) return undefined;
    if (remote) return _bitId().BitId.parse(id, true); // user used --remote so we know it has a scope
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return consumer.getParsedId(id);
  };

  const bitId = getBitId();
  const graph = await getGraph();
  const config = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  if (layout) config.layout = layout;
  const visualDependencyGraph = await _vizgraph().default.loadFromGraphlib(graph, config);

  if (bitId) {
    visualDependencyGraph.highlightId(bitId);
  }

  const result = await visualDependencyGraph.image(image);
  return result;

  async function getGraph() {
    if (remote) {
      if (id) {
        // $FlowFixMe scope must be set as it came from a remote
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const scopeName = typeof remote === 'string' ? remote : bitId.scope;
        const remoteScope = await (0, _getRemoteByName().default)(scopeName, consumer);
        const componentDepGraph = await remoteScope.graph(bitId);
        return componentDepGraph.graph;
      }

      if (typeof remote !== 'string') {
        throw new Error('please specify remote scope name or enter an id');
      }

      const remoteScope = await (0, _getRemoteByName().default)(remote, consumer);
      const componentDepGraph = await remoteScope.graph();
      return componentDepGraph.graph;
    }

    const onlyLatest = !allVersions; // $FlowFixMe consumer must be set here
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const workspaceGraph = await _scopeGraph().default.buildGraphFromWorkspace(consumer, onlyLatest);
    const dependencyGraph = new (_scopeGraph().default)(workspaceGraph);

    if (id) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const componentGraph = dependencyGraph.getSubGraphOfConnectedComponents(bitId);
      const componentDepGraph = new (_scopeGraph().default)(componentGraph);
      return componentDepGraph.graph;
    }

    return dependencyGraph.graph;
  }
};

exports.default = paintGraph;