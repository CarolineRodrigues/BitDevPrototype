"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetch;

function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));

  _path2 = function () {
    return data;
  };

  return data;
}

function _legacyBitId() {
  const data = require("@teambit/legacy-bit-id");

  _legacyBitId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../../scope/component-ops/scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _importComponents() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/import-components"));

  _importComponents = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("../../../consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../../../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _scopeNotFoundOrDenied() {
  const data = require("../../../remotes/exceptions/scope-not-found-or-denied");

  _scopeNotFoundOrDenied = function () {
    return data;
  };

  return data;
}

function _laneNotFound() {
  const data = require("../../scope/lib/exceptions/lane-not-found");

  _laneNotFound = function () {
    return data;
  };

  return data;
}

async function fetch(ids, lanes, components, fromOriginalScope) {
  if (!lanes && !components) {
    throw new (_generalError().default)(`please provide the type of objects you would like to pull, the options are --components and --lanes`);
  }

  _loader().default.start('fetching objects...');

  const consumer = await (0, _consumer().loadConsumer)();

  if (consumer.isLegacy) {
    throw new (_lanesIsDisabled().LanesIsDisabled)();
  }

  const importOptions = {
    ids,
    objectsOnly: true,
    verbose: false,
    withEnvironments: false,
    writePackageJson: false,
    writeConfig: false,
    writeDists: false,
    override: false,
    installNpmPackages: false,
    fromOriginalScope
  };

  if (lanes) {
    importOptions.lanes = await getLanes();
    importOptions.ids = [];
  }

  const importComponents = new (_importComponents().default)(consumer, importOptions);
  const {
    dependencies,
    envComponents,
    importDetails
  } = await importComponents.importComponents();
  const bitIds = dependencies.map((0, _path2().default)(['component', 'id']));

  _analytics().Analytics.setExtraData('num_components', bitIds.length);

  await consumer.onDestroy();
  return {
    dependencies,
    envComponents,
    importDetails
  };

  async function getLanes() {
    const result = {
      laneIds: [],
      lanes: []
    };
    let remoteLaneIds = [];

    if (ids.length) {
      remoteLaneIds = ids.map(id => {
        const trackLane = consumer.scope.lanes.getRemoteTrackedDataByLocalLane(id);
        if (trackLane) return _laneId().RemoteLaneId.from(trackLane.remoteLane, trackLane.remoteScope);
        return _laneId().RemoteLaneId.parse(id);
      });
    } else {
      remoteLaneIds = await consumer.scope.objects.remoteLanes.getAllRemoteLaneIds();
    }

    const scopeComponentImporter = _scopeComponentsImporter().default.getInstance(consumer.scope);

    try {
      const remoteLanes = await scopeComponentImporter.importLanes(remoteLaneIds);
      result.laneIds.push(...remoteLaneIds);
      result.lanes.push(...remoteLanes);
    } catch (err) {
      if (err instanceof _legacyBitId().InvalidScopeName || err instanceof _scopeNotFoundOrDenied().ScopeNotFoundOrDenied || err instanceof _laneNotFound().LaneNotFound || err instanceof _legacyBitId().InvalidScopeNameFromRemote) {
        // the lane could be a local lane so no need to throw an error in such case
        _loader().default.stop();

        _logger().default.console(`unable to get lane's data from a remote due to an error:\n${err.message}`, 'warn', 'yellow');
      } else {
        throw err;
      }
    }

    return result;
  }
}