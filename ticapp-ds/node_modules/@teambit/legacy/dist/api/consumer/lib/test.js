"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = test;
exports.testInProcess = testInProcess;

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _specsRunner() {
  const data = _interopRequireDefault(require("../../../specs-runner/specs-runner"));

  _specsRunner = function () {
    return data;
  };

  return data;
}

/**
 * Run tests for all modified components or for specific component
 * @param {string} id
 * @param {'NONE' | 'ONE' | 'COMPONENT'} forkLevel - run the tests in the current process
 * or in child process, or in child process for each component
 * @param {boolean} verbose
 */
async function test(id, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
forkLevel = _constants().TESTS_FORK_LEVEL.NONE, includeUnmodified = false, verbose) {
  _loader().default.start(_loaderMessages().BEFORE_RUNNING_SPECS);

  if (forkLevel === _constants().TESTS_FORK_LEVEL.NONE) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return testInProcess(id, includeUnmodified, verbose);
  }

  if (forkLevel === _constants().TESTS_FORK_LEVEL.ONE) {
    const ids = id ? [id] : undefined; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return (0, _specsRunner().default)({
      ids,
      forkLevel,
      includeUnmodified,
      verbose
    });
  }

  if (forkLevel === _constants().TESTS_FORK_LEVEL.COMPONENT) {
    const consumer = await (0, _consumer().loadConsumer)(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const components = await _getComponentsAfterBuild(consumer, id, includeUnmodified, verbose);
    const ids = components.map(component => component.id.toString()); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const results = await (0, _specsRunner().default)({
      ids,
      forkLevel,
      verbose
    }); // @ts-ignore obsolete code, no need to fix.

    return results;
  }

  throw new (_generalError().default)('unknown fork level, fork level must be one of: NONE, ONE, COMPONENT');
}

async function testInProcess(id, includeUnmodified = false, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
verbose, dontPrintEnvMsg) {
  const consumer = await (0, _consumer().loadConsumer)();
  const components = await _getComponentsAfterBuild(consumer, id, includeUnmodified, verbose, dontPrintEnvMsg); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  const testsResults = await consumer.scope.testMultiple({
    components,
    consumer,
    verbose,
    dontPrintEnvMsg
  });

  _loader().default.stop();

  await consumer.onDestroy();
  return {
    type: 'results',
    results: testsResults
  };
}

async function _getComponentsAfterBuild(consumer, id, includeUnmodified = false, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
verbose, dontPrintEnvMsg) {
  let components;

  if (id) {
    const idParsed = consumer.getParsedId(id);
    const component = await consumer.loadComponent(idParsed);
    components = [component];
  } else {
    const componentsList = new (_componentsList().default)(consumer);

    _loader().default.start(_loaderMessages().BEFORE_LOADING_COMPONENTS);

    if (includeUnmodified) {
      components = await componentsList.authoredAndImportedComponents();
    } else {
      components = await componentsList.newModifiedAndAutoTaggedComponents();
    }

    _loader().default.stop();
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  await consumer.scope.buildMultiple(components, consumer, false, verbose, dontPrintEnvMsg);
  return components;
}