"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = switchAction;

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("../../../consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _switchLanes() {
  const data = _interopRequireDefault(require("../../../consumer/lanes/switch-lanes"));

  _switchLanes = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("../../../lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("../../../scope/component-ops/scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

async function switchAction(switchProps, checkoutProps) {
  _loader().default.start(_loaderMessages().BEFORE_CHECKOUT);

  const consumer = await (0, _consumer().loadConsumer)();
  if (consumer.isLegacy) throw new (_lanesIsDisabled().LanesIsDisabled)();
  await populateSwitchProps(consumer, switchProps);
  const results = await (0, _switchLanes().default)(consumer, switchProps, checkoutProps);
  await consumer.onDestroy();
  return results;
}

async function populateSwitchProps(consumer, switchProps) {
  const lanes = await consumer.scope.listLanes();

  const isDefaultLane = switchProps.laneName === _constants().DEFAULT_LANE;

  const localLane = lanes.find(lane => lane.name === switchProps.laneName);

  if (isDefaultLane || localLane) {
    populatePropsAccordingToLocalLane();
  } else {
    await populatePropsAccordingToRemoteLane();
  }

  async function populatePropsAccordingToRemoteLane() {
    let remoteLaneId;

    try {
      remoteLaneId = _laneId().RemoteLaneId.parse(switchProps.laneName);
    } catch (e) {
      throw new (_generalError().default)(`invalid lane id "${switchProps.laneName}", the lane ${switchProps.laneName} doesn't exist.`);
    }

    if (remoteLaneId.name === _constants().DEFAULT_LANE) {
      throw new (_generalError().default)(`invalid remote lane id "${switchProps.laneName}". to switch to the main lane on remote,
      run "bit switch main" and then "bit import".`);
    } // fetch the remote to update all heads


    const localTrackedLane = consumer.scope.lanes.getLocalTrackedLaneByRemoteName(remoteLaneId.name, remoteLaneId.scope);
    switchProps.localLaneName = switchProps.newLaneName || localTrackedLane || remoteLaneId.name;

    if (consumer.getCurrentLaneId().name === switchProps.localLaneName) {
      throw new (_generalError().default)(`already checked out to "${switchProps.localLaneName}"`);
    }

    const scopeComponentImporter = _scopeComponentsImporter().default.getInstance(consumer.scope);

    const remoteLaneObjects = await scopeComponentImporter.importFromLanes([remoteLaneId]);

    if (remoteLaneObjects.length === 0) {
      throw new (_generalError().default)(`invalid lane id "${switchProps.laneName}", the lane ${switchProps.laneName} doesn't exist.`);
    }

    const remoteLaneComponents = remoteLaneObjects[0].components;
    switchProps.remoteLaneName = remoteLaneId.name;
    switchProps.laneName = remoteLaneId.name;
    switchProps.remoteLaneScope = remoteLaneId.scope;
    switchProps.remoteScope = remoteLaneId.scope;
    switchProps.ids = remoteLaneComponents.map(l => l.id.changeVersion(l.head.toString()));
    switchProps.remoteLaneComponents = remoteLaneComponents;
    switchProps.localTrackedLane = localTrackedLane || undefined;
    const laneExistsLocally = lanes.find(l => l.name === switchProps.localLaneName);

    if (laneExistsLocally) {
      throw new (_generalError().default)(`unable to checkout to a remote lane ${switchProps.remoteScope}/${switchProps.laneName}.
the local lane "${switchProps.localLaneName}" already exists, please switch to the local lane first by running "bit switch ${switchProps.localLaneName}"
then, to merge the remote lane into the local lane, run "bit lane merge ${switchProps.localLaneName} --remote ${switchProps.remoteScope}"`);
    }
  }

  function populatePropsAccordingToLocalLane() {
    switchProps.localLaneName = switchProps.laneName;

    if (consumer.getCurrentLaneId().name === switchProps.laneName) {
      throw new (_generalError().default)(`already checked out to "${switchProps.laneName}"`);
    }

    if (switchProps.laneName === _constants().DEFAULT_LANE) {
      switchProps.ids = consumer.bitMap.getAuthoredAndImportedBitIdsOfDefaultLane();
      return;
    }

    if (!localLane) {
      throw new (_generalError().default)(`unable to find a local lane "${switchProps.laneName}", to create a new lane please run "bit lane create"`);
    }

    switchProps.ids = localLane.components.map(c => c.id.changeVersion(c.head.toString()));
  }
}