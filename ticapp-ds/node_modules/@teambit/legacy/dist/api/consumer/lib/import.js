"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = importAction;

function _uniq2() {
  const data = _interopRequireDefault(require("ramda/src/uniq"));

  _uniq2 = function () {
    return data;
  };

  return data;
}

function _contains2() {
  const data = _interopRequireDefault(require("ramda/src/contains"));

  _contains2 = function () {
    return data;
  };

  return data;
}

function _forEachObjIndexed2() {
  const data = _interopRequireDefault(require("ramda/src/forEachObjIndexed"));

  _forEachObjIndexed2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _mergeAll2() {
  const data = _interopRequireDefault(require("ramda/src/mergeAll"));

  _mergeAll2 = function () {
    return data;
  };

  return data;
}

function _merge2() {
  const data = _interopRequireDefault(require("ramda/src/merge"));

  _merge2 = function () {
    return data;
  };

  return data;
}

function _path2() {
  const data = _interopRequireDefault(require("ramda/src/path"));

  _path2 = function () {
    return data;
  };

  return data;
}

function _keys2() {
  const data = _interopRequireDefault(require("ramda/src/keys"));

  _keys2 = function () {
    return data;
  };

  return data;
}

function _head2() {
  const data = _interopRequireDefault(require("ramda/src/head"));

  _head2 = function () {
    return data;
  };

  return data;
}

function _compose2() {
  const data = _interopRequireDefault(require("ramda/src/compose"));

  _compose2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _glob() {
  const data = _interopRequireDefault(require("glob"));

  _glob = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _importComponents() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/import-components"));

  _importComponents = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("../../../consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _flattenDependencies() {
  const data = require("../../../scope/flatten-dependencies");

  _flattenDependencies = function () {
    return data;
  };

  return data;
}

function _flagHarmonyOnly() {
  const data = _interopRequireDefault(require("./exceptions/flag-harmony-only"));

  _flagHarmonyOnly = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const key = (0, _compose2().default)(_head2().default, _keys2().default);

async function importAction(importOptions, packageManagerArgs, environmentOptions = {}) {
  async function importEnvironment(consumer) {
    _loader().default.start(_loaderMessages().BEFORE_IMPORT_ENVIRONMENT);

    if (!importOptions.ids.length) throw new (_generalError().default)('you must specify component id for importing an environment');
    const idToImport = importOptions.ids[0];

    const bitIdToImport = _bitId().BitId.parse(idToImport, true); // import without id is not supported


    const envComponents = await consumer.importEnvironment(bitIdToImport, importOptions.verbose, true);
    if (!envComponents.length) throw new (_generalError().default)(`the environment component ${idToImport} is installed already`);
    const id = envComponents[0].component.id.toString();

    async function writeConfigIfNeeded() {
      if (environmentOptions.compiler) {
        consumer.config._setCompiler(id);

        _analytics().Analytics.setExtraData('build_env', id);

        const res = consumer.config.write({
          workspaceDir: consumer.getPath()
        });
        return res;
      }

      if (environmentOptions.tester) {
        consumer.config._setTester(id);

        _analytics().Analytics.setExtraData('test_env', id);

        return consumer.config.write({
          workspaceDir: consumer.getPath()
        });
      }

      return Promise.resolve(true);
    }

    await writeConfigIfNeeded();
    return {
      envComponents
    };
  }

  const consumer = await (0, _consumer().loadConsumer)();
  if (importOptions.skipLane && consumer.isLegacy) throw new (_lanesIsDisabled().LanesIsDisabled)();
  consumer.packageManagerArgs = packageManagerArgs;

  if (environmentOptions.tester || environmentOptions.compiler) {
    return importEnvironment(consumer);
  }

  if (importOptions.writeConfig && consumer.config.isLegacy) {
    throw new (_flagHarmonyOnly().default)('--conf');
  }

  const importComponents = new (_importComponents().default)(consumer, importOptions);
  const {
    dependencies,
    envComponents,
    importDetails
  } = await importComponents.importComponents();
  const bitIds = dependencies.map((0, _path2().default)(['component', 'id']));
  const warnings = await warnForPackageDependencies({
    dependencies: (0, _flattenDependencies().flattenDependencies)(dependencies),
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    envComponents,
    consumer,
    installNpmPackages: importOptions.installNpmPackages
  });

  _analytics().Analytics.setExtraData('num_components', bitIds.length);

  await consumer.onDestroy();
  return {
    dependencies,
    envComponents,
    importDetails,
    warnings
  };
} // TODO: refactor to better use of semver
// TODO: move to bit-javascript


const getSemverType = str => {
  if (_semver().default.valid(str)) return 'V'; // VALID_VERSION

  if (_semver().default.validRange(str)) return 'R'; // RANGE_VERSIONS

  return null;
}; // TODO: refactor to better use of semver
// TODO: move to bit-javascript


function compatibleWith(a, b) {
  const depName = key(a);
  if (!b[depName]) return false; // dependency does not exist - return false

  const bVersion = b[depName];
  const aVersion = a[depName];
  const aType = getSemverType(aVersion);
  const bType = getSemverType(bVersion);
  if (!aType || !bType) return false; // in case one of the versions is invalid - return false

  if (aType === 'V' && bType === 'V') {
    return _semver().default.eq(aVersion, bVersion);
  }

  if (aType === 'V' && bType === 'R') {
    return _semver().default.satisfies(aVersion, bVersion);
  }

  if (aType === 'R' && bType === 'V') {
    return _semver().default.satisfies(bVersion, aVersion);
  }

  if (aType === 'R' && bType === 'R') {
    if (aVersion.startsWith('^') && bVersion.startsWith('^')) {
      const aMajorVersion = parseInt(aVersion[1], 10);
      const bMajorVersion = parseInt(bVersion[1], 10);
      if (aMajorVersion === bMajorVersion) return true;
    }
  }

  return false;
} // TODO: refactor to better use of semver
// TODO: move to bit-javascript


function warnForPackageDependencies({
  dependencies,
  consumer,
  installNpmPackages
}) {
  const warnings = {
    notInPackageJson: [],
    notInNodeModules: [],
    notInBoth: []
  };
  if (installNpmPackages) return Promise.resolve(warnings);
  const projectDir = consumer.getPath();

  const getPackageJson = dir => {
    try {
      return _fsExtra().default.readJSONSync(path().join(dir, 'package.json'));
    } catch (e) {
      return {};
    } // do we want to inform the use that he has no package.json

  };

  const packageJson = getPackageJson(projectDir);
  const packageJsonDependencies = (0, _merge2().default)(packageJson.dependencies || {}, packageJson.devDependencies || {});

  const getNameAndVersion = pj => ({
    [pj.name]: pj.version
  });

  const nodeModules = (0, _mergeAll2().default)(_glob().default.sync(path().join(projectDir, 'node_modules', '*')).map((0, _compose2().default)(getNameAndVersion, getPackageJson))); // eslint-disable-next-line

  dependencies.forEach(dep => {
    if (!dep.packageDependencies || (0, _isEmpty2().default)(dep.packageDependencies)) return null;
    (0, _forEachObjIndexed2().default)((packageDepVersion, packageDepName) => {
      const packageDep = {
        [packageDepName]: packageDepVersion
      };
      const compatibleWithPackgeJson = compatibleWith(packageDep, packageJsonDependencies);
      const compatibleWithNodeModules = compatibleWith(packageDep, nodeModules);

      if (!compatibleWithPackgeJson && !compatibleWithNodeModules && !(0, _contains2().default)(packageDep, warnings.notInBoth)) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        warnings.notInBoth.push(packageDep);
      }

      if (!compatibleWithPackgeJson && compatibleWithNodeModules && !(0, _contains2().default)(packageDep, warnings.notInPackageJson)) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        warnings.notInPackageJson.push(packageDep);
      }

      if (compatibleWithPackgeJson && !compatibleWithNodeModules && !(0, _contains2().default)(packageDep, warnings.notInNodeModules)) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        warnings.notInNodeModules.push(packageDep);
      }
    }, dep.packageDependencies);
  }); // Remove duplicates warnings for missing packages

  warnings.notInBoth = (0, _uniq2().default)(warnings.notInBoth);
  return Promise.resolve(warnings);
}