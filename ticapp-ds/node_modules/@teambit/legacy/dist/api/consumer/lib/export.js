"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exportAction;
exports.registerDefaultScopeGetter = registerDefaultScopeGetter;

function _partition2() {
  const data = _interopRequireDefault(require("ramda/src/partition"));

  _partition2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _objectWithoutProperties2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

  _objectWithoutProperties2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _yn() {
  const data = _interopRequireDefault(require("yn"));

  _yn = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _ejectComponents() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/eject-components"));

  _ejectComponents = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../../../consumer/component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _exportLanes() {
  const data = require("../../../consumer/lanes/export-lanes");

  _exportLanes = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("../../../hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../../links");

  _links = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _prompts() {
  const data = require("../../../prompts");

  _prompts = function () {
    return data;
  };

  return data;
}

function _exportScopeComponents() {
  const data = require("../../../scope/component-ops/export-scope-components");

  _exportScopeComponents = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _idExportedAlready() {
  const data = _interopRequireDefault(require("./exceptions/id-exported-already"));

  _idExportedAlready = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../../../scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const HooksManagerInstance = _hooks().default.getInstance();

let getDefaultScope;

function registerDefaultScopeGetter(func) {
  getDefaultScope = func;
}

async function exportAction(params) {
  HooksManagerInstance.triggerHook(_constants().PRE_EXPORT_HOOK, params);
  const {
    updatedIds,
    nonExistOnBitMap,
    missingScope,
    exported,
    exportedLanes
  } = await exportComponents(params);
  let ejectResults;
  if (params.eject) ejectResults = await ejectExportedComponents(updatedIds);
  const exportResults = {
    componentsIds: exported,
    nonExistOnBitMap,
    missingScope,
    ejectResults,
    exportedLanes
  };
  HooksManagerInstance.triggerHook(_constants().POST_EXPORT_HOOK, exportResults);

  if (_scope().Scope.onPostExport) {
    await _scope().Scope.onPostExport(exported, exportedLanes).catch(err => {
      _logger().default.error('fatal: onPostExport encountered an error (this error does not stop the process)', err);
    });
  }

  return exportResults;
}

async function exportComponents(_ref) {
  let {
    ids,
    remote,
    setCurrentScope,
    includeNonStaged,
    codemod,
    force,
    originDirectly
  } = _ref,
      params = (0, _objectWithoutProperties2().default)(_ref, ["ids", "remote", "setCurrentScope", "includeNonStaged", "codemod", "force", "originDirectly"]);
  const consumer = await (0, _consumer().loadConsumer)();

  if (!consumer.isLegacy && remote) {
    // on Harmony, we don't allow to specify a remote (except lanes), it exports to the default-scope
    ids.push(remote);
    remote = null;
  }

  const {
    idsToExport,
    missingScope,
    idsWithFutureScope,
    laneObject
  } = await getComponentsToExport(ids, consumer, remote, includeNonStaged, force);

  if ((0, _isEmpty2().default)(idsToExport)) {
    return {
      updatedIds: [],
      nonExistOnBitMap: [],
      missingScope,
      exported: [],
      newIdsOnRemote: [],
      exportedLanes: []
    };
  }

  let componentsToExport;

  if (codemod) {
    await _throwForModified(consumer, idsToExport);
    const {
      components
    } = await consumer.loadComponents(idsToExport);
    componentsToExport = components;
  }

  const {
    exported,
    updatedLocally,
    newIdsOnRemote
  } = await (0, _exportScopeComponents().exportMany)(_objectSpread(_objectSpread({}, params), {}, {
    scope: consumer.scope,
    isLegacy: consumer.isLegacy,
    ids: idsToExport,
    remoteName: remote,
    changeLocallyAlthoughRemoteIsDifferent: setCurrentScope,
    codemod,
    laneObject,
    originDirectly,
    idsWithFutureScope
  }));
  if (laneObject) await (0, _exportLanes().updateLanesAfterExport)(consumer, laneObject);

  const {
    updatedIds,
    nonExistOnBitMap
  } = _updateIdsOnBitMap(consumer.bitMap, updatedLocally);

  await linkComponents(updatedIds, consumer);

  _analytics().Analytics.setExtraData('num_components', exported.length);

  if (codemod) {
    await reImportComponents(consumer, updatedIds);
    if (!componentsToExport) throw new Error('componentsToExport was not populated');
    await cleanOldComponents(consumer, _bitId().BitIds.fromArray(updatedIds), componentsToExport);
  } // it is important to have consumer.onDestroy() before running the eject operation, we want the
  // export and eject operations to function independently. we don't want to lose the changes to
  // .bitmap file done by the export action in case the eject action has failed.


  await consumer.onDestroy();
  return {
    updatedIds,
    nonExistOnBitMap,
    missingScope,
    exported,
    newIdsOnRemote,
    exportedLanes: laneObject ? [laneObject] : []
  };
}

function _updateIdsOnBitMap(bitMap, componentsIds) {
  const updatedIds = [];
  const nonExistOnBitMap = new (_bitId().BitIds)();
  componentsIds.forEach(componentsId => {
    const resultId = bitMap.updateComponentId(componentsId, true); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (resultId.hasVersion()) updatedIds.push(resultId);else nonExistOnBitMap.push(resultId);
  });
  return {
    updatedIds,
    nonExistOnBitMap
  };
}

async function getComponentsToExport(ids, consumer, remote, includeNonStaged, force) {
  const componentsList = new (_componentsList().default)(consumer);
  const idsHaveWildcard = (0, _hasWildcard().default)(ids);

  const filterNonScopeIfNeeded = async bitIds => {
    const idsWithFutureScope = await getIdsWithFutureScope(bitIds, consumer, remote);
    if (remote) return {
      idsToExport: bitIds,
      missingScope: [],
      idsWithFutureScope
    };
    const [idsToExport, missingScope] = (0, _partition2().default)(id => {
      const idWithFutureScope = idsWithFutureScope.searchWithoutScopeAndVersion(id);
      if (!idWithFutureScope) throw new Error(`idsWithFutureScope is missing ${id.toString()}`);
      return idWithFutureScope.hasScope();
    }, bitIds);
    return {
      idsToExport: _bitId().BitIds.fromArray(idsToExport),
      missingScope,
      idsWithFutureScope
    };
  };

  const promptForFork = async bitIds => {
    if (force || !remote) return;
    const idsToFork = bitIds.filter(id => id.scope && id.scope !== remote);
    if (!idsToFork.length) return;
    const forkPromptResult = await (0, _prompts().forkComponentsPrompt)(idsToFork, remote)(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (!(0, _yn().default)(forkPromptResult.shouldFork)) {
      throw new (_generalError().default)('the operation has been canceled');
    }
  };

  if ((0, _exportLanes().isUserTryingToExportLanes)(consumer)) {
    if (ids.length) {
      throw new (_generalError().default)(`when checked out to a lane, all its components are exported. please omit the ids`);
    }

    const {
      componentsToExport,
      laneObject
    } = await (0, _exportLanes().getLaneCompIdsToExport)(consumer, includeNonStaged);
    await promptForFork(componentsToExport);
    const loaderMsg = componentsToExport.length > 1 ? _loaderMessages().BEFORE_EXPORTS : _loaderMessages().BEFORE_EXPORT;

    _loader().default.start(loaderMsg);

    const filtered = await filterNonScopeIfNeeded(componentsToExport);
    return _objectSpread(_objectSpread({}, filtered), {}, {
      laneObject
    });
  }

  if (!ids.length || idsHaveWildcard) {
    _loader().default.start(_loaderMessages().BEFORE_LOADING_COMPONENTS);

    const exportPendingComponents = includeNonStaged ? await componentsList.listNonNewComponentsIds() : await componentsList.listExportPendingComponentsIds();
    const componentsToExport = idsHaveWildcard ? _componentsList().default.filterComponentsByWildcard(exportPendingComponents, ids) : exportPendingComponents;
    await promptForFork(componentsToExport);
    const loaderMsg = componentsToExport.length > 1 ? _loaderMessages().BEFORE_EXPORTS : _loaderMessages().BEFORE_EXPORT;

    _loader().default.start(loaderMsg);

    return filterNonScopeIfNeeded(componentsToExport);
  }

  _loader().default.start(_loaderMessages().BEFORE_EXPORT); // show single export


  const parsedIds = await Promise.all(ids.map(id => getParsedId(consumer, id)));
  const statuses = await consumer.getManyComponentsStatuses(parsedIds);
  statuses.forEach(({
    id,
    status
  }) => {
    if (status.nested) {
      throw new (_generalError().default)(`unable to export "${id.toString()}", the component is not fully available. please use "bit import" first`);
    } // don't allow to re-export an exported component unless it's being exported to another scope


    if (remote && !status.staged && id.scope === remote) {
      throw new (_idExportedAlready().default)(id.toString(), remote);
    }
  });
  await promptForFork(parsedIds);
  return filterNonScopeIfNeeded(_bitId().BitIds.fromArray(parsedIds));
}

async function getIdsWithFutureScope(ids, consumer, remote) {
  const workspaceDefaultScope = consumer.config.defaultScope;
  let workspaceDefaultOwner = consumer.config.defaultOwner; // For backward computability don't treat the default binding prefix as real owner

  if (workspaceDefaultOwner === _constants().DEFAULT_BINDINGS_PREFIX) {
    workspaceDefaultOwner = undefined;
  }

  const idsArrayP = ids.map(async id => {
    if (remote) return id.changeScope(remote);
    if (id.hasScope()) return id;
    let finalScope = workspaceDefaultScope;

    if (consumer.isLegacy) {
      const overrides = consumer.config.getComponentConfig(id);
      const componentDefaultScope = overrides ? overrides.defaultScope : null; // TODO: handle separation of owner from default scope on component
      // TODO: handle owner of component

      finalScope = componentDefaultScope || finalScope;

      if (workspaceDefaultScope && workspaceDefaultOwner && !componentDefaultScope) {
        finalScope = `${workspaceDefaultOwner}.${workspaceDefaultScope}`;
      }

      return id.changeScope(finalScope);
    }

    if (getDefaultScope && typeof getDefaultScope === 'function') {
      finalScope = await getDefaultScope(id);

      if (finalScope) {
        return id.changeScope(finalScope);
      }
    }

    return id;
  });
  const idsArray = await Promise.all(idsArrayP);
  return _bitId().BitIds.fromArray(idsArray);
}

async function getParsedId(consumer, id) {
  // reason why not calling `consumer.getParsedId()` first is because a component might not be on
  // .bitmap and only in the scope. we support this case and enable to export
  const parsedId = await consumer.scope.getParsedId(id);
  if (parsedId.hasScope()) return parsedId; // parsing id from the scope, doesn't provide the scope-name in case it's missing, in this case
  // get the id including the scope from the consumer.

  try {
    return consumer.getParsedId(id);
  } catch (err) {
    // not in the consumer, just return the one parsed without the scope name
    return parsedId;
  }
}

async function linkComponents(ids, consumer) {
  // we don't have much of a choice here, we have to load all the exported components in order to link them
  // some of the components might be authored, some might be imported.
  // when a component has dists, we need the consumer-component object to retrieve the dists info.
  const components = await Promise.all(ids.map(id => consumer.loadComponentFromModel(id)));
  const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
  await nodeModuleLinker.link();
}

async function ejectExportedComponents(componentsIds) {
  const consumer = await (0, _consumer().loadConsumer)(undefined, true);
  let ejectResults;

  try {
    const ejectComponents = new (_ejectComponents().default)(consumer, componentsIds);
    ejectResults = await ejectComponents.eject();
  } catch (err) {
    const ejectErr = `The components ${componentsIds.map(c => c.toString()).join(', ')} were exported successfully.
    However, the eject operation has failed due to an error: ${err.msg || err}`;

    _logger().default.error(ejectErr, err);

    throw new Error(ejectErr);
  } // run the consumer.onDestroy() again, to write the changes done by the eject action to .bitmap


  await consumer.onDestroy();
  return ejectResults;
}

async function reImportComponents(consumer, ids) {
  await (0, _pMapSeries().default)(ids, id => reImportComponent(consumer, id));
}

async function reImportComponent(consumer, id) {
  const componentWithDependencies = await consumer.loadComponentWithDependenciesFromModel(id);
  const componentMap = consumer.bitMap.getComponent(id);
  const rootDir = componentMap.rootDir;

  const shouldWritePackageJson = async () => {
    if (!rootDir) return false;
    const packageJsonPath = path().join(consumer.getPath(), rootDir, 'package.json');
    return _fsExtra().default.pathExists(packageJsonPath);
  };

  const shouldInstallNpmPackages = () => {
    return componentMap.origin !== _constants().COMPONENT_ORIGINS.AUTHORED;
  };

  const writePackageJson = await shouldWritePackageJson();
  const shouldDependenciesSaveAsComponents = await consumer.shouldDependenciesSavedAsComponents([id]);
  componentWithDependencies.component.dependenciesSavedAsComponents = shouldDependenciesSaveAsComponents[0].saveDependenciesAsComponents;
  const manyComponentsWriter = new (_manyComponentsWriter().default)({
    consumer,
    componentsWithDependencies: [componentWithDependencies],
    installNpmPackages: shouldInstallNpmPackages(),
    override: true,
    writePackageJson
  });
  await manyComponentsWriter.writeAll();
}
/**
 * remove the components with the old scope from package.json and from node_modules
 */


async function cleanOldComponents(consumer, updatedIds, componentsToExport) {
  // componentsToExport have the old scope, updatedIds have the new scope, only the old updatedIds
  //  need to be cleaned. that's why we search within componentsToExport for updatedIds
  const componentsToClean = componentsToExport.filter(c => updatedIds.hasWithoutScopeAndVersion(c.id));
  await packageJsonUtils().removeComponentsFromWorkspacesAndDependencies(consumer, componentsToClean);
}

async function _throwForModified(consumer, ids) {
  const statuses = await consumer.getManyComponentsStatuses(ids);
  statuses.forEach(({
    id,
    status
  }) => {
    if (status.modified) {
      throw new (_generalError().default)(`unable to perform rewire on "${id.toString()}" because it is modified, please tag or discard your changes before re-trying`);
    }
  });
}