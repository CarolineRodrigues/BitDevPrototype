"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _gitHook() {
  const data = _interopRequireDefault(require("./git-hook"));

  _gitHook = function () {
    return data;
  };

  return data;
}

function _bitImportGitHook() {
  const data = _interopRequireDefault(require("./fixtures/bit-import-git-hook"));

  _bitImportGitHook = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const HOOKS_DIR_NAME = 'hooks';
/*
 * Setting up block level variable to store class state
 * set's to null by default.
 */

let instance = null;
/**
 * A class which manage all the git hooks
 * This is a singleton class which expose getInstance method
 * This class used for add new git hooks
 */

class GitHooksManager {
  // path to the .git dir
  constructor(basePath) {
    (0, _defineProperty2().default)(this, "basePath", void 0);
    (0, _defineProperty2().default)(this, "hooks", new Map());
    this.basePath = basePath;

    if (!instance) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      instance = this;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return instance;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get hooksDirPath() {
    return path().join(this.basePath, HOOKS_DIR_NAME);
  }
  /**
   * Initialize the default hooks
   */


  static init(basePath) {
    const self = new GitHooksManager(basePath);

    _constants().GIT_HOOKS_NAMES.forEach(hookName => {
      const hook = new (_gitHook().default)(self.hooksDirPath, hookName, _bitImportGitHook().default);
      self.hooks.set(hookName, hook);
    });

    return self;
  }

  writeAllHooks() {
    const alreadyExist = [];
    const added = [];
    this.hooks.forEach((hook, hookName) => {
      const result = hook.writeSync();

      if (result) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        added.push(hookName);
      } else {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        alreadyExist.push(hookName);
      }
    });
    return {
      added,
      alreadyExist
    };
  }
  /**
   * Get the instance of the HooksManager
   * @return {GitHooksManager} instance of the GitHooksManager
   *
   */


  static getInstance() {
    return instance;
  }

}

exports.default = GitHooksManager;