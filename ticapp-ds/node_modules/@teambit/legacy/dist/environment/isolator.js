"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _isEmpty2() {
  const data = _interopRequireDefault(require("ramda/src/isEmpty"));

  _isEmpty2 = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _execa() {
  const data = _interopRequireDefault(require("execa"));

  _execa = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _loadFlattenedDependencies() {
  const data = require("../consumer/component-ops/load-flattened-dependencies");

  _loadFlattenedDependencies = function () {
    return data;
  };

  return data;
}

function _manipulateDir() {
  const data = require("../consumer/component-ops/manipulate-dir");

  _manipulateDir = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _componentSchema() {
  const data = require("../consumer/component/component-schema");

  _componentSchema = function () {
    return data;
  };

  return data;
}

function _packageJsonUtils() {
  const data = require("../consumer/component/package-json-utils");

  _packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _npmClient() {
  const data = _interopRequireDefault(require("../npm-client"));

  _npmClient = function () {
    return data;
  };

  return data;
}

function _componentsGraph() {
  const data = require("../scope/graph/components-graph");

  _componentsGraph = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _capsuleFactory() {
  const data = _interopRequireDefault(require("./capsule-factory"));

  _capsuleFactory = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Isolator {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // this is the same packageJson of the main component as it located on the root
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  constructor(capsule, scope, consumer, dir) {
    (0, _defineProperty2().default)(this, "capsule", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "capsuleBitMap", void 0);
    (0, _defineProperty2().default)(this, "capsulePackageJson", void 0);
    (0, _defineProperty2().default)(this, "componentWithDependencies", void 0);
    (0, _defineProperty2().default)(this, "manyComponentsWriter", void 0);
    (0, _defineProperty2().default)(this, "_npmVersionHasValidated", false);
    (0, _defineProperty2().default)(this, "componentRootDir", void 0);
    (0, _defineProperty2().default)(this, "dir", void 0);
    this.capsule = capsule;
    this.scope = scope;
    this.consumer = consumer;
    this.dir = dir;
  }

  static async getInstance(containerType = 'fs', scope, consumer, dir) {
    _logger().default.debug(`Isolator.getInstance, creating a capsule with an ${containerType} container, dir ${dir || 'N/A'}`);

    const capsule = await (0, _capsuleFactory().default)(containerType, dir);
    return new Isolator(capsule, scope, consumer, dir);
  }

  async isolate(componentId, opts) {
    var _this$consumer, _this$consumer2;

    const loaderPrefix = `isolating component - ${componentId.name}`;

    _loader().default.setText(loaderPrefix);

    const componentWithDependencies = await this._loadComponent(componentId);
    (0, _componentSchema().throwForNonLegacy)(componentWithDependencies.component.isLegacy, 'evn/Isolator.isolate');

    if (opts.shouldBuildDependencies) {
      (0, _componentsGraph().topologicalSortComponentDependencies)(componentWithDependencies);
      await (0, _pMapSeries().default)(componentWithDependencies.dependencies.reverse(), async dep => {
        if (!dep.dists || dep.dists.isEmpty()) {
          await dep.build({
            scope: this.scope,
            consumer: this.consumer
          });
          dep.dists.stripOriginallySharedDir(dep.originallySharedDir);
        } else {
          // needed for cases when a component is isolated as an individual first, then as a dependency.
          // because when it is isolated in the first time, the 'writeDistsFiles' is manually set to false
          dep.dists.writeDistsFiles = true;
        }
      });
    }

    const writeToPath = opts.writeToPath; // default should be true

    const installNpmPackages = typeof opts.installNpmPackages === 'undefined' ? true : opts.installNpmPackages;
    const concreteOpts = {
      componentsWithDependencies: [componentWithDependencies],
      writeToPath,
      override: opts.override,
      writePackageJson: opts.writePackageJson,
      writeConfig: opts.writeConfig,
      ignoreBitDependencies: !opts.writeBitDependencies,
      createNpmLinkFiles: opts.createNpmLinkFiles,
      saveDependenciesAsComponents: opts.saveDependenciesAsComponents !== false,
      writeDists: opts.writeDists,
      installNpmPackages,
      installPeerDependencies: !!opts.installPeerDependencies,
      // convert to boolean
      addToRootPackageJson: false,
      verbose: opts.verbose,
      excludeRegistryPrefix: !!opts.excludeRegistryPrefix,
      silentPackageManagerResult: opts.silentPackageManagerResult,
      isolated: true,
      isLegacy: (_this$consumer = this.consumer) === null || _this$consumer === void 0 ? void 0 : _this$consumer.isLegacy,
      applyPackageJsonTransformers: !((_this$consumer2 = this.consumer) !== null && _this$consumer2 !== void 0 && _this$consumer2.isLegacy)
    };
    this.componentWithDependencies = componentWithDependencies;
    this.manyComponentsWriter = new (_manyComponentsWriter().default)(concreteOpts);
    await this.writeComponentsAndDependencies({
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
    await this.installComponentPackages({
      installNpmPackages,
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
    await this.writeLinks({
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
    this.capsuleBitMap = this.manyComponentsWriter.bitMap;
    return componentWithDependencies;
  }

  async writeComponentsAndDependencies(opts = {
    keepExistingCapsule: false
  }) {
    _logger().default.debug('ManyComponentsWriter, writeAllToIsolatedCapsule');

    this._manipulateDir();

    await this.manyComponentsWriter._populateComponentsFilesToWrite();
    await this.manyComponentsWriter._populateComponentsDependenciesToWrite();
    await this._persistComponentsDataToCapsule({
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
  }

  async installComponentPackages(opts = {
    installNpmPackages: true,
    keepExistingCapsule: false
  }) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    this.capsulePackageJson = this.componentWithDependencies.component.packageJsonFile; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.componentRootDir = this.componentWithDependencies.component.writtenPath;
    await this._addComponentsToRoot({
      keepExistingCapsule: !!opts.keepExistingCapsule
    });

    _logger().default.debug('ManyComponentsWriter, install packages on capsule');

    if (opts.installNpmPackages) {
      await this._installWithPeerOption();
    }
  }

  async writeLinks(opts = {
    keepExistingCapsule: false
  }) {
    const links = await this.manyComponentsWriter._getAllLinks(); // links is a DataToPersist instance

    await links.persistAllToCapsule(this.capsule, {
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
  }
  /**
   * used by compilers that create capsule.
   * when installing packages on the capsule, the links generated on node_modules may be deleted
   */


  async writeLinksOnNodeModules() {
    const links = await this.manyComponentsWriter._getAllLinks();
    const nodeModulesLinks = links.filterByPath(filePath => filePath.startsWith('node_modules'));
    await nodeModulesLinks.persistAllToCapsule(this.capsule);
  }

  _manipulateDir() {
    const allComponents = [this.componentWithDependencies.component, ...this.componentWithDependencies.allDependencies];
    const manipulateDirData = (0, _manipulateDir().getManipulateDirForComponentWithDependencies)(this.componentWithDependencies);
    allComponents.forEach(component => {
      component.stripOriginallySharedDir(manipulateDirData);
    });
  }
  /**
   * To write a component into an isolated environment, we need not only its dependencies, but
   * also the dependencies of its dependencies and so on.
   * When loading a component from the model, it's easy to get them all from the
   * flattenedDependencies. However, when loading from the consumer, we have only the dependencies
   * loaded, not the flattened. To get the flattened, we have to load the dependencies and each one
   * of the dependency we need to load its dependencies as well until we got them all.
   * Also, we have to clone each component we load, because when writing them into the capsule, we
   * strip their shared-dir and we don't want these changed paths to affect the workspace
   */


  async _loadComponent(id) {
    if (this.consumer) {
      return this._loadComponentFromConsumer(id);
    }

    throw new Error('loading components from scope is not implemented yet');
  }

  async _loadComponentFromConsumer(id) {
    const consumer = this.consumer;
    if (!consumer) throw new Error('missing consumer');
    const component = await consumer.loadComponentForCapsule(id);
    const flattenedDependencyLoader = new (_loadFlattenedDependencies().FlattenedDependencyLoader)(consumer);
    return flattenedDependencyLoader.load(component);
  }

  async _persistComponentsDataToCapsule(opts = {
    keepExistingCapsule: false
  }) {
    const dataToPersist = new (_dataToPersist().default)();
    const allComponents = [this.componentWithDependencies.component, ...this.componentWithDependencies.allDependencies];
    allComponents.forEach(component => dataToPersist.merge(component.dataToPersist));
    await dataToPersist.persistAllToCapsule(this.capsule, {
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
  } // amit - here we need to add a map of all the capsules so we can link the components


  async _addComponentsToRoot(opts = {
    keepExistingCapsule: false
  }) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const capsulePath = this.capsule.container.getPath(); // the capsulePath hack only works for the fs-capsule
    // for other capsule types, we would need to do this
    // (and other things) inside the capsule itself
    // rather than fetching its folder and using it

    const rootPathInCapsule = path().join(capsulePath, this.componentRootDir);
    const componentsToAdd = this.componentWithDependencies.allDependencies.reduce((acc, component) => {
      // $FlowFixMe - writtenPath is defined
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const componentPathInCapsule = path().join(capsulePath, component.writtenPath);
      const relativeDepLocation = path().relative(rootPathInCapsule, componentPathInCapsule);
      const locationAsUnixFormat = (0, _packageJsonUtils().convertToValidPathForPackageManager)(relativeDepLocation);
      const packageName = (0, _componentIdToPackageName().default)(component);
      acc[packageName] = locationAsUnixFormat;
      return acc;
    }, {});
    if ((0, _isEmpty2().default)(componentsToAdd)) return;
    this.capsulePackageJson.addDependencies(componentsToAdd);
    await this._writeCapsulePackageJson({
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
  }

  async _writeCapsulePackageJson(opts = {
    keepExistingCapsule: false
  }) {
    const dataToPersist = new (_dataToPersist().default)();
    dataToPersist.addFile(this.capsulePackageJson.toVinylFile());
    return dataToPersist.persistAllToCapsule(this.capsule, {
      keepExistingCapsule: !!opts.keepExistingCapsule
    });
  }

  async _getNpmVersion() {
    const {
      stdout: versionString
    } = await this.capsuleExecUsingExeca('npm', ['--version']);

    const validVersion = _semver().default.coerce(versionString);

    return validVersion ? validVersion.raw : null;
  }

  async installPackagesOnRoot(modules = []) {
    await this._throwForOldNpmVersion();
    const args = ['install', ...modules, '--no-save'];
    return this.capsuleExecUsingExeca('npm', args, this.componentRootDir);
  }

  async _throwForOldNpmVersion() {
    if (this._npmVersionHasValidated) {
      return;
    }

    const npmVersion = await this._getNpmVersion();

    if (!npmVersion) {
      throw new Error('Failed to isolate component: unable to run npm');
    }

    if (!_semver().default.satisfies(npmVersion, _constants().ACCEPTABLE_NPM_VERSIONS)) {
      throw new (_generalError().default)(`Failed to isolate component: found an old version of npm (${npmVersion}). ` + `To get rid of this error, please upgrade to npm ${_constants().ACCEPTABLE_NPM_VERSIONS}`);
    }

    this._npmVersionHasValidated = true;
  }

  async capsuleExecUsingExeca(pkgManager, args, dir = '') {
    // @ts-ignore fs-container has path.
    const capsuleDir = this.capsule.container.path;
    const cwd = path().join(capsuleDir, dir);
    return (0, _execa().default)(pkgManager, args, {
      cwd
    });
  }

  async capsuleExec(cmd, options) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const execResults = await this.capsule.exec({
      command: cmd.split(' '),
      options
    });
    let stdout = '';
    let stderr = '';
    return new Promise((resolve, reject) => {
      execResults.stdout.on('data', data => {
        stdout += data;
      });
      execResults.stdout.on('error', error => {
        return reject(error);
      }); // @ts-ignore

      execResults.on('close', () => {
        return resolve({
          stdout,
          stderr
        });
      });
      execResults.stderr.on('error', error => {
        return reject(error);
      });
      execResults.stderr.on('data', data => {
        stderr += data;
      });
    });
  }
  /**
   * it must be done in this order. first, `npm install`, then, `npm list -j` shows the missing
   * peer dependencies, then, add these peerDependencies into devDependencies and run `npm install`
   * again. The reason for adding the missing peer into devDependencies is to not get them deleted
   * once `npm install` is running along the road.
   */


  async _installWithPeerOption(installPeerDependencies = true) {
    await this.installPackagesOnRoot();

    if (installPeerDependencies) {
      const peers = await this._getPeerDependencies();

      if (!(0, _isEmpty2().default)(peers)) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        this.capsulePackageJson.packageJsonObject.devDependencies = Object.assign( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        this.capsulePackageJson.packageJsonObject.devDependencies || {}, peers);
        await this._writeCapsulePackageJson();
        await this.installPackagesOnRoot();
      }
    }
  }

  async _getPeerDependencies() {
    const packageManager = 'npm';
    let npmList;

    try {
      npmList = await this._getNpmListOutput(packageManager);
    } catch (err) {
      _logger().default.error(`failed running "${packageManager} list -j"`, err);

      throw new Error(`failed running "${packageManager} list -j" to find the peer dependencies due to an error: ${err}`);
    }

    return _npmClient().default.getPeerDepsFromNpmList(npmList, packageManager);
  }

  async _getNpmListOutput(packageManager) {
    const args = ['list', '-j'];

    try {
      const {
        stdout,
        stderr
      } = await this.capsuleExecUsingExeca(packageManager, args, this.componentRootDir);
      if (stderr && stderr.startsWith('{')) return stderr;
      return stdout;
    } catch (err) {
      if (err.stdout && err.stdout.startsWith('{')) {
        // it's probably a valid json with errors, that's fine, parse it.
        return err.stdout;
      }

      _logger().default.error('npm-client got an error', err);

      throw new Error(`failed running ${err.cmd} to find the peer dependencies due to an error: ${err.message}`);
    }
  }

}

exports.default = Isolator;