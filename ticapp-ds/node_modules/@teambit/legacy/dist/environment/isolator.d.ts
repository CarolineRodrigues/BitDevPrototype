import Capsule from '../../legacy-capsule/core/capsule';
import { BitId } from '../bit-id';
import BitMap from '../consumer/bit-map';
import ManyComponentsWriter from '../consumer/component-ops/many-components-writer';
import PackageJsonFile from '../consumer/component/package-json-file';
import Consumer from '../consumer/consumer';
import { PackageManagerResults } from '../npm-client/npm-client';
import { ComponentWithDependencies, Scope } from '../scope';
import { PathOsBased } from '../utils/path';
export interface IsolateOptions {
    writeToPath?: PathOsBased;
    override?: boolean;
    writePackageJson?: boolean;
    writeConfig?: boolean;
    writeBitDependencies?: boolean;
    createNpmLinkFiles?: boolean;
    saveDependenciesAsComponents?: boolean;
    writeDists?: boolean;
    shouldBuildDependencies?: boolean;
    installNpmPackages?: boolean;
    keepExistingCapsule?: boolean;
    installPeerDependencies?: boolean;
    installProdPackagesOnly?: boolean;
    verbose?: boolean;
    excludeRegistryPrefix?: boolean;
    silentPackageManagerResult?: boolean;
}
export default class Isolator {
    capsule: Capsule;
    consumer?: Consumer;
    scope: Scope;
    capsuleBitMap: BitMap;
    capsulePackageJson: PackageJsonFile;
    componentWithDependencies: ComponentWithDependencies;
    manyComponentsWriter: ManyComponentsWriter;
    _npmVersionHasValidated: boolean;
    componentRootDir: string;
    dir?: string;
    constructor(capsule: Capsule, scope: Scope, consumer?: Consumer, dir?: string);
    static getInstance(containerType: string | undefined, scope: Scope, consumer?: Consumer, dir?: string): Promise<Isolator>;
    isolate(componentId: BitId, opts: IsolateOptions): Promise<ComponentWithDependencies>;
    writeComponentsAndDependencies(opts?: {
        keepExistingCapsule: boolean;
    }): Promise<void>;
    installComponentPackages(opts?: {
        installNpmPackages: boolean;
        keepExistingCapsule: boolean;
    }): Promise<void>;
    writeLinks(opts?: {
        keepExistingCapsule: boolean;
    }): Promise<void>;
    /**
     * used by compilers that create capsule.
     * when installing packages on the capsule, the links generated on node_modules may be deleted
     */
    writeLinksOnNodeModules(): Promise<void>;
    _manipulateDir(): void;
    /**
     * To write a component into an isolated environment, we need not only its dependencies, but
     * also the dependencies of its dependencies and so on.
     * When loading a component from the model, it's easy to get them all from the
     * flattenedDependencies. However, when loading from the consumer, we have only the dependencies
     * loaded, not the flattened. To get the flattened, we have to load the dependencies and each one
     * of the dependency we need to load its dependencies as well until we got them all.
     * Also, we have to clone each component we load, because when writing them into the capsule, we
     * strip their shared-dir and we don't want these changed paths to affect the workspace
     */
    _loadComponent(id: BitId): Promise<ComponentWithDependencies>;
    _loadComponentFromConsumer(id: BitId): Promise<ComponentWithDependencies>;
    _persistComponentsDataToCapsule(opts?: {
        keepExistingCapsule: boolean;
    }): Promise<void>;
    _addComponentsToRoot(opts?: {
        keepExistingCapsule: boolean;
    }): Promise<void>;
    _writeCapsulePackageJson(opts?: {
        keepExistingCapsule: boolean;
    }): Promise<void>;
    _getNpmVersion(): Promise<string | null>;
    installPackagesOnRoot(modules?: string[]): Promise<PackageManagerResults>;
    _throwForOldNpmVersion(): Promise<void>;
    capsuleExecUsingExeca(pkgManager: string, args: string[], dir?: string): Promise<PackageManagerResults>;
    capsuleExec(cmd: string, options?: Record<string, any> | null | undefined): Promise<PackageManagerResults>;
    /**
     * it must be done in this order. first, `npm install`, then, `npm list -j` shows the missing
     * peer dependencies, then, add these peerDependencies into devDependencies and run `npm install`
     * again. The reason for adding the missing peer into devDependencies is to not get them deleted
     * once `npm install` is running along the road.
     */
    _installWithPeerOption(installPeerDependencies?: boolean): Promise<void>;
    _getPeerDependencies(): Promise<Record<string, any>>;
    _getNpmListOutput(packageManager: string): Promise<string>;
}
