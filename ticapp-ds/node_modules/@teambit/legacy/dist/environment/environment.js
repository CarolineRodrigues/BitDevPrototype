"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _uuid() {
  const data = _interopRequireDefault(require("uuid"));

  _uuid = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ENV_IS_INSTALLED_FILENAME = '.bit_env_has_installed';

class Environment {
  constructor(scope, dir) {
    (0, _defineProperty2().default)(this, "path", void 0);
    (0, _defineProperty2().default)(this, "scope", void 0);
    (0, _defineProperty2().default)(this, "consumer", void 0);
    this.scope = scope;
    this.path = dir || path().join(scope.getPath(), _constants().ISOLATED_ENV_ROOT, (0, _uuid().default)());

    _logger().default.debug(`creating a new isolated environment at ${this.path}`);
  }

  async create() {
    await _fsExtra().default.ensureDir(this.path);
    this.consumer = await _consumer().Consumer.createIsolatedWithExistingScope(this.path, this.scope);
  }
  /**
   * import a component end to end. Including importing the dependencies and installing the npm
   * packages.
   *
   * @param {BitId | string} bitId - the component id to isolate
   * @param {IsolateOptions} opts
   * @return {Promise.<Component>}
   */


  async isolateComponent(bitId, opts) {
    // add this if statement due to extensions calling this api directly with bitId as string with version
    if (typeof bitId === 'string') {
      bitId = _bitId().BitId.parse(bitId, true);
    }

    const saveDependenciesAsComponents = opts.saveDependenciesAsComponents === undefined ? true : opts.saveDependenciesAsComponents;

    if (!this.consumer) {
      throw new Error('trying to import component without define consumer');
    }

    const componentsWithDependencies = await this.consumer.importComponentsLegacy(_bitId().BitIds.fromArray([bitId]), false, saveDependenciesAsComponents);
    const componentWithDependencies = componentsWithDependencies[0];
    const writeToPath = opts.writeToPath || this.path;
    const concreteOpts = {
      consumer: this.consumer,
      componentsWithDependencies,
      writeToPath,
      override: opts.override,
      writePackageJson: opts.writePackageJson,
      writeConfig: opts.writeConfig,
      ignoreBitDependencies: !opts.writeBitDependencies,
      createNpmLinkFiles: opts.createNpmLinkFiles,
      writeDists: opts.writeDists,
      saveDependenciesAsComponents: opts.saveDependenciesAsComponents !== false,
      installNpmPackages: !!opts.installNpmPackages,
      // convert to boolean
      installPeerDependencies: !!opts.installPeerDependencies,
      // convert to boolean
      addToRootPackageJson: false,
      installProdPackagesOnly: opts.installProdPackagesOnly,
      verbose: opts.verbose,
      excludeRegistryPrefix: !!opts.excludeRegistryPrefix,
      silentPackageManagerResult: opts.silentPackageManagerResult
    };
    const manyComponentsWriter = new (_manyComponentsWriter().default)(concreteOpts);
    await manyComponentsWriter.writeAll();
    await Environment.markEnvironmentAsInstalled(writeToPath);
    return componentWithDependencies;
  }
  /**
   * It helps to make sure an environment is installed. Otherwise, in case a user interrupts the environment
   * installation process, it won't be installed again.
   */


  static markEnvironmentAsInstalled(dir) {
    const filePath = path().join(dir, ENV_IS_INSTALLED_FILENAME);
    return (0, _utils().outputFile)({
      filePath,
      content: ''
    });
  }

  static isEnvironmentInstalled(dir) {
    const filePath = path().join(dir, ENV_IS_INSTALLED_FILENAME);
    return _fsExtra().default.existsSync(filePath);
  }

  getPath() {
    return this.path;
  }

  destroy() {
    _logger().default.debug(`destroying the isolated environment at ${this.path}`);

    _logger().default.info(`environment, deleting ${this.path}`);

    return _fsExtra().default.remove(this.path);
  }

  async destroyIfExist() {
    const isExist = await _fsExtra().default.pathExists(this.path);

    if (isExist) {
      _logger().default.debug(`destroying existing environment in path ${this.path}`);

      return this.destroy();
    }

    return false;
  }

}

exports.default = Environment;