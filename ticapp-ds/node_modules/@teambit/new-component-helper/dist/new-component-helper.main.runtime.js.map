{"version":3,"sources":["new-component-helper.main.runtime.ts"],"names":["NewComponentHelperMain","constructor","workspace","harmony","getNewComponentId","name","namespace","scope","defaultScope","InvalidScopeName","BitError","fullComponentName","ComponentID","fromObject","getNewComponentPath","componentId","pathFromUser","_legacy","changeScope","defaultDirectory","writeAndAddNewComp","comp","targetId","options","config","targetPath","path","throwForExistingPath","write","track","rootDir","componentName","fullName","mainFile","state","_consumer","err","fs","remove","bitMap","clearCache","triggerOnComponentAdd","stat","isDirectory","isEmpty","code","getConfigFromExistingToNewComponent","aspectIds","aspects","entries","map","e","id","toString","loadAspects","fromExisting","forEach","entry","aspectId","aspect","get","Error","shouldPreserveConfigForClonedComponent","provider","_","WorkspaceAspect","MainRuntime","NewComponentHelperAspect","addRuntime"],"mappings":"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","sourcesContent":["import fs from 'fs-extra';\nimport { BitError } from '@teambit/bit-error';\nimport { InvalidScopeName, isValidScopeName } from '@teambit/legacy-bit-id';\nimport { MainRuntime } from '@teambit/cli';\nimport { composeComponentPath } from '@teambit/legacy/dist/utils/bit/compose-component-path';\nimport { Component } from '@teambit/component';\nimport { isDirEmpty } from '@teambit/legacy/dist/utils';\nimport { ComponentID } from '@teambit/component-id';\nimport { Harmony } from '@teambit/harmony';\nimport { PathLinuxRelative } from '@teambit/legacy/dist/utils/path';\nimport WorkspaceAspect, { Workspace } from '@teambit/workspace';\nimport { NewComponentHelperAspect } from './new-component-helper.aspect';\n\nexport class NewComponentHelperMain {\n  constructor(private workspace: Workspace, private harmony: Harmony) {}\n  /**\n   * when creating/forking a component, the user provides the new name and optionally the scope/namespace.\n   * from this user input, create a ComponentID.\n   */\n  getNewComponentId(name: string, namespace?: string, scope?: string): ComponentID {\n    scope = scope || this.workspace.defaultScope;\n    if (!isValidScopeName(scope)) {\n      throw new InvalidScopeName(scope);\n    }\n    if (!scope) throw new BitError(`failed finding defaultScope`);\n\n    const fullComponentName = namespace ? `${namespace}/${name}` : name;\n    return ComponentID.fromObject({ name: fullComponentName }, scope);\n  }\n\n  /**\n   * when creating/forking a component, the user may or may not provide a path.\n   * if not provided, generate the path based on the component-id.\n   * the component will be written to that path.\n   */\n  getNewComponentPath(componentId: ComponentID, pathFromUser?: string): PathLinuxRelative {\n    if (pathFromUser) return pathFromUser;\n    return composeComponentPath(componentId._legacy.changeScope(componentId.scope), this.workspace.defaultDirectory);\n  }\n\n  async writeAndAddNewComp(\n    comp: Component,\n    targetId: ComponentID,\n    options?: { path?: string; scope?: string },\n    config?: { [aspectName: string]: any }\n  ) {\n    const targetPath = this.getNewComponentPath(targetId, options?.path);\n    await this.throwForExistingPath(targetPath);\n    await this.workspace.write(targetPath, comp);\n    try {\n      await this.workspace.track({\n        rootDir: targetPath,\n        componentName: targetId.fullName,\n        mainFile: comp.state._consumer.mainFile,\n        defaultScope: options?.scope,\n        config,\n      });\n    } catch (err) {\n      await fs.remove(targetPath);\n      throw err;\n    }\n\n    await this.workspace.bitMap.write();\n    this.workspace.clearCache();\n    // this takes care of compiling the component as well\n    await this.workspace.triggerOnComponentAdd(targetId);\n  }\n\n  private async throwForExistingPath(targetPath: string) {\n    try {\n      const stat = await fs.stat(targetPath);\n      if (!stat.isDirectory()) {\n        throw new BitError(`unable to create component at \"${targetPath}\", this path already exists`);\n      }\n      const isEmpty = await isDirEmpty(targetPath);\n      if (!isEmpty) {\n        throw new BitError(`unable to create component at \"${targetPath}\", this directory is not empty`);\n      }\n    } catch (err: any) {\n      if (err.code === 'ENOENT') {\n        return;\n      }\n      throw err;\n    }\n  }\n\n  async getConfigFromExistingToNewComponent(comp: Component) {\n    const aspectIds = comp.state.aspects.entries.map((e) => e.id.toString());\n    await this.workspace.loadAspects(aspectIds);\n    const fromExisting = {};\n    comp.state.aspects.entries.forEach((entry) => {\n      if (!entry.config) return;\n      const aspectId = entry.id.toString();\n      const aspect = this.harmony.get<CloneConfig>(aspectId);\n      if (!aspect) throw new Error(`error: unable to get \"${aspectId}\" aspect from Harmony`);\n      if (\n        'shouldPreserveConfigForClonedComponent' in aspect &&\n        aspect.shouldPreserveConfigForClonedComponent === false\n      ) {\n        return;\n      }\n      fromExisting[aspectId] = entry.config;\n    });\n    return fromExisting;\n  }\n\n  static slots = [];\n  static dependencies = [WorkspaceAspect];\n  static runtime = MainRuntime;\n  static async provider([workspace]: [Workspace], config, _, harmony: Harmony) {\n    return new NewComponentHelperMain(workspace, harmony);\n  }\n}\n\nNewComponentHelperAspect.addRuntime(NewComponentHelperMain);\n\nexport interface CloneConfig {\n  readonly shouldPreserveConfigForClonedComponent?: boolean; // default true\n}\n"]}