"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportCmd = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("@teambit/legacy/dist/api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _ejectTemplate() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/templates/eject-template"));

  _ejectTemplate = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

class ExportCmd {
  constructor(docsDomain) {
    this.docsDomain = docsDomain;
    (0, _defineProperty2().default)(this, "name", 'export [remote] [id...]');
    (0, _defineProperty2().default)(this, "description", void 0);
    (0, _defineProperty2().default)(this, "alias", 'e');
    (0, _defineProperty2().default)(this, "options", [['e', 'eject', 'replaces the exported components from the local scope with the corresponding packages'], ['a', 'all', 'export all components include non-staged'], ['d', 'include-dependencies', "LEGACY ONLY. include the component's dependencies as part of the export to the remote scope"], ['s', 'set-current-scope', "LEGACY ONLY. ensure the component's remote scope is set according to the target location"], ['r', 'rewire', 'LEGACY ONLY. when exporting to a different or new scope, replace import/require statements in the source code to match the new scope'], ['f', 'force', 'force changing a component remote without asking for a confirmation'], ['', 'all-versions', 'export not only staged versions but all of them'], ['', 'origin-directly', 'HARMONY ONLY. avoid export to the central hub, instead, export directly to the original scopes. not recommended!'], ['', 'resume <string>', 'in case the previous export failed and suggested to resume with an export-id, enter the id'], ['', 'ignore-missing-artifacts', "EXPERIMENTAL. don't throw an error when artifact files are missing. not recommended, unless you're sure the artifacts are in the remote"]]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "group", 'collaborate');
    (0, _defineProperty2().default)(this, "shortDescription", 'Export components to a remote scope');
    (0, _defineProperty2().default)(this, "remoteOp", true);
    this.description = `export components to a remote scope.
bit export => export all staged components to their current scope, if checked out to a lane, export the lane as well
\`bit export [id...]\` => export the given ids to their current scope

https://${docsDomain}/components/exporting-components
${(0, _constants().WILDCARD_HELP)('export remote-scope')}`;
  }

  async report([remote, ids = []], {
    eject = false,
    includeDependencies = false,
    setCurrentScope = false,
    all = false,
    allVersions = false,
    originDirectly = false,
    force = false,
    rewire = false,
    ignoreMissingArtifacts = false,
    resume
  }) {
    const currentScope = !remote || remote === _constants().CURRENT_UPSTREAM;

    if (currentScope && remote) {
      remote = '';
    }

    if (includeDependencies && !remote) {
      throw new (_generalError().default)('to use --includeDependencies, please specify a remote (the default remote gets already the dependencies)');
    }

    const {
      componentsIds,
      nonExistOnBitMap,
      missingScope,
      exportedLanes,
      ejectResults
    } = await (0, _consumer().exportAction)({
      ids,
      remote,
      eject,
      includeDependencies,
      setCurrentScope,
      includeNonStaged: all || allVersions,
      allVersions: allVersions || all,
      originDirectly,
      codemod: rewire,
      force,
      resumeExportId: resume,
      ignoreMissingArtifacts
    });

    if ((0, _lodash().isEmpty)(componentsIds) && (0, _lodash().isEmpty)(nonExistOnBitMap) && (0, _lodash().isEmpty)(missingScope)) {
      return _chalk().default.yellow('nothing to export');
    }

    const exportOutput = () => {
      if ((0, _lodash().isEmpty)(componentsIds)) return '';
      const lanesOutput = exportedLanes.length ? ` from lane ${_chalk().default.bold(exportedLanes[0].name)}` : '';
      if (remote) return _chalk().default.green(`exported ${componentsIds.length} components${lanesOutput} to scope ${_chalk().default.bold(remote)}`);
      return _chalk().default.green(`exported the following ${componentsIds.length} component(s)${lanesOutput}:\n${_chalk().default.bold(componentsIds.join('\n'))}`);
    };

    const nonExistOnBitMapOutput = () => {
      // if includeDependencies is true, the nonExistOnBitMap might be the dependencies
      if ((0, _lodash().isEmpty)(nonExistOnBitMap) || includeDependencies) return '';
      const idsStr = nonExistOnBitMap.map(id => id.toString()).join(', ');
      return _chalk().default.yellow(`${idsStr}\nexported successfully. bit did not update the workspace as the component files are not tracked. this might happen when a component was tracked in a different git branch. to fix it check if they where tracked in a different git branch, checkout to that branch and resync by running 'bit import'. or stay on your branch and track the components again using 'bit add'.\n`);
    };

    const missingScopeOutput = () => {
      if ((0, _lodash().isEmpty)(missingScope)) return '';
      const idsStr = missingScope.map(id => id.toString()).join(', ');
      return _chalk().default.yellow(`the following component(s) were not exported: ${_chalk().default.bold(idsStr)}.\nplease specify <remote> to export them, or set a "defaultScope" in your workspace config\n\n`);
    };

    const ejectOutput = () => {
      if (!ejectResults) return '';
      const output = (0, _ejectTemplate().default)(ejectResults);
      return `\n${output}`;
    };

    return nonExistOnBitMapOutput() + missingScopeOutput() + exportOutput() + ejectOutput();
  }

}

exports.ExportCmd = ExportCmd;

//# sourceMappingURL=export-cmd.js.map