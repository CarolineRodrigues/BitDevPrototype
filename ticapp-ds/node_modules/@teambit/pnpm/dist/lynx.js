"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPeerDependencyIssues = getPeerDependencyIssues;
exports.install = install;
exports.resolveRemoteVersion = resolveRemoteVersion;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _parsePackageName() {
  const data = _interopRequireDefault(require("parse-package-name"));

  _parsePackageName = function () {
    return data;
  };

  return data;
}

function _defaultReporter() {
  const data = _interopRequireDefault(require("@pnpm/default-reporter"));

  _defaultReporter = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@pnpm/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _storeConnectionManager() {
  const data = require("@pnpm/store-connection-manager");

  _storeConnectionManager = function () {
    return data;
  };

  return data;
}

function _sortPackages() {
  const data = _interopRequireDefault(require("@pnpm/sort-packages"));

  _sortPackages = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function pnpm() {
  const data = _interopRequireWildcard(require("@pnpm/core"));

  pnpm = function () {
    return data;
  };

  return data;
}

function _client() {
  const data = _interopRequireDefault(require("@pnpm/client"));

  _client = function () {
    return data;
  };

  return data;
}

function _pickRegistryForPackage() {
  const data = _interopRequireDefault(require("@pnpm/pick-registry-for-package"));

  _pickRegistryForPackage = function () {
    return data;
  };

  return data;
}

function _nerfDart() {
  const data = _interopRequireDefault(require("nerf-dart"));

  _nerfDart = function () {
    return data;
  };

  return data;
}

function _pkgsGraph() {
  const data = _interopRequireDefault(require("pkgs-graph"));

  _pkgsGraph = function () {
    return data;
  };

  return data;
}

function _readConfig() {
  const data = require("./read-config");

  _readConfig = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

const STORE_CACHE = {};

async function createStoreController(options) {
  var _options$proxyConfig, _options$proxyConfig2, _options$proxyConfig3, _options$proxyConfig4, _options$proxyConfig5, _options$networkConfi, _options$proxyConfig6;

  const authConfig = getAuthConfig(options.registries);
  const opts = {
    dir: options.rootDir,
    cacheDir: options.cacheDir,
    storeDir: options.storeDir,
    rawConfig: authConfig,
    verifyStoreIntegrity: true,
    httpProxy: (_options$proxyConfig = options.proxyConfig) === null || _options$proxyConfig === void 0 ? void 0 : _options$proxyConfig.httpProxy,
    httpsProxy: (_options$proxyConfig2 = options.proxyConfig) === null || _options$proxyConfig2 === void 0 ? void 0 : _options$proxyConfig2.httpsProxy,
    ca: (_options$proxyConfig3 = options.proxyConfig) === null || _options$proxyConfig3 === void 0 ? void 0 : _options$proxyConfig3.ca,
    cert: (_options$proxyConfig4 = options.proxyConfig) === null || _options$proxyConfig4 === void 0 ? void 0 : _options$proxyConfig4.cert,
    key: (_options$proxyConfig5 = options.proxyConfig) === null || _options$proxyConfig5 === void 0 ? void 0 : _options$proxyConfig5.key,
    localAddress: (_options$networkConfi = options.networkConfig) === null || _options$networkConfi === void 0 ? void 0 : _options$networkConfi.localAddress,
    noProxy: (_options$proxyConfig6 = options.proxyConfig) === null || _options$proxyConfig6 === void 0 ? void 0 : _options$proxyConfig6.noProxy,
    strictSsl: options.proxyConfig.strictSSL,
    maxSockets: options.networkConfig.maxSockets,
    networkConcurrency: options.networkConfig.networkConcurrency,
    packageImportMethod: options.packageImportMethod
  }; // We should avoid the recreation of store.
  // The store holds cache that makes subsequent resolutions faster.

  const cacheKey = JSON.stringify(opts);

  if (!STORE_CACHE[cacheKey]) {
    // Although it would be enough to call createNewStoreController(),
    // that doesn't resolve the store directory location.
    STORE_CACHE[cacheKey] = await (0, _storeConnectionManager().createOrConnectStoreController)(opts);
  }

  return STORE_CACHE[cacheKey];
}

async function generateResolverAndFetcher(cacheDir, registries, proxyConfig = {}, networkConfig = {}) {
  const pnpmConfig = await (0, _readConfig().readConfig)();
  const authConfig = getAuthConfig(registries);
  const opts = {
    authConfig: Object.assign({}, pnpmConfig.config.rawConfig, authConfig),
    cacheDir,
    httpProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpProxy,
    httpsProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.httpsProxy,
    ca: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.ca,
    cert: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.cert,
    key: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.key,
    localAddress: networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.localAddress,
    noProxy: proxyConfig === null || proxyConfig === void 0 ? void 0 : proxyConfig.noProxy,
    strictSsl: proxyConfig.strictSSL,
    timeout: networkConfig.fetchTimeout,
    retry: {
      factor: networkConfig.fetchRetryFactor,
      maxTimeout: networkConfig.fetchRetryMaxtimeout,
      minTimeout: networkConfig.fetchRetryMintimeout,
      retries: networkConfig.fetchRetries
    }
  };
  const result = (0, _client().default)(opts);
  return result;
}

async function getPeerDependencyIssues(rootManifest, manifestsByPaths, opts) {
  const projects = [];
  const workspacePackages = {};

  for (const [rootDir, manifest] of Object.entries(manifestsByPaths)) {
    projects.push({
      manifest,
      rootDir
    });
    workspacePackages[manifest.name] = workspacePackages[manifest.name] || {};
    workspacePackages[manifest.name][manifest.version] = {
      dir: rootDir,
      manifest
    };
  }

  projects.push({
    manifest: rootManifest.manifest,
    rootDir: rootManifest.rootDir
  });
  const registriesMap = getRegistriesMap(opts.registries);
  const storeController = await createStoreController(_objectSpread(_objectSpread({}, opts), {}, {
    rootDir: rootManifest.rootDir
  }));
  return pnpm().getPeerDependencyIssues(projects, {
    storeController: storeController.ctrl,
    storeDir: storeController.dir,
    overrides: opts.overrides,
    workspacePackages,
    registries: registriesMap
  });
}

async function install(rootManifest, manifestsByPaths, storeDir, cacheDir, registries, proxyConfig = {}, networkConfig = {}, options, // eslint-disable-next-line @typescript-eslint/no-unused-vars
logger) {
  const {
    packagesToBuild,
    workspacePackages
  } = groupPkgs(_objectSpread(_objectSpread({}, manifestsByPaths), {}, {
    [rootManifest.rootDir]: rootManifest.manifest
  }));
  const registriesMap = getRegistriesMap(registries);
  const authConfig = getAuthConfig(registries);
  const storeController = await createStoreController({
    rootDir: rootManifest.rootDir,
    storeDir,
    cacheDir,
    registries,
    proxyConfig,
    networkConfig,
    packageImportMethod: options === null || options === void 0 ? void 0 : options.packageImportMethod
  });

  const opts = _objectSpread({
    storeDir: storeController.dir,
    dir: rootManifest.rootDir,
    extendNodePath: false,
    storeController: storeController.ctrl,
    workspacePackages,
    preferFrozenLockfile: true,
    pruneLockfileImporters: true,
    registries: registriesMap,
    rawConfig: authConfig
  }, options);

  const stopReporting = (0, _defaultReporter().default)({
    context: {
      argv: []
    },
    reportingOptions: {
      appendOnly: false,
      throttleProgress: 200
    },
    streamParser: _logger().streamParser
  });

  try {
    await (0, pnpm().mutateModules)(packagesToBuild, opts);
  } finally {
    stopReporting();
  }
}

function groupPkgs(manifestsByPaths) {
  const pkgs = Object.entries(manifestsByPaths).map(([dir, manifest]) => ({
    dir,
    manifest
  }));
  const {
    graph
  } = (0, _pkgsGraph().default)(pkgs);
  const chunks = (0, _sortPackages().default)(graph); // This will create local link by pnpm to a component exists in the ws.
  // it will later deleted by the link process
  // we keep it here to better support case like this:
  // compA@1.0.0 uses compB@1.0.0
  // I have compB@2.0.0 in my workspace
  // now I install compA@1.0.0
  // compA is hoisted to the root and install B@1.0.0 hoisted to the root as well
  // now we will make link to B@2.0.0 and A will break
  // with this we will have a link to the local B by pnpm so it will install B@1.0.0 inside A
  // then when overriding the link, A will still works
  // This is the rational behind not deleting this completely, but need further check that it really works

  const packagesToBuild = []; // @pnpm/core will use this to install the packages

  const workspacePackages = {}; // @pnpm/core will use this to link packages to each other

  chunks.forEach((dirs, buildIndex) => {
    for (const rootDir of dirs) {
      const manifest = manifestsByPaths[rootDir];
      packagesToBuild.push({
        buildIndex,
        manifest,
        rootDir,
        mutation: 'install'
      });

      if (manifest.name) {
        workspacePackages[manifest.name] = workspacePackages[manifest.name] || {};
        workspacePackages[manifest.name][manifest.version] = {
          dir: rootDir,
          manifest
        };
      }
    }
  });
  return {
    packagesToBuild,
    workspacePackages
  };
}

async function resolveRemoteVersion(packageName, rootDir, cacheDir, registries, proxyConfig = {}, networkConfig = {}) {
  const {
    resolve
  } = await generateResolverAndFetcher(cacheDir, registries, proxyConfig, networkConfig);
  const resolveOpts = {
    projectDir: rootDir,
    registry: ''
  };

  try {
    const parsedPackage = (0, _parsePackageName().default)(packageName);
    const registriesMap = getRegistriesMap(registries);
    const registry = (0, _pickRegistryForPackage().default)(registriesMap, parsedPackage.name);
    const wantedDep = {
      alias: parsedPackage.name,
      pref: parsedPackage.version
    };
    const isValidRange = parsedPackage.version ? !!_semver().default.validRange(parsedPackage.version) : false;
    resolveOpts.registry = registry;
    const val = await resolve(wantedDep, resolveOpts);
    const version = isValidRange ? parsedPackage.version : val.manifest.version;
    return {
      packageName: val.manifest.name,
      version,
      isSemver: true,
      resolvedVia: val.resolvedVia
    };
  } catch (e) {
    var _e$message;

    if (!((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.includes('is not a valid string'))) {
      throw e;
    } // The provided package is probably a git url or path to a folder


    const wantedDep = {
      alias: undefined,
      pref: packageName
    };
    const val = await resolve(wantedDep, resolveOpts);
    return {
      packageName: val.manifest.name,
      version: val.normalizedPref,
      isSemver: false,
      resolvedVia: val.resolvedVia
    };
  }
}

function getRegistriesMap(registries) {
  const registriesMap = {
    default: registries.defaultRegistry.uri || _dependencyResolver().NPM_REGISTRY
  };
  Object.entries(registries.scopes).forEach(([registryName, registry]) => {
    registriesMap[`@${registryName}`] = registry.uri;
  });
  return registriesMap;
}

function getAuthConfig(registries) {
  const res = {};
  res.registry = registries.defaultRegistry.uri;

  if (registries.defaultRegistry.alwaysAuth) {
    res['always-auth'] = true;
  }

  const defaultAuthTokens = getAuthTokenForRegistry(registries.defaultRegistry, true);
  defaultAuthTokens.forEach(({
    keyName,
    val
  }) => {
    res[keyName] = val;
  });
  Object.entries(registries.scopes).forEach(([, registry]) => {
    const authTokens = getAuthTokenForRegistry(registry);
    authTokens.forEach(({
      keyName,
      val
    }) => {
      res[keyName] = val;
    });

    if (registry.alwaysAuth) {
      const nerfed = (0, _nerfDart().default)(registry.uri);
      const alwaysAuthKeyName = `${nerfed}:always-auth`;
      res[alwaysAuthKeyName] = true;
    }
  });
  return res;
}

function getAuthTokenForRegistry(registry, isDefault = false) {
  const nerfed = (0, _nerfDart().default)(registry.uri);

  if (registry.originalAuthType === 'authToken') {
    return [{
      keyName: `${nerfed}:_authToken`,
      val: registry.originalAuthValue || ''
    }];
  }

  if (registry.originalAuthType === 'auth') {
    return [{
      keyName: isDefault ? '_auth' : `${nerfed}:_auth`,
      val: registry.originalAuthValue || ''
    }];
  }

  if (registry.originalAuthType === 'user-pass') {
    var _registry$originalAut, _registry$originalAut2;

    return [{
      keyName: `${nerfed}:username`,
      val: ((_registry$originalAut = registry.originalAuthValue) === null || _registry$originalAut === void 0 ? void 0 : _registry$originalAut.split(':')[0]) || ''
    }, {
      keyName: `${nerfed}:_password`,
      val: ((_registry$originalAut2 = registry.originalAuthValue) === null || _registry$originalAut2 === void 0 ? void 0 : _registry$originalAut2.split(':')[1]) || ''
    }];
  }

  return [];
}

//# sourceMappingURL=lynx.js.map