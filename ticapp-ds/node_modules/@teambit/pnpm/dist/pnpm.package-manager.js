"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.replace.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PnpmPackageManager = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _dependencyResolver() {
  const data = require("@teambit/dependency-resolver");

  _dependencyResolver = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function () {
    return data;
  };

  return data;
}

function _userHome() {
  const data = _interopRequireDefault(require("user-home"));

  _userHome = function () {
    return data;
  };

  return data;
}

function _readConfig() {
  const data = require("./read-config");

  _readConfig = function () {
    return data;
  };

  return data;
}

const defaultStoreDir = (0, _path().join)(_userHome().default, '.pnpm-store');
const defaultCacheDir = (0, _path().join)(_userHome().default, '.pnpm-cache');

class PnpmPackageManager {
  constructor(depResolver, pkg, logger) {
    this.depResolver = depResolver;
    this.pkg = pkg;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "readConfig", (0, _lodash().memoize)(_readConfig().readConfig));
  }

  async _componentsToPnpmWorkspaceProjects(rootDir, rootPolicy, componentDirectoryMap, installOptions = {}) {
    const components = componentDirectoryMap.toArray().map(([component]) => component);
    const options = {
      filterComponentsFromManifests: true,
      createManifestForComponentsWithoutDependencies: true,
      dedupe: installOptions.dedupe,
      dependencyFilterFn: installOptions.dependencyFilterFn
    };
    const workspaceManifest = await this.depResolver.getWorkspaceManifest(undefined, undefined, rootPolicy, rootDir, components, options);
    const rootManifest = workspaceManifest.toJsonWithDir({
      copyPeerToRuntime: installOptions.copyPeerToRuntimeOnRoot,
      installPeersFromEnvs: installOptions.installPeersFromEnvs
    });
    const componentsManifests = this.computeComponentsManifests(componentDirectoryMap, workspaceManifest.componentsManifestsMap, // In case of not deduping we want to install peers inside the components
    // !options.dedupe
    installOptions.copyPeerToRuntimeOnComponents);
    return {
      componentsManifests,
      rootManifest
    };
  }

  async _getGlobalPnpmDirs(opts = {}) {
    var _config$storeDir, _config$cacheDir;

    const {
      config
    } = await this.readConfig(opts.packageManagerConfigRootDir);
    const storeDir = opts.cacheRootDir ? (0, _path().join)(opts.cacheRootDir, '.pnpm-store') : (_config$storeDir = config.storeDir) !== null && _config$storeDir !== void 0 ? _config$storeDir : defaultStoreDir;
    const cacheDir = opts.cacheRootDir ? (0, _path().join)(opts.cacheRootDir, '.pnpm-cache') : (_config$cacheDir = config.cacheDir) !== null && _config$cacheDir !== void 0 ? _config$cacheDir : defaultCacheDir;
    return {
      storeDir,
      cacheDir
    };
  }

  async install(rootDir, rootPolicy, componentDirectoryMap, installOptions = {}) {
    var _installOptions$packa;

    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      install
    } = require('./lynx');

    const {
      componentsManifests,
      rootManifest
    } = await this._componentsToPnpmWorkspaceProjects(rootDir, rootPolicy, componentDirectoryMap, installOptions);
    this.logger.debug('root manifest for installation', rootManifest);
    this.logger.debug('components manifests for installation', componentsManifests);
    this.logger.setStatusLine('installing dependencies using pnpm'); // turn off the logger because it interrupts the pnpm output

    this.logger.off();
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    const {
      storeDir,
      cacheDir
    } = await this._getGlobalPnpmDirs(installOptions);
    const {
      config
    } = await this.readConfig(installOptions.packageManagerConfigRootDir);
    await (0, _dependencyResolver().extendWithComponentsFromDir)(rootManifest.rootDir, componentsManifests);
    await install(rootManifest, componentsManifests, storeDir, cacheDir, registries, proxyConfig, networkConfig, {
      nodeLinker: installOptions.nodeLinker,
      overrides: installOptions.overrides,
      hoistPattern: config.hoistPattern,
      publicHoistPattern: ['*eslint*', '@prettier/plugin-*', '*prettier-plugin-*'],
      packageImportMethod: (_installOptions$packa = installOptions.packageImportMethod) !== null && _installOptions$packa !== void 0 ? _installOptions$packa : config.packageImportMethod
    }, this.logger);
    this.logger.on(); // Make a divider row to improve output

    this.logger.console('-------------------------');
    this.logger.consoleSuccess('installing dependencies using pnpm');
  }

  async getPeerDependencyIssues(rootDir, rootPolicy, componentDirectoryMap, installOptions = {}) {
    var _installOptions$packa2;

    const {
      storeDir,
      cacheDir
    } = await this._getGlobalPnpmDirs(installOptions);
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    const registries = await this.depResolver.getRegistries(); // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require

    const lynx = require('./lynx');

    const {
      componentsManifests,
      rootManifest
    } = await this._componentsToPnpmWorkspaceProjects(rootDir, rootPolicy, componentDirectoryMap, installOptions);
    const {
      config
    } = await this.readConfig();
    return lynx.getPeerDependencyIssues(rootManifest, componentsManifests, {
      storeDir,
      cacheDir,
      proxyConfig,
      registries,
      networkConfig,
      overrides: installOptions.overrides,
      packageImportMethod: (_installOptions$packa2 = installOptions.packageImportMethod) !== null && _installOptions$packa2 !== void 0 ? _installOptions$packa2 : config.packageImportMethod
    });
  }

  computeComponentsManifests(componentDirectoryMap, componentsManifestsFromWorkspace, copyPeerToRuntime = false) {
    return componentDirectoryMap.toArray().reduce((acc, [component, dir]) => {
      const packageName = this.pkg.getPackageName(component);

      if (componentsManifestsFromWorkspace.has(packageName)) {
        var _componentsManifestsF;

        acc[dir] = (_componentsManifestsF = componentsManifestsFromWorkspace.get(packageName)) === null || _componentsManifestsF === void 0 ? void 0 : _componentsManifestsF.toJson({
          copyPeerToRuntime
        });
      }

      return acc;
    }, {});
  }

  async resolveRemoteVersion(packageName, options) {
    // require it dynamically for performance purpose. the pnpm package require many files - do not move to static import
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      resolveRemoteVersion
    } = require('./lynx');

    const {
      cacheDir
    } = await this._getGlobalPnpmDirs(options);
    const registries = await this.depResolver.getRegistries();
    const proxyConfig = await this.depResolver.getProxyConfig();
    const networkConfig = await this.depResolver.getNetworkConfig();
    return resolveRemoteVersion(packageName, options.rootDir, cacheDir, registries, proxyConfig, networkConfig);
  }

  async getProxyConfig() {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      getProxyConfig
    } = require('./get-proxy-config');

    const {
      config
    } = await this.readConfig();
    return getProxyConfig(config);
  }

  async getNetworkConfig() {
    const {
      config
    } = await this.readConfig();
    return {
      maxSockets: config.maxSockets,
      networkConcurrency: config.networkConcurrency,
      fetchRetries: config.fetchRetries,
      fetchTimeout: config.fetchTimeout,
      fetchRetryMaxtimeout: config.fetchRetryMaxtimeout,
      fetchRetryMintimeout: config.fetchRetryMintimeout
    };
  }

  async getRegistries() {
    // eslint-disable-next-line global-require, import/no-dynamic-require
    const {
      getRegistries
    } = require('./get-registries');

    const {
      config
    } = await this.readConfig();
    const pnpmRegistry = await getRegistries(config);
    const defaultRegistry = new (_dependencyResolver().Registry)(pnpmRegistry.default.uri, pnpmRegistry.default.alwaysAuth, pnpmRegistry.default.authHeaderValue, pnpmRegistry.default.originalAuthType, pnpmRegistry.default.originalAuthValue);
    const pnpmScoped = (0, _lodash().omit)(pnpmRegistry, ['default']);
    const scopesRegistries = Object.keys(pnpmScoped).reduce((acc, scopedRegName) => {
      const scopedReg = pnpmScoped[scopedRegName];
      const name = scopedRegName.replace('@', '');
      acc[name] = new (_dependencyResolver().Registry)(scopedReg.uri, scopedReg.alwaysAuth, scopedReg.authHeaderValue, scopedReg.originalAuthType, scopedReg.originalAuthValue);
      return acc;
    }, {}); // Add bit registry server if not exist

    if (!scopesRegistries.bit) {
      scopesRegistries.bit = new (_dependencyResolver().Registry)(_dependencyResolver().BIT_DEV_REGISTRY, true);
    }

    return new (_dependencyResolver().Registries)(defaultRegistry, scopesRegistries);
  }

}

exports.PnpmPackageManager = PnpmPackageManager;

//# sourceMappingURL=pnpm.package-manager.js.map