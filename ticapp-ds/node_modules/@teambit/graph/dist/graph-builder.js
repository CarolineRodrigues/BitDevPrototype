"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GraphBuilder = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _componentGraph() {
  const data = require("./component-graph");

  _componentGraph = function () {
    return data;
  };

  return data;
}

function _dependency() {
  const data = require("./model/dependency");

  _dependency = function () {
    return data;
  };

  return data;
}

/**
 * @todo: potential issues with the current way the class is built.
 * it's possible to call `getGraph` multiple times and at the same time (Promise.all).
 * which makes the _graph prop and other props unpredictable.
 */
class GraphBuilder {
  constructor(componentAspect) {
    this.componentAspect = componentAspect;
    (0, _defineProperty2().default)(this, "_graph", void 0);
    (0, _defineProperty2().default)(this, "_initialized", false);
  }

  async getGraph(ids, opts = {}) {
    const componentHost = opts.host || this.componentAspect.getHost();
    const legacyGraph = await componentHost.getLegacyGraph(ids);
    const graph = await this.buildFromLegacy(legacyGraph, {
      host: opts.host
    });
    this._graph = graph;
    this._initialized = true;
    graph.seederIds = ids || (await componentHost.listIds());
    return this._graph;
  }

  async buildFromLegacy(legacyGraph, opts = {}) {
    const newGraph = new (_componentGraph().ComponentGraph)();
    const componentHost = opts.host || this.componentAspect.getHost();
    const setNodeP = legacyGraph.nodes().map(async nodeId => {
      const componentId = await componentHost.resolveComponentId(nodeId);
      const component = await componentHost.get(componentId);

      if (component) {
        newGraph.setNode(componentId.toString(), component);
      }
    });
    await Promise.all(setNodeP);
    const setEdgePromise = legacyGraph.edges().map(async edgeId => {
      const source = await componentHost.resolveComponentId(edgeId.v);
      const target = await componentHost.resolveComponentId(edgeId.w);
      const edgeObj = legacyGraph.edge(edgeId.v, edgeId.w) === 'dependencies' ? new (_dependency().Dependency)('runtime') : new (_dependency().Dependency)('dev');
      newGraph.setEdge(source.toString(), target.toString(), edgeObj);
    });
    await Promise.all(setEdgePromise);
    newGraph.versionMap = newGraph._calculateVersionMap();
    return newGraph;
  }

}

exports.GraphBuilder = GraphBuilder;

//# sourceMappingURL=graph-builder.js.map