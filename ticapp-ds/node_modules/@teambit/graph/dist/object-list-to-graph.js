"use strict";

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IdGraph = void 0;
exports.objectListToGraph = objectListToGraph;

function _cleargraph() {
  const data = require("cleargraph");

  _cleargraph = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _traverseVersions() {
  const data = require("@teambit/legacy/dist/scope/component-ops/traverse-versions");

  _traverseVersions = function () {
    return data;
  };

  return data;
}

function _dependency() {
  const data = require("./model/dependency");

  _dependency = function () {
    return data;
  };

  return data;
}

class IdGraph extends _cleargraph().Graph {
  constructor(nodes = [], edges = []) {
    super(nodes, edges);
  }

}

exports.IdGraph = IdGraph;

async function objectListToGraph(objectList) {
  const bitObjectsList = await objectList.toBitObjects();
  const components = bitObjectsList.getComponents();
  const versions = bitObjectsList.getVersions();
  const nodes = [];
  const edges = [];
  await Promise.all(components.map(async component => {
    const versionsInfo = await (0, _traverseVersions().getAllVersionsInfo)({
      modelComponent: component,
      versionObjects: versions,
      throws: false
    });
    versionsInfo.forEach(versionInfo => {
      const id = component.toBitId().changeVersion(versionInfo.tag || versionInfo.ref.toString());
      const idStr = id.toString();
      nodes.push({
        id: idStr,
        node: id
      });

      if (!versionInfo.version) {
        return;
      }

      const {
        dependencies,
        devDependencies,
        extensionDependencies
      } = versionInfo.version.depsIdsGroupedByType;

      const addDep = (depId, edge) => {
        const depIdStr = depId.toString();
        nodes.push({
          id: depIdStr,
          node: depId
        });
        edges.push({
          sourceId: idStr,
          targetId: depIdStr,
          edge
        });
      };

      const runTime = new (_dependency().Dependency)('runtime');
      const dev = new (_dependency().Dependency)('dev');
      dependencies.forEach(depId => addDep(depId, runTime));
      [...devDependencies, ...extensionDependencies].forEach(depId => addDep(depId, dev));
    });
  }));
  const uniqNodes = (0, _lodash().uniqBy)(nodes, 'id');
  const idGraph = new IdGraph(uniqNodes, edges);
  return idGraph;
}

//# sourceMappingURL=object-list-to-graph.js.map