"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.flat.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.array.unscopables.flat.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.trim.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SnappingMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@teambit/legacy/dist/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _featureToggle() {
  const data = require("@teambit/legacy/dist/api/consumer/lib/feature-toggle");

  _featureToggle = function () {
    return data;
  };

  return data;
}

function _componentIssues() {
  const data = require("@teambit/component-issues");

  _componentIssues = function () {
    return data;
  };

  return data;
}

function _community() {
  const data = _interopRequireDefault(require("@teambit/community"));

  _community = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));

  _workspace = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("@teambit/legacy/dist/analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _semverHelper() {
  const data = require("@teambit/legacy/dist/utils/semver-helper");

  _semverHelper = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _tagModelComponent() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/scope/component-ops/tag-model-component"));

  _tagModelComponent = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("@teambit/legacy/dist/consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _componentsPendingImport() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/exceptions/components-pending-import"));

  _componentsPendingImport = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _bitError() {
  const data = require("@teambit/bit-error");

  _bitError = function () {
    return data;
  };

  return data;
}

function _failedLoadForTag() {
  const data = require("@teambit/legacy/dist/consumer/component/exceptions/failed-load-for-tag");

  _failedLoadForTag = function () {
    return data;
  };

  return data;
}

function _issues() {
  const data = _interopRequireDefault(require("@teambit/issues"));

  _issues = function () {
    return data;
  };

  return data;
}

function _snapCmd() {
  const data = require("./snap-cmd");

  _snapCmd = function () {
    return data;
  };

  return data;
}

function _snapping() {
  const data = require("./snapping.aspect");

  _snapping = function () {
    return data;
  };

  return data;
}

function _tagCmd() {
  const data = require("./tag-cmd");

  _tagCmd = function () {
    return data;
  };

  return data;
}

function _componentsHaveIssues() {
  const data = require("./components-have-issues");

  _componentsHaveIssues = function () {
    return data;
  };

  return data;
}

const HooksManagerInstance = _hooks().default.getInstance();

class SnappingMain {
  constructor(workspace, logger, issues) {
    this.workspace = workspace;
    this.logger = logger;
    this.issues = issues;
  }
  /**
   * tag the given component ids or all modified/new components if "all" param is set.
   * tag is a similar operation as a snap, which saves the changes into the local scope, but it also creates an alias
   * with a valid semver to that version.
   * tag can be done only on main, not on a lane.
   */
  // eslint-disable-next-line complexity


  async tag({
    ids = [],
    message = '',
    ver,
    all = false,
    editor = '',
    snapped = false,
    patch,
    minor,
    major,
    preRelease,
    force = false,
    verbose = false,
    ignoreIssues,
    ignoreNewestVersion = false,
    skipTests = false,
    skipAutoTag = false,
    scope,
    build,
    soft = false,
    persist = false,
    forceDeploy = false,
    incrementBy = 1,
    disableTagAndSnapPipelines = false
  }) {
    build = (0, _featureToggle().isFeatureEnabled)(_featureToggle().BUILD_ON_CI) ? Boolean(build) : true;
    if (soft) build = false;

    function getVersion() {
      if (scope && (0, _utils().isString)(scope)) return scope;
      if (all && (0, _utils().isString)(all)) return all;
      if (snapped && (0, _utils().isString)(snapped)) return snapped;
      return ver;
    }

    if (!ids.length && !all && !snapped && !scope && !persist) {
      throw new (_bitError().BitError)('missing [id]. to tag all components, please use --all flag');
    }

    if (ids.length && all) {
      throw new (_bitError().BitError)('you can use either a specific component [id] to tag a particular component or --all flag to tag them all');
    }

    if (disableTagAndSnapPipelines && forceDeploy) {
      throw new (_bitError().BitError)('you can use either force-deploy or disable-tag-pipeline, but not both');
    }

    if (all && persist) {
      throw new (_bitError().BitError)('you can use either --all or --persist, but not both');
    }

    if (editor && persist) {
      throw new (_bitError().BitError)('you can use either --editor or --persist, but not both');
    }

    if (editor && message) {
      throw new (_bitError().BitError)('you can use either --editor or --message, but not both');
    }

    const releaseFlags = [patch, minor, major, preRelease].filter(x => x);

    if (releaseFlags.length > 1) {
      throw new (_bitError().BitError)('you can use only one of the following - patch, minor, major, pre-release');
    }

    let releaseType = _constants().DEFAULT_BIT_RELEASE_TYPE;

    const includeImported = Boolean(scope && all);
    if (major) releaseType = 'major';else if (minor) releaseType = 'minor';else if (patch) releaseType = 'patch';else if (preRelease) releaseType = 'prerelease';
    const exactVersion = getVersion();
    all = Boolean(all);
    snapped = Boolean(snapped);
    preRelease = typeof preRelease === 'string' ? preRelease : '';
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const idsHasWildcard = (0, _hasWildcard().default)(ids);
    const isAll = Boolean(all || scope || idsHasWildcard);
    const validExactVersion = (0, _semverHelper().validateVersion)(exactVersion);
    const consumer = this.workspace.consumer;
    const componentsList = new (_componentsList().default)(consumer);

    _loader().default.start('determine components to tag...');

    const newComponents = await componentsList.listNewComponents();
    const {
      bitIds,
      warnings
    } = await this.getComponentsToTag(Boolean(scope), exactVersion, includeImported, persist, force, ids, snapped);
    if (_ramda().default.isEmpty(bitIds)) return null;

    const legacyBitIds = _bitId().BitIds.fromArray(bitIds);

    if (this.workspace.isLegacy) {
      persist = true;
    }

    this.logger.debug(`tagging the following components: ${legacyBitIds.toString()}`);

    _analytics().Analytics.addBreadCrumb('tag', `tagging the following components: ${_analytics().Analytics.hashData(legacyBitIds)}`);

    if (!soft) {
      await this.workspace.consumer.componentFsCache.deleteAllDependenciesDataCache();
    }

    const components = await this.loadComponentsForTag(legacyBitIds);
    this.throwForComponentIssues(components, ignoreIssues);
    const areComponentsMissingFromScope = components.some(c => !c.componentFromModel && c.id.hasScope());

    if (areComponentsMissingFromScope) {
      throw new (_componentsPendingImport().default)();
    }

    const {
      taggedComponents,
      autoTaggedResults,
      publishedPackages
    } = await (0, _tagModelComponent().default)({
      consumerComponents: components,
      ids: legacyBitIds,
      scope: this.workspace.scope.legacyScope,
      message,
      editor,
      exactVersion: validExactVersion,
      releaseType,
      preRelease,
      force,
      consumer: this.workspace.consumer,
      ignoreNewestVersion,
      skipTests,
      verbose,
      skipAutoTag,
      soft,
      build,
      persist,
      resolveUnmerged: false,
      disableTagAndSnapPipelines,
      forceDeploy,
      incrementBy
    });
    const tagResults = {
      taggedComponents,
      autoTaggedResults,
      isSoftTag: soft,
      publishedPackages
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    tagResults.warnings = warnings; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    tagResults.newComponents = newComponents;
    const postHook = isAll ? _constants().POST_TAG_ALL_HOOK : _constants().POST_TAG_HOOK;
    HooksManagerInstance === null || HooksManagerInstance === void 0 ? void 0 : HooksManagerInstance.triggerHook(postHook, tagResults);

    _analytics().Analytics.setExtraData('num_components', // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    _ramda().default.concat(tagResults.taggedComponents, tagResults.autoTaggedResults, tagResults.newComponents).length);

    await consumer.onDestroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return tagResults;
  }
  /**
   * save the local changes of a component(s) into the scope. snap can be done on main or on a lane.
   * once a component is snapped on a lane, it becomes part of it.
   */


  async snap({
    id,
    // @todo: rename to "patterns"
    legacyBitIds,
    // @todo: change to ComponentID[]. pass only if have the ids already parsed.
    resolveUnmerged = false,
    message = '',
    force = false,
    verbose = false,
    ignoreIssues,
    skipTests = false,
    skipAutoSnap = false,
    build,
    disableTagAndSnapPipelines = false,
    forceDeploy = false
  }) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    if (id && legacyBitIds) throw new Error(`please pass either id or legacyBitIds, not both`);
    const consumer = this.workspace.consumer;
    if (consumer.isLegacy) throw new (_lanesIsDisabled().LanesIsDisabled)();
    const componentsList = new (_componentsList().default)(consumer);
    const newComponents = await componentsList.listNewComponents();
    const ids = legacyBitIds || (await getIdsToSnap());
    if (!ids) return null;
    this.logger.debug(`snapping the following components: ${ids.toString()}`);
    await this.workspace.consumer.componentFsCache.deleteAllDependenciesDataCache();
    const components = await this.loadComponentsForTag(ids);
    this.throwForComponentIssues(components, ignoreIssues);
    const areComponentsMissingFromScope = components.some(c => !c.componentFromModel && c.id.hasScope());

    if (areComponentsMissingFromScope) {
      throw new (_componentsPendingImport().default)();
    }

    const {
      taggedComponents,
      autoTaggedResults
    } = await (0, _tagModelComponent().default)({
      consumerComponents: components,
      ids,
      ignoreNewestVersion: false,
      scope: this.workspace.scope.legacyScope,
      message,
      force,
      consumer: this.workspace.consumer,
      skipTests,
      verbose,
      skipAutoTag: skipAutoSnap,
      persist: true,
      soft: false,
      build,
      resolveUnmerged,
      isSnap: true,
      disableTagAndSnapPipelines,
      forceDeploy
    }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const snapResults = {
      snappedComponents: taggedComponents,
      autoSnappedResults: autoTaggedResults
    };
    snapResults.newComponents = newComponents;
    const currentLane = consumer.getCurrentLaneId();
    snapResults.laneName = currentLane.isDefault() ? null : currentLane.name;
    await consumer.onDestroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return snapResults;

    async function getIdsToSnap() {
      const idHasWildcard = id && (0, _hasWildcard().default)(id);

      if (id && !idHasWildcard) {
        const bitId = consumer.getParsedId(id);

        if (!force) {
          const componentStatus = await consumer.getComponentStatusById(bitId); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

          if (componentStatus.modified === false) return null;
        }

        return new (_bitId().BitIds)(bitId);
      }

      const tagPendingComponents = await componentsList.listTagPendingComponents(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (_ramda().default.isEmpty(tagPendingComponents)) return null;
      return idHasWildcard ? _componentsList().default.filterComponentsByWildcard(tagPendingComponents, id) : tagPendingComponents;
    }
  }

  async loadComponentsForTag(ids) {
    const {
      components
    } = await this.workspace.consumer.loadComponents(ids.toVersionLatest());

    if (this.workspace.isLegacy) {
      return components;
    }

    let shouldReloadComponents = false;
    const componentsWithRelativePaths = [];
    const componentsWithFilesNotDir = [];
    const componentsWithCustomModuleResolution = [];
    components.forEach(component => {
      var _component$issues, _component$issues2;

      const componentMap = component.componentMap;
      if (componentMap.rootDir) return;
      const hasRelativePaths = (_component$issues = component.issues) === null || _component$issues === void 0 ? void 0 : _component$issues.getIssue(_componentIssues().IssuesClasses.RelativeComponentsAuthored);
      const hasCustomModuleResolutions = (_component$issues2 = component.issues) === null || _component$issues2 === void 0 ? void 0 : _component$issues2.getIssue(_componentIssues().IssuesClasses.MissingCustomModuleResolutionLinks); // leaving this because it can be helpful for users upgrade from legacy

      if (componentMap.trackDir && !hasRelativePaths) {
        componentMap.changeRootDirAndUpdateFilesAccordingly(componentMap.trackDir);
        shouldReloadComponents = true;
        return;
      }

      if (hasRelativePaths) {
        componentsWithRelativePaths.push(component.id.toStringWithoutVersion());
      }

      if (!componentMap.trackDir) {
        componentsWithFilesNotDir.push(component.id.toStringWithoutVersion());
      }

      if (hasCustomModuleResolutions) {
        componentsWithCustomModuleResolution.push(component.id.toStringWithoutVersion());
      }
    });

    if (componentsWithRelativePaths.length || componentsWithFilesNotDir.length) {
      throw new (_failedLoadForTag().FailedLoadForTag)(componentsWithRelativePaths.sort(), componentsWithFilesNotDir.sort(), componentsWithCustomModuleResolution.sort());
    }

    if (!shouldReloadComponents) return components;
    this.workspace.clearCache();
    const {
      components: reloadedComponents
    } = await this.workspace.consumer.loadComponents(ids);
    return reloadedComponents;
  }

  throwForComponentIssues(components, ignoreIssues) {
    components.forEach(component => {
      if (this.workspace.isLegacy && component.issues) {
        component.issues.delete(_componentIssues().IssuesClasses.RelativeComponentsAuthored);
      }
    });

    if (ignoreIssues === '*') {
      // ignore all issues
      return;
    }

    const issuesToIgnoreFromFlag = (ignoreIssues === null || ignoreIssues === void 0 ? void 0 : ignoreIssues.split(',').map(issue => issue.trim())) || [];
    const issuesToIgnoreFromConfig = this.issues.getIssuesToIgnore();
    const issuesToIgnore = [...issuesToIgnoreFromFlag, ...issuesToIgnoreFromConfig];
    issuesToIgnore.forEach(issue => {
      const issueClass = _componentIssues().IssuesClasses[issue];

      if (!issueClass) {
        throw new Error(`unrecognized component-issue "${issue}". please specify one of the following:\n${Object.keys(_componentIssues().IssuesClasses).join('\n')}`);
      }

      components.forEach(component => {
        component.issues.delete(issueClass);
      });
    });
    const componentsWithBlockingIssues = components.filter(component => {
      var _component$issues3;

      return (_component$issues3 = component.issues) === null || _component$issues3 === void 0 ? void 0 : _component$issues3.shouldBlockTagging();
    });

    if (!_ramda().default.isEmpty(componentsWithBlockingIssues)) {
      throw new (_componentsHaveIssues().ComponentsHaveIssues)(componentsWithBlockingIssues);
    }
  }

  async getComponentsToTag(isAllScope, exactVersion, includeImported, persist, force, ids, snapped) {
    const warnings = [];
    const componentsList = new (_componentsList().default)(this.workspace.consumer);

    if (persist) {
      const softTaggedComponents = componentsList.listSoftTaggedComponents();
      return {
        bitIds: softTaggedComponents,
        warnings: []
      };
    }

    const tagPendingComponents = isAllScope ? await componentsList.listTagPendingOfAllScope(includeImported) : await componentsList.listTagPendingComponents();
    const snappedComponents = await componentsList.listSnappedComponentsOnMain();
    const snappedComponentsIds = snappedComponents.map(c => c.toBitId());

    if (ids.length) {
      const bitIds = await Promise.all(ids.map(async id => {
        const [idWithoutVer, version] = id.split('@');
        const idHasWildcard = (0, _hasWildcard().default)(id);

        if (idHasWildcard) {
          const allIds = _componentsList().default.filterComponentsByWildcard(tagPendingComponents, idWithoutVer);

          return allIds.map(bitId => bitId.changeVersion(version));
        }

        const bitId = this.workspace.consumer.getParsedId(idWithoutVer);

        if (!force) {
          const componentStatus = await this.workspace.consumer.getComponentStatusById(bitId);
          if (componentStatus.modified === false) return null;
        }

        return bitId.changeVersion(version);
      }));
      return {
        bitIds: (0, _lodash().compact)(bitIds.flat()),
        warnings
      };
    }

    if (snapped) {
      return {
        bitIds: snappedComponentsIds,
        warnings
      };
    }

    tagPendingComponents.push(...snappedComponentsIds);

    if (isAllScope && exactVersion) {
      const tagPendingComponentsLatest = await this.workspace.scope.legacyScope.latestVersions(tagPendingComponents, false);
      tagPendingComponentsLatest.forEach(componentId => {
        if (componentId.version && _semver().default.valid(componentId.version) && _semver().default.gt(componentId.version, exactVersion)) {
          warnings.push(`warning: ${componentId.toString()} has a version greater than ${exactVersion}`);
        }
      });
    }

    return {
      bitIds: tagPendingComponents.map(id => id.changeVersion(undefined)),
      warnings
    };
  }

  static async provider([workspace, cli, community, loggerMain, issues]) {
    const logger = loggerMain.createLogger(_snapping().SnappingAspect.id);
    const snapping = new SnappingMain(workspace, logger, issues);
    const snapCmd = new (_snapCmd().SnapCmd)(community.getBaseDomain(), snapping);
    const tagCmd = new (_tagCmd().TagCmd)(community.getBaseDomain(), snapping);
    cli.register(tagCmd, snapCmd);
    return snapping;
  }

}

exports.SnappingMain = SnappingMain;
(0, _defineProperty2().default)(SnappingMain, "slots", []);
(0, _defineProperty2().default)(SnappingMain, "dependencies", [_workspace().default, _cli().CLIAspect, _community().default, _logger().LoggerAspect, _issues().default]);
(0, _defineProperty2().default)(SnappingMain, "runtime", _cli().MainRuntime);

_snapping().SnappingAspect.addRuntime(SnappingMain);

var _default = SnappingMain;
exports.default = _default;

//# sourceMappingURL=snapping.main.runtime.js.map