{"version":3,"sources":["variants.main.runtime.ts"],"names":["INTERNAL_FIELDS","VariantsMain","constructor","patterns","configAspect","_loadedLegacy","ConsumerOverrides","load","validateConfig","patternConfig","pattern","defaultScope","InvalidScopeName","undefined","raw","legacy","byRootDirAndName","rootDir","componentName","matches","match","excluded","push","config","specificity","maxSpecificity","sortedMatches","propagate","extensionsToMerge","forEach","getExtensionFromPatternRawConfig","mergedExtensions","ExtensionDataList","mergeConfigs","result","extensions","length","setExtension","variant","extensionId","extensionConfig","opts","newVariant","VariantsAspect","id","overrideExisting","ignoreVersion","provider","MainRuntime","ConfigAspect","rawExtensions","fromConfigObject","addRuntime"],"mappings":"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","sourcesContent":["import { MainRuntime } from '@teambit/cli';\nimport { ConfigAspect } from '@teambit/config';\nimport type { ConfigMain } from '@teambit/config';\nimport ConsumerOverrides from '@teambit/legacy/dist/consumer/config/consumer-overrides';\nimport { ExtensionDataList } from '@teambit/legacy/dist/consumer/config/extension-data';\nimport { PathLinuxRelative } from '@teambit/legacy/dist/utils/path';\nimport { assign } from 'comment-json';\nimport { omit, forEach } from 'lodash';\nimport {\n  MatchedPatternWithConfig,\n  isMatchPattern,\n  sortMatchesBySpecificity,\n} from '@teambit/workspace.modules.match-pattern';\nimport { InvalidScopeName, isValidScopeName } from '@teambit/legacy-bit-id';\nimport { VariantsAspect } from './variants.aspect';\n\nexport type Patterns = { [pattern: string]: Record<string, any> };\n\nexport type VariantsComponentConfig = {\n  propagate: boolean;\n  exclude?: string[];\n  defaultScope?: string;\n  extensions: ExtensionDataList;\n  maxSpecificity: number;\n  sortedMatches: MatchedPatternWithConfig[];\n};\n\nconst INTERNAL_FIELDS = ['propagate', 'exclude', 'defaultScope'];\n\nexport class VariantsMain {\n  static runtime = MainRuntime;\n  static dependencies = [ConfigAspect];\n\n  _loadedLegacy: ConsumerOverrides;\n\n  constructor(private patterns: Patterns, private configAspect: ConfigMain) {\n    this._loadedLegacy = ConsumerOverrides.load(this.patterns);\n    this.validateConfig();\n  }\n\n  private validateConfig() {\n    forEach(this.patterns, (patternConfig: Record<string, any>, pattern: string) => {\n      if (patternConfig.defaultScope && !isValidScopeName(patternConfig.defaultScope)) {\n        throw new InvalidScopeName(patternConfig.defaultScope, undefined, pattern);\n      }\n    });\n  }\n\n  raw(): Patterns {\n    return this.patterns;\n  }\n\n  /**\n   * Get all the patterns defined in the variants section of the workspace as the legacy ConsumerOverrides format\n   */\n  legacy(): ConsumerOverrides {\n    // return ConsumerOverrides.load(this.patterns);\n    return this._loadedLegacy;\n  }\n\n  /**\n   * Gets the config for specific component after merge all matching patterns of the component dir and id in the variants section\n   * @param rootDir\n   */\n  byRootDirAndName(rootDir: PathLinuxRelative, componentName: string): VariantsComponentConfig | undefined {\n    const matches: MatchedPatternWithConfig[] = [];\n    forEach(this.patterns, (patternConfig, pattern) => {\n      const match = isMatchPattern(rootDir, componentName, pattern);\n\n      // Ignore matches with exclude matches\n      if (match.match && !match.excluded) {\n        matches.push({\n          config: patternConfig,\n          specificity: match.maxSpecificity,\n          pattern: match.pattern,\n        });\n      }\n    });\n\n    const sortedMatches: MatchedPatternWithConfig[] = sortMatchesBySpecificity(matches);\n\n    let defaultScope;\n    let propagate = true;\n    const extensionsToMerge: ExtensionDataList[] = [];\n    sortedMatches.forEach((match) => {\n      defaultScope = defaultScope || match.config.defaultScope;\n      if (propagate) {\n        extensionsToMerge.push(getExtensionFromPatternRawConfig(match.config));\n      }\n      if (match.config.propagate === false) {\n        propagate = false;\n      }\n    });\n\n    const mergedExtensions = ExtensionDataList.mergeConfigs(extensionsToMerge);\n    const result = {\n      defaultScope,\n      extensions: mergedExtensions,\n      propagate,\n      maxSpecificity: sortedMatches.length ? sortedMatches[0].specificity : -1,\n      sortedMatches,\n    };\n    return result;\n  }\n\n  /**\n   * Updates the specified extension object of the specified variant.\n   * @param {string} variant - The variant pattern.\n   * @param {string} extensionId - The extension ID.\n   * @param {Object} extensionConfig - The extension configuration.\n   * @param {boolean} opts.overrideExisting - When true, any existing entries are overriden.\n   */\n  setExtension(variant: string, extensionId: string, extensionConfig: any, opts?: { overrideExisting?: boolean }) {\n    const newVariant = this.patterns[variant] ?? {};\n    assign(newVariant, { [extensionId]: extensionConfig });\n    assign(this.patterns, { [variant]: newVariant });\n    this.configAspect.setExtension(VariantsAspect.id, this.patterns, {\n      overrideExisting: opts?.overrideExisting === true,\n      ignoreVersion: true,\n    });\n  }\n\n  static async provider([configAspect]: [ConfigMain], config) {\n    return new VariantsMain(config, configAspect);\n  }\n}\n\nfunction getExtensionFromPatternRawConfig(config: Record<string, any>) {\n  const rawExtensions = omit(config, INTERNAL_FIELDS);\n  const extensions = ExtensionDataList.fromConfigObject(rawExtensions);\n  return extensions;\n}\n\nVariantsAspect.addRuntime(VariantsMain);\n"]}