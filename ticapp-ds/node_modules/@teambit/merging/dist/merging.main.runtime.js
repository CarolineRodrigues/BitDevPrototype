"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MergingMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _workspace() {
  const data = _interopRequireDefault(require("@teambit/workspace"));

  _workspace = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _lanesIsDisabled() {
  const data = require("@teambit/legacy/dist/consumer/lanes/exceptions/lanes-is-disabled");

  _lanesIsDisabled = function () {
    return data;
  };

  return data;
}

function _mergeVersion() {
  const data = require("@teambit/legacy/dist/consumer/versions-ops/merge-version");

  _mergeVersion = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("@teambit/legacy/dist/consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _snapping() {
  const data = _interopRequireDefault(require("@teambit/snapping"));

  _snapping = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _laneId() {
  const data = require("@teambit/legacy/dist/lane-id/lane-id");

  _laneId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _getDivergeData() {
  const data = require("@teambit/legacy/dist/scope/component-ops/get-diverge-data");

  _getDivergeData = function () {
    return data;
  };

  return data;
}

function _objects() {
  const data = require("@teambit/legacy/dist/scope/objects");

  _objects = function () {
    return data;
  };

  return data;
}

function _repositories() {
  const data = require("@teambit/legacy/dist/scope/repositories");

  _repositories = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@teambit/legacy/dist/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function _checkoutVersion() {
  const data = _interopRequireWildcard(require("@teambit/legacy/dist/consumer/versions-ops/checkout-version"));

  _checkoutVersion = function () {
    return data;
  };

  return data;
}

function _threeWayMerge() {
  const data = _interopRequireDefault(require("@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge"));

  _threeWayMerge = function () {
    return data;
  };

  return data;
}

function _mergeCmd() {
  const data = require("./merge-cmd");

  _mergeCmd = function () {
    return data;
  };

  return data;
}

function _merging() {
  const data = require("./merging.aspect");

  _merging = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

class MergingMain {
  constructor(workspace, snapping) {
    var _this$workspace;

    this.workspace = workspace;
    this.snapping = snapping;
    (0, _defineProperty2().default)(this, "consumer", void 0);
    this.consumer = (_this$workspace = this.workspace) === null || _this$workspace === void 0 ? void 0 : _this$workspace.consumer;
  }
  /**
   * merge components according to the "values" param.
   * if the first param is a version, then merge the component ids to that version.
   * otherwise, merge from the remote head to the local.
   */


  async merge(values, mergeStrategy, abort, resolve, noSnap, message, build) {
    if (!this.workspace) throw new (_exceptions().ConsumerNotFound)();
    const consumer = this.workspace.consumer;

    if (consumer.isLegacy && (noSnap || message || abort || resolve)) {
      throw new (_lanesIsDisabled().LanesIsDisabled)();
    }

    let mergeResults;

    const firstValue = _ramda().default.head(values);

    if (resolve) {
      mergeResults = await this.resolveMerge(consumer, values, message, build);
    } else if (abort) {
      mergeResults = await this.abortMerge(consumer, values);
    } else if (!_bitId().BitId.isValidVersion(firstValue)) {
      const bitIds = this.getComponentsToMerge(consumer, values); // @todo: version could be the lane only or remote/lane

      mergeResults = await this.mergeComponentsFromRemote(consumer, bitIds, mergeStrategy, noSnap, message, build);
    } else {
      const version = firstValue;

      const ids = _ramda().default.tail(values);

      const bitIds = this.getComponentsToMerge(consumer, ids);
      mergeResults = await (0, _mergeVersion().mergeVersion)(consumer, version, bitIds, mergeStrategy);
    }

    await consumer.onDestroy();
    return mergeResults;
  }
  /**
   * when user is on main, it merges the remote main components into local.
   * when user is on a lane, it merges the remote lane components into the local lane.
   */


  async mergeComponentsFromRemote(consumer, bitIds, mergeStrategy, noSnap, snapMessage, build) {
    const localLaneId = consumer.getCurrentLaneId();
    const localLaneObject = await consumer.getCurrentLaneObject();
    const remoteTrackedLane = consumer.scope.lanes.getRemoteTrackedDataByLocalLane(localLaneId.name);

    if (!localLaneId.isDefault() && !remoteTrackedLane) {
      throw new Error(`unable to find a remote tracked to the local lane "${localLaneId.name}"`);
    }

    const allComponentsStatus = await this.getAllComponentsStatus(bitIds, localLaneId, localLaneObject, remoteTrackedLane);
    return this.mergeSnaps({
      mergeStrategy,
      allComponentsStatus,
      remoteName: remoteTrackedLane ? remoteTrackedLane.remoteScope : null,
      laneId: localLaneId,
      localLane: localLaneObject,
      noSnap,
      snapMessage,
      build
    });
  }
  /**
   * merge multiple components according to the "allComponentsStatus".
   */


  async mergeSnaps({
    mergeStrategy,
    allComponentsStatus,
    remoteName,
    laneId,
    localLane,
    noSnap,
    snapMessage,
    build
  }) {
    const consumer = this.workspace.consumer;
    const componentWithConflict = allComponentsStatus.find(component => component.mergeResults && component.mergeResults.hasConflicts);

    if (componentWithConflict && !mergeStrategy) {
      mergeStrategy = await (0, _mergeVersion().getMergeStrategyInteractive)();
    }

    const failedComponents = allComponentsStatus.filter(componentStatus => componentStatus.failureMessage).map(componentStatus => ({
      id: componentStatus.id,
      failureMessage: componentStatus.failureMessage
    }));
    const succeededComponents = allComponentsStatus.filter(componentStatus => !componentStatus.failureMessage); // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,
    // which can be an issue when some components are also dependencies of others

    const componentsResults = await (0, _pMapSeries().default)(succeededComponents, ({
      componentFromFS,
      id,
      mergeResults
    }) => {
      return this.applyVersion({
        consumer,
        componentFromFS,
        id,
        mergeResults,
        mergeStrategy,
        remoteHead: new (_objects().Ref)(id.version),
        // @ts-ignore
        remoteName: remoteName || componentFromFS.scope,
        laneId,
        localLane
      });
    });
    if (localLane) consumer.scope.objects.add(localLane);
    await consumer.scope.objects.persist(); // persist anyway, it localLane is null it should save all main heads

    await consumer.scope.objects.unmergedComponents.write();
    const mergeSnapResults = noSnap ? null : await this.snapResolvedComponents(consumer, snapMessage, build);
    return {
      components: componentsResults,
      failedComponents,
      mergeSnapResults
    };
  }

  async getComponentMergeStatus(id, localLane, otherLaneName, existingOnWorkspaceOnly = false) {
    var _modelComponent$laneH;

    const consumer = this.workspace.consumer;
    const componentStatus = {
      id
    };

    const returnFailure = msg => {
      componentStatus.failureMessage = msg;
      return componentStatus;
    };

    const modelComponent = await consumer.scope.getModelComponentIfExist(id);

    if (!modelComponent) {
      throw new (_generalError().default)(`component ${id.toString()} is on the lane but its objects were not found, please re-import the lane`);
    }

    const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);

    if (unmerged && unmerged.resolved === false) {
      return returnFailure(`component ${id.toStringWithoutVersion()} has conflicts that need to be resolved first, please use bit merge --resolve/--abort`);
    }

    const version = id.version;
    const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, {
      ignoreVersion: true
    });
    const componentOnLane = await modelComponent.loadVersion(version, consumer.scope.objects);

    if (!existingBitMapId) {
      if (existingOnWorkspaceOnly) {
        return returnFailure(`component ${id.toStringWithoutVersion()} is not in the workspace`);
      } // @ts-ignore


      return {
        componentFromFS: null,
        componentFromModel: componentOnLane,
        id,
        mergeResults: null
      };
    }

    const currentlyUsedVersion = existingBitMapId.version;

    if (currentlyUsedVersion === version) {
      // @todo: maybe this check is not needed as we check for diverge later on
      if (localLane || modelComponent.hasHead()) {
        return returnFailure(`component ${id.toStringWithoutVersion()} is already merged`);
      }
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    const component = await consumer.loadComponent(existingBitMapId);
    const componentModificationStatus = await consumer.getComponentStatusById(component.id);

    if (componentModificationStatus.modified) {
      throw new (_generalError().default)(`unable to merge ${id.toStringWithoutVersion()}, the component is modified, please snap/tag it first`);
    }

    const repo = consumer.scope.objects;
    const laneHeadIsDifferentThanCheckedOut = localLane && currentlyUsedVersion && ((_modelComponent$laneH = modelComponent.laneHeadLocal) === null || _modelComponent$laneH === void 0 ? void 0 : _modelComponent$laneH.toString()) !== currentlyUsedVersion;
    const localHead = laneHeadIsDifferentThanCheckedOut ? _objects().Ref.from(currentlyUsedVersion) : null;
    const otherLaneHead = new (_objects().Ref)(version);
    const divergeData = await (0, _getDivergeData().getDivergeData)(repo, modelComponent, otherLaneHead, localHead);

    if (!divergeData.isDiverged()) {
      if (divergeData.isLocalAhead()) {
        // do nothing!
        return returnFailure(`component ${component.id.toString()} is ahead, nothing to merge`);
      }

      if (divergeData.isRemoteAhead()) {
        // just override with the model data
        return {
          componentFromFS: component,
          componentFromModel: componentOnLane,
          id,
          mergeResults: null
        };
      } // we know that localHead and remoteHead are set, so if none of them is ahead they must be equal


      return returnFailure(`component ${component.id.toString()} is already merged`);
    }

    const baseSnap = divergeData.commonSnapBeforeDiverge; // must be set when isTrueMerge

    const baseComponent = await modelComponent.loadVersion(baseSnap.toString(), repo);
    const otherComponent = await modelComponent.loadVersion(otherLaneHead.toString(), repo);
    const mergeResults = await (0, _threeWayMerge().default)({
      consumer,
      otherComponent,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      otherLabel: `${otherLaneHead.toString()} (${otherLaneName})`,
      currentComponent: component,
      currentLabel: `${currentlyUsedVersion} (local)`,
      baseComponent
    });
    return {
      componentFromFS: component,
      id,
      mergeResults
    };
  }

  async applyVersion({
    consumer,
    componentFromFS,
    id,
    mergeResults,
    mergeStrategy,
    remoteHead,
    remoteName,
    laneId,
    localLane
  }) {
    let filesStatus = {};
    const unmergedComponent = {
      // @ts-ignore
      id: {
        name: id.name,
        scope: id.scope
      },
      // @ts-ignore
      head: remoteHead,
      // @ts-ignore
      remote: remoteName,
      lane: laneId.name,
      resolved: false // could be changed later

    };
    id = componentFromFS ? componentFromFS.id : id;

    if (mergeResults && mergeResults.hasConflicts && mergeStrategy === _mergeVersion().MergeOptions.ours) {
      if (!componentFromFS) throw new Error(`applyVersion expect to get componentFromFS for ${id.toString()}`);
      componentFromFS.files.forEach(file => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.unchanged;
      });
      unmergedComponent.resolved = true;
      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
      return {
        id,
        filesStatus
      };
    }

    const remoteId = id.changeVersion(remoteHead.toString());
    const idToLoad = !mergeResults || mergeStrategy === _mergeVersion().MergeOptions.theirs ? remoteId : id;
    const componentWithDependencies = await consumer.loadComponentWithDependenciesFromModel(idToLoad);
    const componentMap = componentFromFS && componentFromFS.componentMap;
    if (componentFromFS && !componentMap) throw new (_generalError().default)('applyVersion: componentMap was not found');

    if (componentMap && componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && !id.scope) {
      componentWithDependencies.dependencies = [];
      componentWithDependencies.devDependencies = [];
    }

    const shouldWritePackageJson = async () => {
      if (!componentMap) return true;
      const rootDir = componentMap && componentMap.rootDir;
      if (!rootDir) return false;

      const packageJsonPath = _path().default.join(consumer.getPath(), rootDir, 'package.json');

      return _fsExtra().default.pathExists(packageJsonPath);
    };

    const shouldInstallNpmPackages = () => {
      if (componentMap && componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) return false;
      return true;
    };

    const writePackageJson = await shouldWritePackageJson();
    const files = componentWithDependencies.component.files;
    files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      filesStatus[(0, _utils().pathNormalizeToLinux)(file.relative)] = _mergeVersion().FileStatus.updated;
    });

    if (mergeResults) {
      // update files according to the merge results
      const {
        filesStatus: modifiedStatus,
        modifiedFiles
      } = (0, _checkoutVersion().applyModifiedVersion)(files, mergeResults, mergeStrategy, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      componentWithDependencies.component.originallySharedDir);
      componentWithDependencies.component.files = modifiedFiles;
      filesStatus = _objectSpread(_objectSpread({}, filesStatus), modifiedStatus);
    }

    const shouldDependenciesSaveAsComponents = await consumer.shouldDependenciesSavedAsComponents([id]);
    componentWithDependencies.component.dependenciesSavedAsComponents = shouldDependenciesSaveAsComponents[0].saveDependenciesAsComponents;
    const manyComponentsWriter = new (_manyComponentsWriter().default)({
      consumer,
      componentsWithDependencies: [componentWithDependencies],
      installNpmPackages: shouldInstallNpmPackages(),
      override: true,
      writeConfig: false,
      // @todo: should write if config exists before, needs to figure out how to do it.
      verbose: false,
      // @todo: do we need a flag here?
      writeDists: true,
      // @todo: do we need a flag here?
      writePackageJson
    });
    await manyComponentsWriter.writeAll(); // if mergeResults, the head snap is going to be updated on a later phase when snapping with two parents
    // otherwise, update the head of the current lane or main

    if (mergeResults) {
      if (mergeResults.hasConflicts && mergeStrategy === _mergeVersion().MergeOptions.manual) {
        unmergedComponent.resolved = false;
        unmergedComponent.unmergedPaths = mergeResults.modifiedFiles.filter(f => f.conflict).map(f => f.filePath);
      } else {
        unmergedComponent.resolved = true;
      }

      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);
    } else if (localLane) {
      localLane.addComponent({
        id,
        head: remoteHead
      });
    } else {
      // this is main
      const modelComponent = await consumer.scope.getModelComponent(id);
      if (!consumer.isLegacy) modelComponent.setHead(remoteHead);
      consumer.scope.objects.add(modelComponent);
    }

    return {
      id,
      filesStatus
    };
  }

  async abortMerge(consumer, values) {
    const ids = this.getIdsForUnresolved(consumer, values); // @ts-ignore not clear yet what to do with other flags

    const results = await (0, _checkoutVersion().default)(consumer, {
      ids,
      reset: true
    });
    ids.forEach(id => consumer.scope.objects.unmergedComponents.removeComponent(id.name));
    await consumer.scope.objects.unmergedComponents.write();
    return {
      abortedComponents: results.components
    };
  }

  async resolveMerge(consumer, values, snapMessage, build) {
    const ids = this.getIdsForUnresolved(consumer, values); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const {
      snappedComponents
    } = await this.snapping.snap({
      legacyBitIds: _bitId().BitIds.fromArray(ids),
      resolveUnmerged: true,
      build,
      message: snapMessage
    });
    return {
      resolvedComponents: snappedComponents
    };
  }

  async getAllComponentsStatus(bitIds, localLaneId, localLaneObject, remoteTrackedLane) {
    const tmp = new (_repositories().Tmp)(this.consumer.scope);

    try {
      const componentsStatus = await Promise.all(bitIds.map(async bitId => {
        const remoteLaneName = remoteTrackedLane ? remoteTrackedLane.remoteLane : localLaneId.name;
        const remoteScopeName = remoteTrackedLane ? remoteTrackedLane.remoteScope : bitId.scope;

        const remoteLaneId = _laneId().RemoteLaneId.from(remoteLaneName, remoteScopeName);

        const remoteHead = await this.consumer.scope.objects.remoteLanes.getRef(remoteLaneId, bitId);
        const remoteLaneIdStr = remoteLaneId.toString();
        if (!remoteHead) throw new (_generalError().default)(`unable to find a remote head of "${bitId.toStringWithoutVersion()}" in "${remoteLaneIdStr}"`);
        return this.getComponentMergeStatus(bitId.changeVersion(remoteHead.toString()), localLaneObject, remoteLaneIdStr);
      }));
      await tmp.clear();
      return componentsStatus;
    } catch (err) {
      await tmp.clear();
      throw err;
    }
  }

  async snapResolvedComponents(consumer, snapMessage, build) {
    const resolvedComponents = consumer.scope.objects.unmergedComponents.getResolvedComponents();

    _logger().default.debug(`merge-snaps, snapResolvedComponents, total ${resolvedComponents.length.toString()} components`);

    if (!resolvedComponents.length) return null;

    const ids = _bitId().BitIds.fromArray(resolvedComponents.map(r => new (_bitId().BitId)(r.id)));

    return this.snapping.snap({
      legacyBitIds: ids,
      build,
      message: snapMessage
    });
  }

  getIdsForUnresolved(consumer, idsStr) {
    if (idsStr && idsStr.length) {
      const bitIds = idsStr.map(id => consumer.getParsedId(id));
      bitIds.forEach(id => {
        const entry = consumer.scope.objects.unmergedComponents.getEntry(id.name);

        if (!entry) {
          throw new (_generalError().default)(`unable to merge-resolve ${id.toString()}, it is not marked as unresolved`);
        }
      });
      return bitIds;
    }

    const unresolvedComponents = consumer.scope.objects.unmergedComponents.getComponents();
    if (!unresolvedComponents.length) throw new (_generalError().default)(`all components are resolved already, nothing to do`);
    return unresolvedComponents.map(u => new (_bitId().BitId)(u.id));
  }

  getComponentsToMerge(consumer, ids) {
    if ((0, _hasWildcard().default)(ids)) {
      const componentsList = new (_componentsList().default)(consumer);
      return componentsList.listComponentsByIdsWithWildcard(ids);
    }

    return ids.map(id => consumer.getParsedId(id));
  }

  static async provider([cli, workspace, snapping]) {
    const merging = new MergingMain(workspace, snapping);
    cli.register(new (_mergeCmd().MergeCmd)(merging));
    return merging;
  }

}

exports.MergingMain = MergingMain;
(0, _defineProperty2().default)(MergingMain, "slots", []);
(0, _defineProperty2().default)(MergingMain, "dependencies", [_cli().CLIAspect, _workspace().default, _snapping().default]);
(0, _defineProperty2().default)(MergingMain, "runtime", _cli().MainRuntime);

_merging().MergingAspect.addRuntime(MergingMain);

//# sourceMappingURL=merging.main.runtime.js.map