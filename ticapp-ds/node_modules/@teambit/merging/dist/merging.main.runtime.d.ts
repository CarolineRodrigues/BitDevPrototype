import { CLIMain } from '@teambit/cli';
import { Workspace } from '@teambit/workspace';
import { Consumer } from '@teambit/legacy/dist/consumer';
import { ApplyVersionResults, MergeStrategy, ApplyVersionResult, FailedComponents } from '@teambit/legacy/dist/consumer/versions-ops/merge-version';
import { SnappingMain } from '@teambit/snapping';
import { BitId } from '@teambit/legacy/dist/bit-id';
import LaneId from '@teambit/legacy/dist/lane-id/lane-id';
import { AutoTagResult } from '@teambit/legacy/dist/scope/component-ops/auto-tag';
import { Lane, Version } from '@teambit/legacy/dist/scope/models';
import Component from '@teambit/legacy/dist/consumer/component/consumer-component';
import { MergeResultsThreeWay } from '@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge';
export declare type ComponentStatus = {
    componentFromFS?: Component | null;
    componentFromModel?: Version;
    id: BitId;
    failureMessage?: string;
    mergeResults?: MergeResultsThreeWay | null;
};
export declare class MergingMain {
    private workspace;
    private snapping;
    private consumer;
    constructor(workspace: Workspace, snapping: SnappingMain);
    /**
     * merge components according to the "values" param.
     * if the first param is a version, then merge the component ids to that version.
     * otherwise, merge from the remote head to the local.
     */
    merge(values: string[], mergeStrategy: MergeStrategy, abort: boolean, resolve: boolean, noSnap: boolean, message: string, build: boolean): Promise<ApplyVersionResults>;
    /**
     * when user is on main, it merges the remote main components into local.
     * when user is on a lane, it merges the remote lane components into the local lane.
     */
    mergeComponentsFromRemote(consumer: Consumer, bitIds: BitId[], mergeStrategy: MergeStrategy, noSnap: boolean, snapMessage: string, build: boolean): Promise<ApplyVersionResults>;
    /**
     * merge multiple components according to the "allComponentsStatus".
     */
    mergeSnaps({ mergeStrategy, allComponentsStatus, remoteName, laneId, localLane, noSnap, snapMessage, build, }: {
        mergeStrategy: MergeStrategy;
        allComponentsStatus: ComponentStatus[];
        remoteName: string | null;
        laneId: LaneId;
        localLane: Lane | null;
        noSnap: boolean;
        snapMessage: string;
        build: boolean;
    }): Promise<{
        components: ApplyVersionResult[];
        failedComponents: FailedComponents[];
        mergeSnapResults: {
            snappedComponents: Component[];
            autoSnappedResults: AutoTagResult[];
        } | null;
    }>;
    getComponentMergeStatus(id: BitId, localLane: Lane | null, otherLaneName: string, existingOnWorkspaceOnly?: boolean): Promise<ComponentStatus>;
    private applyVersion;
    private abortMerge;
    private resolveMerge;
    private getAllComponentsStatus;
    private snapResolvedComponents;
    private getIdsForUnresolved;
    private getComponentsToMerge;
    static slots: never[];
    static dependencies: import("@teambit/harmony").Aspect[];
    static runtime: import("@teambit/harmony").RuntimeDefinition;
    static provider([cli, workspace, snapping]: [CLIMain, Workspace, SnappingMain]): Promise<MergingMain>;
}
