{"version":3,"sources":["merging.main.runtime.ts"],"names":["MergingMain","constructor","workspace","snapping","consumer","merge","values","mergeStrategy","abort","resolve","noSnap","message","build","ConsumerNotFound","isLegacy","LanesIsDisabled","mergeResults","firstValue","R","head","resolveMerge","abortMerge","BitId","isValidVersion","bitIds","getComponentsToMerge","mergeComponentsFromRemote","version","ids","tail","onDestroy","snapMessage","localLaneId","getCurrentLaneId","localLaneObject","getCurrentLaneObject","remoteTrackedLane","scope","lanes","getRemoteTrackedDataByLocalLane","name","isDefault","Error","allComponentsStatus","getAllComponentsStatus","mergeSnaps","remoteName","remoteScope","laneId","localLane","componentWithConflict","find","component","hasConflicts","failedComponents","filter","componentStatus","failureMessage","map","id","succeededComponents","componentsResults","componentFromFS","applyVersion","remoteHead","Ref","objects","add","persist","unmergedComponents","write","mergeSnapResults","snapResolvedComponents","components","getComponentMergeStatus","otherLaneName","existingOnWorkspaceOnly","returnFailure","msg","modelComponent","getModelComponentIfExist","GeneralError","toString","unmerged","getEntry","resolved","toStringWithoutVersion","existingBitMapId","bitMap","getBitIdIfExist","ignoreVersion","componentOnLane","loadVersion","componentFromModel","currentlyUsedVersion","hasHead","loadComponent","componentModificationStatus","getComponentStatusById","modified","repo","laneHeadIsDifferentThanCheckedOut","laneHeadLocal","localHead","from","otherLaneHead","divergeData","isDiverged","isLocalAhead","isRemoteAhead","baseSnap","commonSnapBeforeDiverge","baseComponent","otherComponent","otherLabel","currentComponent","currentLabel","filesStatus","unmergedComponent","remote","lane","MergeOptions","ours","files","forEach","file","relative","FileStatus","unchanged","addEntry","remoteId","changeVersion","idToLoad","theirs","componentWithDependencies","loadComponentWithDependenciesFromModel","componentMap","origin","COMPONENT_ORIGINS","AUTHORED","dependencies","devDependencies","shouldWritePackageJson","rootDir","packageJsonPath","path","join","getPath","fs","pathExists","shouldInstallNpmPackages","writePackageJson","updated","modifiedStatus","modifiedFiles","originallySharedDir","shouldDependenciesSaveAsComponents","shouldDependenciesSavedAsComponents","dependenciesSavedAsComponents","saveDependenciesAsComponents","manyComponentsWriter","ManyComponentsWriter","componentsWithDependencies","installNpmPackages","override","writeConfig","verbose","writeDists","writeAll","manual","unmergedPaths","f","conflict","filePath","addComponent","getModelComponent","setHead","getIdsForUnresolved","results","reset","removeComponent","abortedComponents","snappedComponents","snap","legacyBitIds","BitIds","fromArray","resolveUnmerged","resolvedComponents","tmp","Tmp","componentsStatus","Promise","all","bitId","remoteLaneName","remoteLane","remoteScopeName","remoteLaneId","RemoteLaneId","remoteLanes","getRef","remoteLaneIdStr","clear","err","getResolvedComponents","logger","debug","length","r","idsStr","getParsedId","entry","unresolvedComponents","getComponents","u","componentsList","ComponentsList","listComponentsByIdsWithWildcard","provider","cli","merging","register","MergeCmd","CLIAspect","WorkspaceAspect","SnappingAspect","MainRuntime","MergingAspect","addRuntime"],"mappings":"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","sourcesContent":["import { CLIAspect, CLIMain, MainRuntime } from '@teambit/cli';\nimport WorkspaceAspect, { Workspace } from '@teambit/workspace';\nimport R from 'ramda';\nimport { Consumer } from '@teambit/legacy/dist/consumer';\nimport ComponentsList from '@teambit/legacy/dist/consumer/component/components-list';\nimport { LanesIsDisabled } from '@teambit/legacy/dist/consumer/lanes/exceptions/lanes-is-disabled';\nimport {\n  ApplyVersionResults,\n  MergeStrategy,\n  mergeVersion,\n  ApplyVersionResult,\n  FailedComponents,\n  FileStatus,\n  getMergeStrategyInteractive,\n  MergeOptions,\n} from '@teambit/legacy/dist/consumer/versions-ops/merge-version';\nimport { ConsumerNotFound } from '@teambit/legacy/dist/consumer/exceptions';\nimport SnappingAspect, { SnappingMain } from '@teambit/snapping';\nimport hasWildcard from '@teambit/legacy/dist/utils/string/has-wildcard';\nimport fs from 'fs-extra';\nimport mapSeries from 'p-map-series';\nimport path from 'path';\nimport { BitId, BitIds } from '@teambit/legacy/dist/bit-id';\nimport { COMPONENT_ORIGINS } from '@teambit/legacy/dist/constants';\nimport GeneralError from '@teambit/legacy/dist/error/general-error';\nimport LaneId, { LocalLaneId, RemoteLaneId } from '@teambit/legacy/dist/lane-id/lane-id';\nimport logger from '@teambit/legacy/dist/logger/logger';\nimport { AutoTagResult } from '@teambit/legacy/dist/scope/component-ops/auto-tag';\nimport { getDivergeData } from '@teambit/legacy/dist/scope/component-ops/get-diverge-data';\nimport { UnmergedComponent } from '@teambit/legacy/dist/scope/lanes/unmerged-components';\nimport { Lane, Version } from '@teambit/legacy/dist/scope/models';\nimport { Ref } from '@teambit/legacy/dist/scope/objects';\nimport { Tmp } from '@teambit/legacy/dist/scope/repositories';\nimport { pathNormalizeToLinux } from '@teambit/legacy/dist/utils';\nimport ManyComponentsWriter from '@teambit/legacy/dist/consumer/component-ops/many-components-writer';\nimport Component from '@teambit/legacy/dist/consumer/component/consumer-component';\nimport checkoutVersion, { applyModifiedVersion } from '@teambit/legacy/dist/consumer/versions-ops/checkout-version';\nimport threeWayMerge, {\n  MergeResultsThreeWay,\n} from '@teambit/legacy/dist/consumer/versions-ops/merge-version/three-way-merge';\nimport { TrackLane } from '@teambit/legacy/dist/scope/scope-json';\nimport { MergeCmd } from './merge-cmd';\nimport { MergingAspect } from './merging.aspect';\n\nexport type ComponentStatus = {\n  componentFromFS?: Component | null;\n  componentFromModel?: Version;\n  id: BitId;\n  failureMessage?: string;\n  mergeResults?: MergeResultsThreeWay | null;\n};\n\nexport class MergingMain {\n  private consumer: Consumer;\n  constructor(private workspace: Workspace, private snapping: SnappingMain) {\n    this.consumer = this.workspace?.consumer;\n  }\n\n  /**\n   * merge components according to the \"values\" param.\n   * if the first param is a version, then merge the component ids to that version.\n   * otherwise, merge from the remote head to the local.\n   */\n  async merge(\n    values: string[],\n    mergeStrategy: MergeStrategy,\n    abort: boolean,\n    resolve: boolean,\n    noSnap: boolean,\n    message: string,\n    build: boolean\n  ): Promise<ApplyVersionResults> {\n    if (!this.workspace) throw new ConsumerNotFound();\n    const consumer: Consumer = this.workspace.consumer;\n    if (consumer.isLegacy && (noSnap || message || abort || resolve)) {\n      throw new LanesIsDisabled();\n    }\n    let mergeResults;\n    const firstValue = R.head(values);\n    if (resolve) {\n      mergeResults = await this.resolveMerge(consumer, values, message, build);\n    } else if (abort) {\n      mergeResults = await this.abortMerge(consumer, values);\n    } else if (!BitId.isValidVersion(firstValue)) {\n      const bitIds = this.getComponentsToMerge(consumer, values);\n      // @todo: version could be the lane only or remote/lane\n      mergeResults = await this.mergeComponentsFromRemote(consumer, bitIds, mergeStrategy, noSnap, message, build);\n    } else {\n      const version = firstValue;\n      const ids = R.tail(values);\n      const bitIds = this.getComponentsToMerge(consumer, ids);\n      mergeResults = await mergeVersion(consumer, version, bitIds, mergeStrategy);\n    }\n    await consumer.onDestroy();\n    return mergeResults;\n  }\n\n  /**\n   * when user is on main, it merges the remote main components into local.\n   * when user is on a lane, it merges the remote lane components into the local lane.\n   */\n  async mergeComponentsFromRemote(\n    consumer: Consumer,\n    bitIds: BitId[],\n    mergeStrategy: MergeStrategy,\n    noSnap: boolean,\n    snapMessage: string,\n    build: boolean\n  ): Promise<ApplyVersionResults> {\n    const localLaneId = consumer.getCurrentLaneId();\n    const localLaneObject = await consumer.getCurrentLaneObject();\n    const remoteTrackedLane = consumer.scope.lanes.getRemoteTrackedDataByLocalLane(localLaneId.name);\n    if (!localLaneId.isDefault() && !remoteTrackedLane) {\n      throw new Error(`unable to find a remote tracked to the local lane \"${localLaneId.name}\"`);\n    }\n    const allComponentsStatus = await this.getAllComponentsStatus(\n      bitIds,\n      localLaneId,\n      localLaneObject,\n      remoteTrackedLane\n    );\n\n    return this.mergeSnaps({\n      mergeStrategy,\n      allComponentsStatus,\n      remoteName: remoteTrackedLane ? remoteTrackedLane.remoteScope : null,\n      laneId: localLaneId,\n      localLane: localLaneObject,\n      noSnap,\n      snapMessage,\n      build,\n    });\n  }\n\n  /**\n   * merge multiple components according to the \"allComponentsStatus\".\n   */\n  async mergeSnaps({\n    mergeStrategy,\n    allComponentsStatus,\n    remoteName,\n    laneId,\n    localLane,\n    noSnap,\n    snapMessage,\n    build,\n  }: {\n    mergeStrategy: MergeStrategy;\n    allComponentsStatus: ComponentStatus[];\n    remoteName: string | null;\n    laneId: LaneId;\n    localLane: Lane | null;\n    noSnap: boolean;\n    snapMessage: string;\n    build: boolean;\n  }) {\n    const consumer = this.workspace.consumer;\n    const componentWithConflict = allComponentsStatus.find(\n      (component) => component.mergeResults && component.mergeResults.hasConflicts\n    );\n    if (componentWithConflict && !mergeStrategy) {\n      mergeStrategy = await getMergeStrategyInteractive();\n    }\n    const failedComponents: FailedComponents[] = allComponentsStatus\n      .filter((componentStatus) => componentStatus.failureMessage)\n      .map((componentStatus) => ({ id: componentStatus.id, failureMessage: componentStatus.failureMessage as string }));\n    const succeededComponents = allComponentsStatus.filter((componentStatus) => !componentStatus.failureMessage);\n    // do not use Promise.all for applyVersion. otherwise, it'll write all components in parallel,\n    // which can be an issue when some components are also dependencies of others\n    const componentsResults = await mapSeries(succeededComponents, ({ componentFromFS, id, mergeResults }) => {\n      return this.applyVersion({\n        consumer,\n        componentFromFS,\n        id,\n        mergeResults,\n        mergeStrategy,\n        remoteHead: new Ref(id.version as string),\n        // @ts-ignore\n        remoteName: remoteName || componentFromFS.scope,\n        laneId,\n        localLane,\n      });\n    });\n\n    if (localLane) consumer.scope.objects.add(localLane);\n\n    await consumer.scope.objects.persist(); // persist anyway, it localLane is null it should save all main heads\n\n    await consumer.scope.objects.unmergedComponents.write();\n\n    const mergeSnapResults = noSnap ? null : await this.snapResolvedComponents(consumer, snapMessage, build);\n\n    return { components: componentsResults, failedComponents, mergeSnapResults };\n  }\n\n  async getComponentMergeStatus(\n    id: BitId,\n    localLane: Lane | null,\n    otherLaneName: string,\n    existingOnWorkspaceOnly = false\n  ): Promise<ComponentStatus> {\n    const consumer = this.workspace.consumer;\n    const componentStatus: ComponentStatus = { id };\n    const returnFailure = (msg: string) => {\n      componentStatus.failureMessage = msg;\n      return componentStatus;\n    };\n    const modelComponent = await consumer.scope.getModelComponentIfExist(id);\n    if (!modelComponent) {\n      throw new GeneralError(\n        `component ${id.toString()} is on the lane but its objects were not found, please re-import the lane`\n      );\n    }\n    const unmerged = consumer.scope.objects.unmergedComponents.getEntry(id.name);\n    if (unmerged && unmerged.resolved === false) {\n      return returnFailure(\n        `component ${id.toStringWithoutVersion()} has conflicts that need to be resolved first, please use bit merge --resolve/--abort`\n      );\n    }\n    const version = id.version as string;\n    const existingBitMapId = consumer.bitMap.getBitIdIfExist(id, { ignoreVersion: true });\n    const componentOnLane: Version = await modelComponent.loadVersion(version, consumer.scope.objects);\n    if (!existingBitMapId) {\n      if (existingOnWorkspaceOnly) {\n        return returnFailure(`component ${id.toStringWithoutVersion()} is not in the workspace`);\n      }\n      // @ts-ignore\n      return { componentFromFS: null, componentFromModel: componentOnLane, id, mergeResults: null };\n    }\n    const currentlyUsedVersion = existingBitMapId.version;\n    if (currentlyUsedVersion === version) {\n      // @todo: maybe this check is not needed as we check for diverge later on\n      if (localLane || modelComponent.hasHead()) {\n        return returnFailure(`component ${id.toStringWithoutVersion()} is already merged`);\n      }\n    }\n    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n    const component = await consumer.loadComponent(existingBitMapId);\n    const componentModificationStatus = await consumer.getComponentStatusById(component.id);\n    if (componentModificationStatus.modified) {\n      throw new GeneralError(\n        `unable to merge ${id.toStringWithoutVersion()}, the component is modified, please snap/tag it first`\n      );\n    }\n    const repo = consumer.scope.objects;\n    const laneHeadIsDifferentThanCheckedOut =\n      localLane && currentlyUsedVersion && modelComponent.laneHeadLocal?.toString() !== currentlyUsedVersion;\n    const localHead = laneHeadIsDifferentThanCheckedOut ? Ref.from(currentlyUsedVersion) : null;\n\n    const otherLaneHead = new Ref(version);\n    const divergeData = await getDivergeData(repo, modelComponent, otherLaneHead, localHead);\n    if (!divergeData.isDiverged()) {\n      if (divergeData.isLocalAhead()) {\n        // do nothing!\n        return returnFailure(`component ${component.id.toString()} is ahead, nothing to merge`);\n      }\n      if (divergeData.isRemoteAhead()) {\n        // just override with the model data\n        return {\n          componentFromFS: component,\n          componentFromModel: componentOnLane,\n          id,\n          mergeResults: null,\n        };\n      }\n      // we know that localHead and remoteHead are set, so if none of them is ahead they must be equal\n      return returnFailure(`component ${component.id.toString()} is already merged`);\n    }\n    const baseSnap = divergeData.commonSnapBeforeDiverge as Ref; // must be set when isTrueMerge\n    const baseComponent: Version = await modelComponent.loadVersion(baseSnap.toString(), repo);\n    const otherComponent: Version = await modelComponent.loadVersion(otherLaneHead.toString(), repo);\n    const mergeResults = await threeWayMerge({\n      consumer,\n      otherComponent,\n      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n      otherLabel: `${otherLaneHead.toString()} (${otherLaneName})`,\n      currentComponent: component,\n      currentLabel: `${currentlyUsedVersion} (local)`,\n      baseComponent,\n    });\n    return { componentFromFS: component, id, mergeResults };\n  }\n\n  private async applyVersion({\n    consumer,\n    componentFromFS,\n    id,\n    mergeResults,\n    mergeStrategy,\n    remoteHead,\n    remoteName,\n    laneId,\n    localLane,\n  }: {\n    consumer: Consumer;\n    componentFromFS: Component | null | undefined;\n    id: BitId;\n    mergeResults: MergeResultsThreeWay | null | undefined;\n    mergeStrategy: MergeStrategy;\n    remoteHead: Ref;\n    remoteName: string | null;\n    laneId: LaneId;\n    localLane: Lane | null;\n  }): Promise<ApplyVersionResult> {\n    let filesStatus = {};\n    const unmergedComponent: UnmergedComponent = {\n      // @ts-ignore\n      id: { name: id.name, scope: id.scope },\n      // @ts-ignore\n      head: remoteHead,\n      // @ts-ignore\n      remote: remoteName,\n      lane: laneId.name,\n      resolved: false, // could be changed later\n    };\n    id = componentFromFS ? componentFromFS.id : id;\n    if (mergeResults && mergeResults.hasConflicts && mergeStrategy === MergeOptions.ours) {\n      if (!componentFromFS) throw new Error(`applyVersion expect to get componentFromFS for ${id.toString()}`);\n      componentFromFS.files.forEach((file) => {\n        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n        filesStatus[pathNormalizeToLinux(file.relative)] = FileStatus.unchanged;\n      });\n      unmergedComponent.resolved = true;\n      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);\n\n      return { id, filesStatus };\n    }\n    const remoteId = id.changeVersion(remoteHead.toString());\n    const idToLoad = !mergeResults || mergeStrategy === MergeOptions.theirs ? remoteId : id;\n    const componentWithDependencies = await consumer.loadComponentWithDependenciesFromModel(idToLoad);\n    const componentMap = componentFromFS && componentFromFS.componentMap;\n    if (componentFromFS && !componentMap) throw new GeneralError('applyVersion: componentMap was not found');\n    if (componentMap && componentMap.origin === COMPONENT_ORIGINS.AUTHORED && !id.scope) {\n      componentWithDependencies.dependencies = [];\n      componentWithDependencies.devDependencies = [];\n    }\n    const shouldWritePackageJson = async (): Promise<boolean> => {\n      if (!componentMap) return true;\n      const rootDir = componentMap && componentMap.rootDir;\n      if (!rootDir) return false;\n      const packageJsonPath = path.join(consumer.getPath(), rootDir, 'package.json');\n      return fs.pathExists(packageJsonPath);\n    };\n    const shouldInstallNpmPackages = (): boolean => {\n      if (componentMap && componentMap.origin === COMPONENT_ORIGINS.AUTHORED) return false;\n      return true;\n    };\n    const writePackageJson = await shouldWritePackageJson();\n\n    const files = componentWithDependencies.component.files;\n    files.forEach((file) => {\n      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n      filesStatus[pathNormalizeToLinux(file.relative)] = FileStatus.updated;\n    });\n\n    if (mergeResults) {\n      // update files according to the merge results\n      const { filesStatus: modifiedStatus, modifiedFiles } = applyModifiedVersion(\n        files,\n        mergeResults,\n        mergeStrategy,\n        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n        componentWithDependencies.component.originallySharedDir\n      );\n      componentWithDependencies.component.files = modifiedFiles;\n      filesStatus = { ...filesStatus, ...modifiedStatus };\n    }\n    const shouldDependenciesSaveAsComponents = await consumer.shouldDependenciesSavedAsComponents([id]);\n    componentWithDependencies.component.dependenciesSavedAsComponents =\n      shouldDependenciesSaveAsComponents[0].saveDependenciesAsComponents;\n\n    const manyComponentsWriter = new ManyComponentsWriter({\n      consumer,\n      componentsWithDependencies: [componentWithDependencies],\n      installNpmPackages: shouldInstallNpmPackages(),\n      override: true,\n      writeConfig: false, // @todo: should write if config exists before, needs to figure out how to do it.\n      verbose: false, // @todo: do we need a flag here?\n      writeDists: true, // @todo: do we need a flag here?\n      writePackageJson,\n    });\n    await manyComponentsWriter.writeAll();\n\n    // if mergeResults, the head snap is going to be updated on a later phase when snapping with two parents\n    // otherwise, update the head of the current lane or main\n    if (mergeResults) {\n      if (mergeResults.hasConflicts && mergeStrategy === MergeOptions.manual) {\n        unmergedComponent.resolved = false;\n        unmergedComponent.unmergedPaths = mergeResults.modifiedFiles.filter((f) => f.conflict).map((f) => f.filePath);\n      } else {\n        unmergedComponent.resolved = true;\n      }\n      consumer.scope.objects.unmergedComponents.addEntry(unmergedComponent);\n    } else if (localLane) {\n      localLane.addComponent({ id, head: remoteHead });\n    } else {\n      // this is main\n      const modelComponent = await consumer.scope.getModelComponent(id);\n      if (!consumer.isLegacy) modelComponent.setHead(remoteHead);\n      consumer.scope.objects.add(modelComponent);\n    }\n\n    return { id, filesStatus };\n  }\n\n  private async abortMerge(consumer: Consumer, values: string[]): Promise<ApplyVersionResults> {\n    const ids = this.getIdsForUnresolved(consumer, values);\n    // @ts-ignore not clear yet what to do with other flags\n    const results = await checkoutVersion(consumer, { ids, reset: true });\n    ids.forEach((id) => consumer.scope.objects.unmergedComponents.removeComponent(id.name));\n    await consumer.scope.objects.unmergedComponents.write();\n    return { abortedComponents: results.components };\n  }\n\n  private async resolveMerge(\n    consumer: Consumer,\n    values: string[],\n    snapMessage: string,\n    build: boolean\n  ): Promise<ApplyVersionResults> {\n    const ids = this.getIdsForUnresolved(consumer, values);\n    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!\n    const { snappedComponents } = await this.snapping.snap({\n      legacyBitIds: BitIds.fromArray(ids),\n      resolveUnmerged: true,\n      build,\n      message: snapMessage,\n    });\n    return { resolvedComponents: snappedComponents };\n  }\n\n  private async getAllComponentsStatus(\n    bitIds: BitId[],\n    localLaneId: LocalLaneId,\n    localLaneObject: Lane | null,\n    remoteTrackedLane?: TrackLane\n  ): Promise<ComponentStatus[]> {\n    const tmp = new Tmp(this.consumer.scope);\n    try {\n      const componentsStatus = await Promise.all(\n        bitIds.map(async (bitId) => {\n          const remoteLaneName = remoteTrackedLane ? remoteTrackedLane.remoteLane : localLaneId.name;\n          const remoteScopeName = remoteTrackedLane ? remoteTrackedLane.remoteScope : bitId.scope;\n          const remoteLaneId = RemoteLaneId.from(remoteLaneName, remoteScopeName as string);\n          const remoteHead = await this.consumer.scope.objects.remoteLanes.getRef(remoteLaneId, bitId);\n          const remoteLaneIdStr = remoteLaneId.toString();\n          if (!remoteHead)\n            throw new GeneralError(\n              `unable to find a remote head of \"${bitId.toStringWithoutVersion()}\" in \"${remoteLaneIdStr}\"`\n            );\n          return this.getComponentMergeStatus(\n            bitId.changeVersion(remoteHead.toString()),\n            localLaneObject,\n            remoteLaneIdStr\n          );\n        })\n      );\n      await tmp.clear();\n      return componentsStatus;\n    } catch (err: any) {\n      await tmp.clear();\n      throw err;\n    }\n  }\n\n  private async snapResolvedComponents(\n    consumer: Consumer,\n    snapMessage: string,\n    build: boolean\n  ): Promise<null | { snappedComponents: Component[]; autoSnappedResults: AutoTagResult[] }> {\n    const resolvedComponents = consumer.scope.objects.unmergedComponents.getResolvedComponents();\n    logger.debug(`merge-snaps, snapResolvedComponents, total ${resolvedComponents.length.toString()} components`);\n    if (!resolvedComponents.length) return null;\n    const ids = BitIds.fromArray(resolvedComponents.map((r) => new BitId(r.id)));\n    return this.snapping.snap({\n      legacyBitIds: ids,\n      build,\n      message: snapMessage,\n    });\n  }\n\n  private getIdsForUnresolved(consumer: Consumer, idsStr?: string[]): BitId[] {\n    if (idsStr && idsStr.length) {\n      const bitIds = idsStr.map((id) => consumer.getParsedId(id));\n      bitIds.forEach((id) => {\n        const entry = consumer.scope.objects.unmergedComponents.getEntry(id.name);\n        if (!entry) {\n          throw new GeneralError(`unable to merge-resolve ${id.toString()}, it is not marked as unresolved`);\n        }\n      });\n      return bitIds;\n    }\n    const unresolvedComponents = consumer.scope.objects.unmergedComponents.getComponents();\n    if (!unresolvedComponents.length) throw new GeneralError(`all components are resolved already, nothing to do`);\n    return unresolvedComponents.map((u) => new BitId(u.id));\n  }\n\n  private getComponentsToMerge(consumer: Consumer, ids: string[]): BitId[] {\n    if (hasWildcard(ids)) {\n      const componentsList = new ComponentsList(consumer);\n      return componentsList.listComponentsByIdsWithWildcard(ids);\n    }\n    return ids.map((id) => consumer.getParsedId(id));\n  }\n\n  static slots = [];\n  static dependencies = [CLIAspect, WorkspaceAspect, SnappingAspect];\n  static runtime = MainRuntime;\n  static async provider([cli, workspace, snapping]: [CLIMain, Workspace, SnappingMain]) {\n    const merging = new MergingMain(workspace, snapping);\n    cli.register(new MergeCmd(merging));\n    return merging;\n  }\n}\n\nMergingAspect.addRuntime(MergingMain);\n"]}