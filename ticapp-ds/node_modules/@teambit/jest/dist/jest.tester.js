"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JestTester = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = require("fs-extra");

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _minimatch() {
  const data = _interopRequireDefault(require("minimatch"));

  _minimatch = function () {
    return data;
  };

  return data;
}

function _lodash() {
  const data = require("lodash");

  _lodash = function () {
    return data;
  };

  return data;
}

function _comlink() {
  const data = require("comlink");

  _comlink = function () {
    return data;
  };

  return data;
}

function _tester() {
  const data = require("@teambit/tester");

  _tester = function () {
    return data;
  };

  return data;
}

function _testsResults() {
  const data = require("@teambit/tests-results");

  _testsResults = function () {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  const data = require("jest-message-util");

  _jestMessageUtil = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("@teambit/legacy/dist/consumer/component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _error() {
  const data = require("./error");

  _error = function () {
    return data;
  };

  return data;
}

class JestTester {
  constructor(id, jestConfig, jestModulePath, jestWorker, logger) {
    this.id = id;
    this.jestConfig = jestConfig;
    this.jestModulePath = jestModulePath;
    this.jestWorker = jestWorker;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "jestModule", void 0);
    (0, _defineProperty2().default)(this, "configPath", this.jestConfig);
    (0, _defineProperty2().default)(this, "displayName", 'Jest');
    (0, _defineProperty2().default)(this, "_callback", void 0);
    // eslint-disable-next-line global-require,import/no-dynamic-require
    this.jestModule = require(jestModulePath);
  }

  displayConfig() {
    return (0, _fsExtra().readFileSync)(this.jestConfig, 'utf8');
  }

  version() {
    return this.jestModule.getVersion();
  } // private getTestFile(path: string, testerContext: TesterContext): AbstractVinyl | undefined {
  //   return testerContext.specFiles.toArray().reduce((acc: AbstractVinyl | undefined, [, specs]) => {
  //     const file = specs.find((spec) => spec.path === path);
  //     if (file) acc = file;
  //     return acc;
  //   }, undefined);
  // }


  attachTestsToComponent(testerContext, testResult) {
    return _component().ComponentMap.as(testerContext.components, component => {
      const componentSpecFiles = testerContext.patterns.get(component);
      if (!componentSpecFiles) return undefined;
      const [, specs] = componentSpecFiles;
      return testResult.filter(test => {
        return specs.filter(pattern => (0, _minimatch().default)(test.testFilePath, pattern.path)).length > 0;
      });
    });
  }

  buildTestsObj(aggregatedResult, components, testerContext, config) {
    const testsSuiteResult = components.toArray().map(([component, testsFiles]) => {
      if (!testsFiles) return undefined;
      if ((testsFiles === null || testsFiles === void 0 ? void 0 : testsFiles.length) === 0) return undefined;
      const errors = this.getErrors(testsFiles);
      const tests = testsFiles.map(test => {
        const file = new (_sources().AbstractVinyl)({
          path: test.testFilePath,
          contents: (0, _fsExtra().readFileSync)(test.testFilePath)
        });
        const testResults = test.testResults.map(testResult => {
          const error = (0, _jestMessageUtil().formatResultsErrors)([testResult], config, {
            noStackTrace: true
          }) || undefined;
          const isFailure = testResult.status === 'failed';
          return new (_testsResults().TestResult)(testResult.ancestorTitles, testResult.title, testResult.status, testResult.duration, isFailure ? undefined : error, isFailure ? error : undefined);
        });
        const filePath = (file === null || file === void 0 ? void 0 : file.basename) || test.testFilePath;

        const getError = () => {
          var _test$testExecError, _test$testExecError2;

          if (!test.testExecError) return undefined;

          if (testerContext.watch) {
            // for some reason, during watch ('bit start'), if a file has an error, the `test.testExecError` is `{}`
            // (an empty object). the failureMessage contains the stringified error.
            // @todo: consider to always use the failureMessage, regardless the context.watch.
            return new (_error().JestError)(test.failureMessage);
          }

          return new (_error().JestError)((_test$testExecError = test.testExecError) === null || _test$testExecError === void 0 ? void 0 : _test$testExecError.message, (_test$testExecError2 = test.testExecError) === null || _test$testExecError2 === void 0 ? void 0 : _test$testExecError2.stack);
        };

        const error = getError();
        return new (_testsResults().TestsFiles)(filePath, testResults, test.numPassingTests, test.numFailingTests, test.numPendingTests, test.perfStats.runtime, test.perfStats.slow, error);
      });
      return {
        componentId: component.id,
        results: new (_testsResults().TestsResult)(tests, aggregatedResult.success, aggregatedResult.startTime),
        errors
      };
    });
    return (0, _lodash().compact)(testsSuiteResult);
  }

  getErrors(testResult) {
    return testResult.reduce((errors, test) => {
      if (test.testExecError) {
        const {
          message,
          stack,
          code,
          type
        } = test.testExecError;
        errors.push(new (_error().JestError)(message, stack, code, type));
      } else if (test.failureMessage) {
        errors.push(new (_error().JestError)(test.failureMessage));
      }

      return errors;
    }, []);
  }

  async onTestRunComplete(callback) {
    this._callback = callback;
  }

  async test(context) {
    const config = {
      rootDir: context.rootPath
    }; // eslint-disable-next-line no-console

    console.warn = message => {
      this.logger.warn(message);
    };

    if (context.debug) config.runInBand = true;
    if (context.coverage) config.coverage = true;
    config.runInBand = true;

    if (context.watch) {
      config.watchAll = true;
      config.noCache = true;
    } // eslint-disable-next-line global-require,import/no-dynamic-require


    const jestConfig = require(this.jestConfig);

    const jestConfigWithSpecs = Object.assign(jestConfig, {
      testMatch: this.patternsToArray(context.patterns)
    });
    const withEnv = Object.assign(jestConfigWithSpecs, config);
    const testsOutPut = await this.jestModule.runCLI(withEnv, [this.jestConfig]);
    const testResults = testsOutPut.results.testResults;
    const componentsWithTests = this.attachTestsToComponent(context, testResults);
    const componentTestResults = this.buildTestsObj(testsOutPut.results, componentsWithTests, context, jestConfigWithSpecs);
    return new (_tester().Tests)(componentTestResults);
  }

  async watch(context) {
    // eslint-disable-next-line
    return new Promise(async resolve => {
      const workerApi = this.jestWorker.initiate(context.ui ? {
        stdout: true,
        stderr: true,
        stdin: true
      } : {
        stdout: false,
        stderr: false,
        stdin: false
      }); // eslint-disable-next-line

      const jestConfig = require(this.jestConfig);

      const jestConfigWithSpecs = Object.assign(jestConfig, {
        testMatch: this.patternsToArray(context.patterns)
      });

      try {
        const cbFn = (0, _comlink().proxy)(results => {
          if (!this._callback) return;
          const testResults = results.testResults;
          const componentsWithTests = this.attachTestsToComponent(context, testResults);
          const componentTestResults = this.buildTestsObj(results, componentsWithTests, context, jestConfigWithSpecs);
          const globalErrors = this.getErrors(testResults);
          const watchTestResults = {
            loading: false,
            errors: globalErrors,
            components: componentTestResults
          };

          this._callback(watchTestResults);

          resolve(watchTestResults);
        }); // eslint-disable-next-line @typescript-eslint/no-floating-promises

        await workerApi.onTestComplete(cbFn);
        await workerApi.watch(this.jestConfig, this.patternsToArray(context.patterns), context.rootPath, this.jestModulePath);
      } catch (err) {
        this.logger.error('jest.tester.watch() caught an error', err);
      }
    });
  }

  patternsToArray(patterns) {
    return (0, _lodash().flatten)(patterns.toArray().map(([, pattern]) => pattern.map(p => p.path)));
  }

}

exports.JestTester = JestTester;

//# sourceMappingURL=jest.tester.js.map