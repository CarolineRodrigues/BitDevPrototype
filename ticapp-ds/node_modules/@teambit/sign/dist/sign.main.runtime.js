"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignMain = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _harmony() {
  const data = require("@teambit/harmony");

  _harmony = function () {
    return data;
  };

  return data;
}

function _cli() {
  const data = require("@teambit/cli");

  _cli = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = require("@teambit/logger");

  _logger = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("@teambit/scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _builder() {
  const data = require("@teambit/builder");

  _builder = function () {
    return data;
  };

  return data;
}

function _tagModelComponent() {
  const data = require("@teambit/legacy/dist/scope/component-ops/tag-model-component");

  _tagModelComponent = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _scopeRemotes() {
  const data = require("@teambit/legacy/dist/scope/scope-remotes");

  _scopeRemotes = function () {
    return data;
  };

  return data;
}

function _actions() {
  const data = require("@teambit/legacy/dist/scope/actions");

  _actions = function () {
    return data;
  };

  return data;
}

function _objectList() {
  const data = require("@teambit/legacy/dist/scope/objects/object-list");

  _objectList = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("@teambit/legacy/dist/bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _sign() {
  const data = require("./sign.cmd");

  _sign = function () {
    return data;
  };

  return data;
}

function _sign2() {
  const data = require("./sign.aspect");

  _sign2 = function () {
    return data;
  };

  return data;
}

class SignMain {
  constructor(scope, logger, builder, onPostSignSlot) {
    this.scope = scope;
    this.logger = logger;
    this.builder = builder;
    this.onPostSignSlot = onPostSignSlot;
  }

  async sign(ids, isMultiple, push) {
    if (isMultiple) await this.scope.import(ids);
    const {
      componentsToSkip,
      componentsToSign
    } = await this.getComponentIdsToSign(ids);

    if (ids.length && componentsToSkip.length) {
      // eslint-disable-next-line no-console
      console.log(`the following component(s) were already signed successfully:
${componentsToSkip.map(c => c.toString()).join('\n')}\n`);
    }

    if (!componentsToSign.length) {
      return null;
    }

    const components = await this.scope.getMany(componentsToSign);
    const {
      builderDataMap,
      pipeResults
    } = await this.builder.tagListener(components, {
      throwOnError: false
    }, {
      seedersOnly: true,
      installOptions: {
        copyPeerToRuntimeOnComponents: true,
        installPeersFromEnvs: true
      }
    });
    const legacyBuildResults = this.scope.builderDataMapToLegacyOnTagResults(builderDataMap);
    const legacyComponents = components.map(c => c.state._consumer);
    (0, _tagModelComponent().updateComponentsByTagResult)(legacyComponents, legacyBuildResults);
    const publishedPackages = (0, _tagModelComponent().getPublishedPackages)(legacyComponents);
    const pipeWithError = pipeResults.find(pipe => pipe.hasErrors());
    const buildStatus = pipeWithError ? _constants().BuildStatus.Failed : _constants().BuildStatus.Succeed;

    if (push) {
      if (isMultiple) {
        await this.exportExtensionsDataIntoScopes(legacyComponents, buildStatus);
      } else {
        await this.saveExtensionsDataIntoScope(legacyComponents, buildStatus);
      }

      await this.clearScopesCaches(legacyComponents);
    }

    await this.triggerOnPostSign(components);
    return {
      components,
      publishedPackages,
      error: pipeWithError ? pipeWithError.getErrorMessageFormatted() : null
    };
  }

  registerOnPostSign(fn) {
    this.onPostSignSlot.register(fn);
  }

  async triggerOnPostSign(components) {
    await Promise.all(this.onPostSignSlot.values().map(fn => fn(components))).catch(err => {
      this.logger.error('failed running onPostSignSlot', err);
    });
  }

  async clearScopesCaches(components) {
    const bitIds = _bitId().BitIds.fromArray(components.map(c => c.id));

    const idsGroupedByScope = bitIds.toGroupByScopeName(new (_bitId().BitIds)());
    const scopeRemotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope.legacyScope);
    await Promise.all(Object.keys(idsGroupedByScope).map(async scopeName => {
      const remote = await scopeRemotes.resolve(scopeName, this.scope.legacyScope);
      return remote.action(_actions().PostSign.name, {
        ids: idsGroupedByScope[scopeName].map(id => id.toString())
      });
    }));
  }

  async saveExtensionsDataIntoScope(components, buildStatus) {
    await (0, _pMapSeries().default)(components, async component => {
      component.buildStatus = buildStatus;
      await this.scope.legacyScope.sources.enrichSource(component);
    });
    await this.scope.legacyScope.objects.persist();
  }

  async exportExtensionsDataIntoScopes(components, buildStatus) {
    const scopeRemotes = await (0, _scopeRemotes().getScopeRemotes)(this.scope.legacyScope);
    const objectListPerScope = {};
    await (0, _pMapSeries().default)(components, async component => {
      component.buildStatus = buildStatus;
      const objects = await this.scope.legacyScope.sources.getObjectsToEnrichSource(component);
      const scopeName = component.scope;
      const objectList = await _objectList().ObjectList.fromBitObjects(objects);

      if (objectListPerScope[scopeName]) {
        objectListPerScope[scopeName].mergeObjectList(objectList);
      } else {
        objectListPerScope[scopeName] = objectList;
      }
    });
    await (0, _pMapSeries().default)(Object.keys(objectListPerScope), async scopeName => {
      const remote = await scopeRemotes.resolve(scopeName, this.scope.legacyScope);
      const objectList = objectListPerScope[scopeName];
      this.logger.setStatusLine(`transferring ${objectList.count()} objects to the remote "${remote.name}"...`);
      await remote.pushMany(objectList, {
        persist: true
      });
    });
  }

  async getComponentIdsToSign(ids) {
    if (!ids.length) {
      ids = await this.scope.listIds();
    } // using `loadMany` instead of `getMany` to make sure component aspects are loaded.


    this.logger.setStatusLine(`loading ${ids.length} components and their aspects...`);
    const components = await this.scope.loadMany(ids);
    this.logger.clearStatusLine();
    const componentsToSign = [];
    const componentsToSkip = [];
    components.forEach(component => {
      if (component.state._consumer.buildStatus === _constants().BuildStatus.Succeed) {
        componentsToSkip.push(component.id);
      } else {
        componentsToSign.push(component.id);
      }
    });
    return {
      componentsToSkip,
      componentsToSign
    };
  }

  static async provider([cli, scope, loggerMain, builder], _, [onPostSignSlot]) {
    const logger = loggerMain.createLogger(_sign2().SignAspect.id);
    const signMain = new SignMain(scope, logger, builder, onPostSignSlot);
    cli.register(new (_sign().SignCmd)(signMain, scope, logger));
    return signMain;
  }

}

exports.SignMain = SignMain;
(0, _defineProperty2().default)(SignMain, "runtime", _cli().MainRuntime);
(0, _defineProperty2().default)(SignMain, "dependencies", [_cli().CLIAspect, _scope().ScopeAspect, _logger().LoggerAspect, _builder().BuilderAspect]);
(0, _defineProperty2().default)(SignMain, "slots", [_harmony().Slot.withType()]);

_sign2().SignAspect.addRuntime(SignMain);

//# sourceMappingURL=sign.main.runtime.js.map