"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.promise.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignCmd = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _component() {
  const data = require("@teambit/component");

  _component = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("@teambit/legacy/dist/constants");

  _constants = function () {
    return data;
  };

  return data;
}

class SignCmd {
  constructor(signMain, scope, logger) {
    this.signMain = signMain;
    this.scope = scope;
    this.logger = logger;
    (0, _defineProperty2().default)(this, "name", 'sign [component...]');
    (0, _defineProperty2().default)(this, "private", true);
    (0, _defineProperty2().default)(this, "description", 'complete the build process for components');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "group", 'development');
    (0, _defineProperty2().default)(this, "options", [['', 'multiple', 'sign components from multiple scopes'], ['', 'always-succeed', 'exit with code 0 even though the build failed'], ['', 'push', 'export the updated objects to the original scopes once done']]);
  }

  async report([components = []], {
    multiple,
    alwaysSucceed,
    push
  }) {
    const componentIds = components.map(c => _component().ComponentID.fromString(c));
    const results = await this.signMain.sign(componentIds, multiple, push);

    if (!results) {
      return _chalk().default.bold('no more components left to sign');
    }

    const status = results.error ? _constants().BuildStatus.Failed : _constants().BuildStatus.Succeed;
    const error = results.error ? `${results.error}\n\n` : '';
    const color = error ? 'red' : 'green';
    const signed = `the following ${results.components.length} component(s) were signed with build-status "${status}"
${results.components.map(c => c.id.toString()).join('\n')}`;
    return {
      data: error + _chalk().default.bold[color](signed),
      code: error && !alwaysSucceed ? 1 : 0
    };
  }

}

exports.SignCmd = SignCmd;

//# sourceMappingURL=sign.cmd.js.map