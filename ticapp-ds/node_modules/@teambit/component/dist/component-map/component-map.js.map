{"version":3,"sources":["component-map.ts"],"names":["ComponentMap","constructor","hashMap","byComponent","component","get","id","toString","components","toArray","map","getValueByComponentId","componentId","tuple","Array","from","values","predicate","tuples","value","newValue","Map","forEach","flattenValue","reduce","acc","concat","filter","asMap","keys","create","rawMap","newMap","data","as"],"mappings":"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","sourcesContent":["import { ComponentID } from '@teambit/component-id';\nimport { Component } from '../component';\n\n/**\n * allows to index components -> values.\n */\nexport class ComponentMap<T> {\n  constructor(readonly hashMap: Map<string, [Component, T]>) {}\n\n  /**\n   * @deprecated please use `get` instead\n   */\n  byComponent(component: Component) {\n    return this.hashMap.get(component.id.toString());\n  }\n\n  get components() {\n    return this.toArray().map(([component]) => component);\n  }\n\n  /**\n   * get a value for a component.\n   */\n  get(component: Component) {\n    return this.hashMap.get(component.id.toString());\n  }\n\n  /**\n   * get a value by the component-id\n   */\n  getValueByComponentId(componentId: ComponentID): T | null {\n    const tuple = this.hashMap.get(componentId.toString());\n    if (!tuple) return null;\n    return tuple[1];\n  }\n\n  /**\n   * returns an array.\n   */\n  toArray() {\n    return Array.from(this.hashMap.values());\n  }\n\n  /**\n   * map entries and return a new component map.\n   */\n  map<NewType>(predicate: (value: T, component: Component) => NewType): ComponentMap<NewType> {\n    const tuples: [string, [Component, NewType]][] = this.toArray().map(([component, value]) => {\n      const newValue = predicate(value, component);\n      return [component.id.toString(), [component, newValue]];\n    });\n\n    return new ComponentMap(new Map(tuples));\n  }\n\n  /**\n   * similar to Array.forEach, but here you get both, the value and the component.\n   */\n  forEach(predicate: (value: T, component: Component) => void): void {\n    this.toArray().forEach(([component, value]) => {\n      predicate(value, component);\n    });\n  }\n\n  /**\n   * flatten values of all components into a single array.\n   */\n  flattenValue(): T[] {\n    return this.toArray().reduce((acc: T[], [, value]) => {\n      acc = acc.concat(value);\n      return acc;\n    }, []);\n  }\n\n  /**\n   * filter all components with empty values and return a new map.\n   */\n  filter(predicate: (value: T) => boolean): ComponentMap<T> {\n    const tuples = this.toArray().filter(([, value]) => {\n      return predicate(value);\n    });\n\n    const asMap: [string, [Component, T]][] = tuples.map(([component, value]) => {\n      return [component.id.toString(), [component, value]];\n    });\n\n    return new ComponentMap(new Map(asMap));\n  }\n\n  /**\n   * get all component ids.\n   */\n  keys() {\n    return this.hashMap.keys();\n  }\n\n  static create<U>(rawMap: [Component, U][]) {\n    const newMap: [string, [Component, U]][] = rawMap.map(([component, data]) => {\n      return [component.id.toString(), [component, data]];\n    });\n    return new ComponentMap(new Map(newMap));\n  }\n\n  /**\n   * create a component map from components and a value predicate.\n   * @param components components to zip into the map.\n   * @param predicate predicate for returning desired value.\n   */\n  static as<U>(components: Component[], predicate: (component: Component) => U): ComponentMap<U> {\n    const tuples: [string, [Component, U]][] = components.map((component) => {\n      return [component.id.toString(), [component, predicate(component)]];\n    });\n\n    return new ComponentMap(new Map(tuples));\n  }\n}\n"]}